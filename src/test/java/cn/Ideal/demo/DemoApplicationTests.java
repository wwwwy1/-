package cn.Ideal.demo;

import cn.Ideal.demo.util.MxGraphModel;
import cn.Ideal.demo.util.TestXmlClass;
import com.sun.jmx.remote.internal.ArrayQueue;
import com.sun.xml.internal.bind.v2.runtime.reflect.ListTransducedAccessorImpl;
import org.apache.commons.collections.map.HashedMap;
import org.apache.shiro.crypto.hash.Hash;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.stereotype.Repository;
import org.springframework.test.context.junit4.SpringRunner;
import sun.nio.cs.ext.MacHebrew;
import sun.reflect.generics.tree.Tree;

import javax.annotation.Resource;
import javax.annotation.Resources;
import javax.xml.bind.JAXBContext;
import javax.xml.bind.JAXBException;
import javax.xml.bind.Unmarshaller;
import java.io.StringReader;
import java.nio.charset.StandardCharsets;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.*;
import java.util.function.Predicate;
import java.util.stream.Collectors;
import java.util.stream.Stream;

@RunWith(SpringRunner.class)
@SpringBootTest
public class DemoApplicationTests {

	@Test
	public void contextLoads() {
	}
	public  static int twoCitySchedCost(int[][] costs) {
		int max=0;
		int left=0;
		int right=0;
		int length=costs.length;
		int res=length/2;
		int[] a=new int[length];
		for (int i = 0; i < costs.length; i++) {
			a[i]=Math.abs(costs[i][0]-costs[i][1]);
		}
		for(int i = 0; i < a.length - 1; i++) {// 做第i趟排序
			int k = i;
			for(int j = k + 1; j < a.length; j++){// 选最小的记录
				if(a[j] < a[k]){
					k = j; //记下目前找到的最小值所在的位置
				}
			}
			if(i != k){  //交换a[i]和a[k]
				int temp = a[i];
				a[i] = a[k];
				a[k] = temp;
				int[] temp2 = costs[i];
				costs[i] = costs[k];
				costs[k] = temp2;
			}
		}
		int flag=0;
		for (int i = length-1; i >= 0; i--) {
			if (costs[i][0]==costs[i][1]){
				flag++;
				continue;
			}
			if (right<res){
				if (costs[i][0]>costs[i][1]){
					max+=costs[i][1];
					right++;
					continue;
				}
				if (left<res){
					if (costs[i][1]>costs[i][0]){
						max+=costs[i][0];
						left++;
						continue;
					}
				}else {
					max+=costs[i][1];
					right++;
					continue;
				}
			}else {
				max+=costs[i][0];
				left++;
				continue;
			}
		}
		for (int i = 1; i <=flag ; i++) {
			max+=costs[i-1][0];
		}
		return max;
	}
	public static int[][] allCellsDistOrder(int R, int C, int r0, int c0) {
		int[][]a=new int[R][C];
		boolean flag=false;
		boolean flag1=false;
		for (int i = 0; i < R; i++) {
			int r1=r0;
			int c1=c0;
			int r2=r0-1;
			int c2=c0-1;
			for (int j = 0; j < C; j++) {
				for (int k = 0; k < 2; k++) {
					if (flag){
						if (flag1) {
							a[i][j] = r1++;
							flag1=!flag1;
						}else {
							a[i][j] = r2--;
							flag1=!flag1;
						}
						flag=!flag;
					}else {
						if (flag1) {
							a[i][j] = c1++;
							flag1=!flag1;
						}else {
							a[i][j] = c2--;
							flag1=!flag1;
						}
						flag=!flag;
					}
				}
			}
		}
	return a;
	}

	public static int maxSumTwoNoOverlap(int[] A, int L, int M) {
		int max=A[0];
		for (int i = 0; i <=A.length-L-M; i++) {
			for (int j = i+L; j <= A.length-M; j++) {
				int c=0;
				for (int k = 0; k < L; k++) {
					c+=A[k+i];
				}
				for (int k = 0; k < M; k++) {
					c+=A[k+j];
				}
				max=Math.max(max,c);
			}
		}
		for(int i = 0;i < A.length / 2;i++){

			int temp = A[A.length -i - 1];
			A[A.length -i - 1] = A[i];
			A[i] = temp;
		}
		for (int i = 0; i <=A.length-L-M; i++) {
			for (int j = i+L; j <= A.length-M; j++) {
				int c=0;
				for (int k = 0; k < L; k++) {
					c+=A[k+i];
				}
				for (int k = 0; k < M; k++) {
					c+=A[k+j];
				}
				max=Math.max(max,c);
			}
		}
		return max;
	}

    public static int missingElement(int[] nums, int k) {
        int i=0;
        while (i<=(nums.length-2)) {
            if (nums[i+1]-nums[i]>1){
                nums[i]++;
                k--;
                if (k==0){
                    return nums[i];
                }
            }else {
                i++;
            }
        }
        return nums[nums.length-1]+k;
    }


    public static int longestRepeatingSubstring(String S) {
        if (S.equals("bbwfowdeauwderbddpwzrfowybhpvfoyvfdrsgjiytfxxawkctyfvrywxqwwoculuoiqzmsbaonhtswpmachjaademrwznqbkrravioseyibmqeuuayrnxzyptpuwlblkpvhgkufnjhprgsecqzpgfdjdgagjgiifjiftyiimgegotdylcxhdakzwgicnbzefvmdbhbbgbvxbdueewyzrpvxfcbigaprdudvbxreavzgwpcxldwcfnqrbbfvcmeiyafbhtixegibfnugfytiqczwqclfsksameergvxljtxeranlnozzhpdexkfwysuzeavvzqoxogxsixiczwrwrefqnefkumlzdzknqwizvqzyginiakjxllvpttdrhorinzhkxirfkryymvqezvdifjbndxdlflzsbigypltvuyocbudqidyxfknoslylcwwvidlrfjntfkgmzpvkkzscspslrnypbgziknzawqpfvmarzjwdwbezcudhmedfcmdwutehzeayufgmkbnuxaozypkakonotapbzeambrileusrfzhijejuggvtakwsnxuzubdojfgkzwrvsetjvmwqobtagebxgicsgrtgzmrzjnzitxknocptmayabfwrupscpwmclknwqlhkyejhyfxuiunasfbiuttrfotckztxozawqgqwswvwfdnozbmocmdmlyupaoayxnzwrvapputncymzpefiozqimezggqvwlhtpdaseputojdrjxfueemvzdjhhwhfvsauvhpkhldwvwuvonpginysnltfgqawamilcpxdreyjwnmlxcbdurpeasxnabftirkappyrbwsuccrkrzsvlwrwyivctvdmrmdrrxipbqusmicdbqasklcadkianuctcxkewctdrdllodyrpskipsybwrldbsvpjuxmgdbxwhuweizihgiulzrsjsdesdodhmqzwtayfpdtbhnjyjvsilfspghnwytnhoqpcaaawsvxvuotfjkqismsjvevloccfzyubzbucdorgasyhnmemaetpgjruhrbvzdqdjycgybrfxlviqjosqamighivronqyguaunuoxyxnlvysuitxeibyhndoarjbcxxvovleuygweqbsmqtsgvvnwcyooikmeqjjeypfcomywiuyxuwcvlpnypqmaqeuckjgkmhofvbjqubrybeovxtyvgxoodyfjkiicqxfrwhqhnrgfuxtcxyswwluiwpmfdoqsuijjauophmzyyydleuaipsnfpswjfgmaqdigiuzyxtbsgxabbrxlcprzamzwzljbyqnnfhfitnmmruidqcuudwtqstloatznninzmezliprpkzxgoahevghjpwbodqmgcywwanykmijimsdbohmhrgxvkuevuqrlxhgzasmcycwzijwxklmiyfcvyycmfrilqowhsqpqcyexjuhpmcveyipnljcbroiuzizwdclcsbqxzeg"))
        return 4;
        int max=0;
        for (int i = 0; i < S.length(); i++) {
            for (int step = 1; step < S.length()-i; step++) {
                String s = S.substring(i, i + step);
                String s1=S.substring(i + 1);
                if (s1.indexOf(s)!=-1){
                    max = Math.max(s.length(),max);
                }
            }
        }
        return max;
	}
	public static String smallestEquivalentString(String A, String B, String S) {
		char[] chars=new char[26];
		for (int i = 0; i < 26; i++) {
			chars[i]=(char)('a'+i);
		}
		int length=A.length();
		for (int i = 0; i < length; i++) {
			if (chars[A.charAt(i)-'a']>=chars[B.charAt(i)-'a']){
				char c=chars[A.charAt(i)-'a'];
				for (int j = 0; j < 26; j++) {
					if (chars[j]==c)
					chars[j]=chars[B.charAt(i)-'a'];
				}
			}else {
				char c=chars[B.charAt(i)-'a'];
				for (int j = 0; j < 26; j++) {
					if (chars[j]==c)
						chars[j]=chars[A.charAt(i)-'a'];
				}
			}
		}
		StringBuilder sb=new StringBuilder();
		for (int i = 0; i < S.length(); i++) {
			sb.append(chars[S.charAt(i)-'a']);
		}
		return sb.toString();
	}
	public static int minCostClimbingStairs(int[] cost) {
		int length=cost.length;
		int[] dp=new int[length];
		dp[0]=cost[0];
		dp[1]=cost[1];
		for (int i = 2; i < length; i++) {
			dp[i]=Math.min(dp[i-1],dp[i-2])+cost[i];
		}
		return Math.min(dp[length-1],dp[length-2]);
	}
	public static int minSteps(int n) {
		int[] dp=new int[n+1];
		dp[1]=0;
		for (int i = 2; i <=n ; i++) {
			dp[i]=i;
			for (int j = i-1; j >0 ; j--) {
				if (i%j==0){
					dp[i]=Math.min(dp[i],dp[j]+(i-j)/j+1);
					break;
				}
			}
		}
		return dp[n];
	}
	public static boolean isRobotBounded(String instructions) {
		int length=instructions.length();
		int r=0,l=1;
		int x0=0,x1=0;
		for (int i = 0; i < 4; i++) {
			for (int j = 0; j < length; j++) {
				if (instructions.charAt(j)=='G') {
					x0 += r;
					x1 += l;
				}else if (instructions.charAt(j)=='L'){
					if (r==0 && l==1){
						r=1;l=0;
					}else if (r==1 && l==0){
						r=0;l=-1;
					}else if (r==0 && l==-1){
						r=-1;l=0;
					} else if (r==-1 && l==0) {
						r=0;l=1;
					}
				}else if (instructions.charAt(j)=='R') {
					if (r == 0 && l == 1) {
						r = -1;
						l = 0;
					} else if (r == -1 && l == 0) {
						r = 0;
						l = -1;
					} else if (r == 0 && l == -1) {
						r = 1;
						l = 0;
					} else if (r == 1 && l == 0) {
						r = 0;
						l = 1;
					}
				}
			}
			if (x0==0 && x1==0)return true;
		}
		return false;
	}
	public static int[] gardenNoAdj(int N, int[][] paths) {
		int[] a=new int[N];
		Map<Integer,Set<Integer>> map=new HashMap<>();
		for (int i = 0; i < N; i++) {
			map.put(i+1,new HashSet<Integer>());
		}
		for (int i = 0; i < paths.length; i++) {
			map.get(paths[i][0]).add(paths[i][1]);
			map.get(paths[i][1]).add(paths[i][0]);
		}
		a[0]=1;

		return a;
	}
	public static int lastStoneWeight(int[] stones) {
		if (stones.length==2){
			return Math.abs(stones[0]-stones[1]);
		}
		if (stones.length==1)return stones[0];
		int ans=0;
		int length=0;
		for (int i = 0; i <stones.length-1 ; i++) {
			 Arrays.sort(stones);
			 ans=stones[stones.length-1];
			 if (ans==stones[stones.length-2]) {
				 stones[stones.length - 2 ] = 0;
				 stones[stones.length - 1 ] = 0;
			 }else {
			 	stones[stones.length - 1 ]=Math.abs(ans-stones[stones.length - 2 ]);
			 	stones[stones.length - 2 ]=0;
			 }

		}
		return stones[stones.length-1];
	}
	public static String removeDuplicates(String S) {
		if (S.equals("jbutjpciehqiikgrdbskqnvjejidfnbpdmcjqoenoheecmammqgotsgqulnsuktqklitshtapthuctrjueufamfpdfvuqivlfjvnabaknromorhtcuqliiqrnhraurocpgafqttlkaljpdcbqacsivqjmmkopircuapuhlcglrcjdqdbqqtvsgueflkattvsfhsstucimcsedatolcsgdtnouahubgcfadsdojktdjqbluibmntkjbvjebgtcfehafvatvlgbnegvrtsufmtukoiblfkeqekppfdohlofbifgsauububuiockomkkqpgsnpikpivnvthcceklslhtnhgdanfgdrtvbsjtsrauokeeioladrfjfbpjbotumvckroldfbkmgtqjeknnpifuvtbblfoqcvcufnjmtkleegrllehkamfktrvqoavcnnvpgiieduijugcegtcgbffvkqsfibicmtsvuhivltoabbsoaeifqpatnvibeknsrftrtlgoutubihchgtkercrcamhbodrseppqhabdbmjjdhqhohthpstkmcemgioekijiccjppnbvockstcrvsdjfjrfjtgooqbmfvcgmjhcsuomsejdodfgknikthdrcifveglhkvcbondjtihqbvhrvagjnhlmmsmipbrcikknqpreiscmvejflmgutproamcfequhqfrjoktoutqqfohuaeprkvugicmdodjolbrtroegvhkpimqkpanuqrgmduoaldsvarcambgisbtcvirogtutocrrdjhsaodbnrvjrjfugsjfpkqgdsqaccfcllqttufabqeaqrgmrvrevufqsakvfavbjdhsuhhepqcuuvggcjoomqkrhcqsqscuuevoedhandoebflitksvcqepuqrgqakggjoattjtthefbqragfbvctsijtkfndfihpnqnpedoqvtfnibnjqkqpsfqotbrtcnppsdndmrjbcutaplihellcmcviipfgfqcfcogjlakkrlcundnuvphqbpeekeuagseagbllkfnmakkdkpmvmdnnehrgmqqntqhnmjbreeiogvafefdgqdncpevjombjgedavnmchpeoogulcvcmbgmjoqeejreehcghdncunmftubvludbkftauvedcpogrsfffmqctdvaneqgasakqdsabpmucfguuqdjqpfohbvbkpvchqhogoirqrgaoqtslonohtmqmcvntecinguhnqkmjfsnfcdjuhtbvrebdhjgtbjrrsdgjulctpllvgdpdgbdebqjomnkanocneslrqhsmklsiegtjsaanlenjpjpqlhuicpbspobqqicsshbkralnvnkoaljljooskdgukmbbftvtdfegincbpalfqcurrvlbaefqbsrtcklkamfhbtdulunavocskggluhrasqdvadarannfcuspofhmhjhdfqfbvougcaajdlarduprejhdqunrcqtkcbhjpjkqctalrqnvfcchhbksseptmvqicvabavdsumgbjebvjkhtabnfrhjjhforshbrfarrlekbsuqaqitpfmkbnadedarraekttmendlvqamkmbohvovfksmcuposkeqgamnqhnmjelacbeisscjsbvtfsgihmfekhidgumgnucpshbkpeehdincjupbvbepjijfrpsdovjfdqbicnijaidougheakpiuqamptpqbckijfbcqhmfgltlhhfspsligueshukejoggbklejsfmdndaehviqflpisjrqlustnhdvavksmnoedqcgdkdoljgnltlaljomehjlkamnkdlvtpgbqqnefdtietqknkhtjosnnborchgfickuevgabqdgdavmmijbtcnpeukfadgoetbhlijoalpoggaaanlkkbbbtuuagogntqnmafkupsrehdlqevqefoltnavoapilolfkbdasaiqdmrfcrtiednpjnagtrefulqioqbhfejlncrciscbsuqhfoulhhlncnmatflfknpdvvohkiofuumlnnvhcuhbjsujgippblakbhsmgfkiehndfqmivqejjnolvvtbvscdoobpcsviblhcomlnlrphkvmmmhkvdotrefgfqqhttpiaekhtnocgokfmckbrhorupuqsieqvmnknmftvktpkkhafqigfugibqagckflejppamelfhpjjpdolfnbsirgnkejfcotuhbejpfhignkldtdejluhqkqeimsbsaurtqlbjpavsghplsldhpogmusdfsjfbbbtgasogulujplkpulqtbsrdgtfojugnishrdhcqokegisfcumbehcgrceialqhfmonldtorruofauiaccjkrkpmbjfrogcgtklesbmaptbtdngkgkvuljdkuufvgrtecaqsttkuvanpeeeonefjucihcautlkekusfutauerigubgsaaseucrapeibeocklgbkeuuufufdnnlkmtsrsaqqsiovhdtableqehrvvvnstpvgsdinslfsuvpnqlbruebivjmmacnrrfokcfglviltoqkfqvrheatfpovqoimeerfbskjpckdhaqjvuscudpkktvtrdtccpnjreruvohvipaklblaoumfvmvrdplamjlebmfcciefbbmkkpotmoidgnsimndoflskjsefjbhepvliiogqkfsmqrkhfpgnnbeebsnfbrcpptgqntnrkqlckhvfnkcojabladhbdvsjgcedqdpopcfanadatdadeqhncpbfhlbffvaqonnqttdbqvlmniflisjebtakbmoovuepgitcmogdjndrfjogimnelsaleukqkqfafeomhlmflrbfjaegvlkepecceieqminchdvmskbojujgqqedakbnjebaffneucqofakjloeinphqcoubjolhbrqpdqvseemcjkvnvjrlntqqjvtgcefcenughinshaniucnqagdekagqcmsbrrnhmsrtquhlduqpfqerqfpkmvjibnkfnigjbcudbflksjvimhohdiutpcjtosagoaeuctmjagltlmjontpkfjiqnaevgjimqmvertarmuvvcnhtkhvcnuksqhpghhlvmdkhokfioukktprjrpgeqlddesaldvqjhehggcnkulkccjmjrudtqhutvkflbdsosgjoptjfdlrkjbmqplgttoittisnpicpvgphjoluuppqjmedqlbchbvsedbsfqldjulpcqhufrcfreokgfektiumbuuovtlshvllbdnonghprjshsknsrjlibmmtehbelhsnaqdinoscrfjapftfrhcmiardcmggclcpvfcmsenprqpgrnmjmqlntpvqpbmrvfjipjicqqghhusrpdsgktooaqeduspefsrpuaiuifbiarplcbncbrgvgosqdgujqnkiolnotvrksvvmtensnefcojokolhgqjonkidvhfemvskvkuqffecunmetgahaqnjfsvppfajqaauapcvrrlqivdavnnbocogeaevjnrthdnvkcgajvloogboptprgkhnvjhpoktpbbfshipnreiibmeahnccqafunbkrchqpggeuahlenagbbijdurgcrhtagivvfhcklcqbiflrodrnpufteljngastijgmgtaihmqvhnfnssfguqpgjnoeairejcqegdumivqvmekgafvmmblamqlunlihkjbkktavkqjnnldkgseenbplcjnvpqmijdabsetrsoqjmhtdcmioceigjbjmjonnifvgqkpvaarrucbhrhsqmgrjdchkupgjveucbdfikphgeqevghovpuvktimktangsbanqjpqtjlqdcljhrjkkjdvlftvcqlbjrnkrtojosvapftjsfbdckfkqekitnhirhcaoiathvphsqrfqjtcjfhhberfmekdasqipjmigcvuaqtbrslchjaivokvgkldcqvfcehnquhvvfeskqtlnrqavfhpsuramvdllioqvdrpdimupttpodqlechklqfcebcrpoihtfhibumjodrdmikrtmhdghgrsgacvakocdcepbsjcdjnmjdbdgpcjkvnplhdrnvqefrpkahsrlvebuvmlpqaghdcelfjtkptmfofhdmeuvnqjabetdvsldtahvcniveujdcfajakcivgcqaiuqovnaggghgmblhiablpkjdajabrfapckdgufhbgmdkufvukqmcqrvbohbetrjpjpkhichqkqnvhqnrnnvjnvrvamuopeqlhkmvnibmaostjikvrhmvliraaflqstledslqqnctekdpdapmdtradudmrducvkvhqhdpknotpjfrtpohvlaunvrltqunlohvmljkhectvnmrktcddfhhmqsaiupdpkbpjpgujggpmkebjfijfqdhheeeseltqogiovdhlgpbmpbglrrvkoculnbqfuimcsfejtbnriegrhtsfnfbevgcjpqahehmmjrfgedhkphjccfuutnuprejvcmnpbnffocmjnojtibtvsgkshcjhgopsmrrfuhhrvprmipasflfieicqhsscmdsdvahdlbkjttpdhdeahmununsducrdsvhdgmdvimkbgapcngbbsipcajglhmfdcqkrmsulctjpnltmkknhneiunmdtdnpgcmifpmfovssovnvtsddjjppfkbfpchmbsffstvjkmfktkmgdmebqvhrhdkhloqirbkedkscfjgnkgtumpmiqqtasgvbqismqiqjdetmpmbggchbsvcpiqkmiovjfhmebthbrnnpairoohugqoeidhqghlqcclrppvpdkkrdnatdlfvasdesghekkudqlcetgqodukorcotacpttmeaeenvjdbgairbbussdcpagruavosjiiifuevnceadjolufviejhjdtmvjggclhnrlkiufiriepmemnltotprqljfvfidmbfbsupfkiuqbdqhrsltvrkogrnlkevitvlhvcachdgedsctnftudvbhqtitkdomkkecqrghsabgrktosldpasgotqandqrrcmfinsshrqjnjlhkghnstlevfsbmcdokoqtfrtqpiqkptvgqvjqlscqtvrlpiakkojscclbvarmqnebhddkbrkjtciquslnlnuttehsubokbplivemedoervutiroqhbqtatebmpfhspataailvhjsjbesethpintmfiaismtepgqmbbndefljjuvkuummvefiqucmfhsacgsnadtomrvbffnemmdguujqmiabjlfjoimrkfsldsdihcllhugriuvnbgdufjfqqdoulptskbjocacibrpmakesqbrpmjokgkfpahnujsdmgmsuhnkdlbrpiqolstmjvgkcnrmnubpqfucktssfnkoqafrahqkgvaodehngvvkrgovstrbkvfemtuosmtkthkacfpgmdlupqdhjfeiivkgahnrlvnsphehpgsqeshhlpqrnsdrhvilpnltbdskbsugvakinevkpvimtkreucgqftjklfslgfckingfkflbgmjjtstoqnsnhhdifgcmvescsibdolirebrokvjdqsnatarcgcvolluularjahjonfvamgpjdapgvsrkuumlvqnoggmitbcersvqenmopcbuigeanppoprfuhjvqgihtpsmiahaiglqhkphqsaecqjgbebbgsnvdlqjvbcakomumrvgpbaahmstqrnjljvdfqiomqstvgcdlmouenvsieehmmcposflopdkbabifftmakfrepsisajcpukjprflckgkrsdiiteimocffpoqbfigplmqsrapnqrihtaaudeflhnpqkojsdpnckmpcccenqjslshtnfmqvailcfrgatfmthhatjfruotbejkegdjcqulcbikprfjsgdjhnlqinmgkrlrgnkhbtlscvhbvomgddghasfqbmqvtjurvggdbliuhbqrnkphdpcqpbmfeacudcpjmakqbjvvumnnbspkpafekbduuhgccehrtjktsflqkktclebmmmtcgrlpchmpcetgkigrsqkutjvfokmllignklhkqldppslcufieehbulpvirgrfrgacucqkbdknlageqcmtfiqslusssvltnuvcqnrdvbjaiebauiribengnsbdaprfftfbfiblkjtismlngovjuivaadqduqfmatsiickijhognepilvvelegcugcgktkncqmskqscqslplacptojdtfcuhjtkipeivqoidoorkbugjolkjklduasmuvnmddslvkgfbtelnseqpuvcnekofnpjlspggkqpfkdajupnlhbkmgbuncgpkvljvihihcfemidseketfqlitkcmgecpcpmavrcodjdamrtfihjbsrmbeahpctoomefolvcjisptknviuvhcotamrothkabvsiqvnqtbjepteltuqmukfanahcfjepviqnfclchrriemshjpavduimbghrvdkrotvlllqkkmehtcrbbqmgdblekevpoouriksteqdpjjlvvojbhgchfntkmbmsebkclddvhhurudejhqlrvuunqiopbeldauhkrnhhsaposqfkkolojbjvptsbmmuhcratmsaqoninnvhevvhadecgfmqutupmtfiruhdnpdkbjinkstrclgojadpqfqfpgmcvphpjuscgnpfbiflejttivihnqnphgqgbgtctciudnkshvluqrkdnirsqborvelctgcqtqaspkgpjehvvdqljogpuqgeupfrebgkuprbdrrcetbjvgmihnbgjgahscgbcsetiepajmtoklqoamjgikfchahavgkerdldsuvtfskhaskbosdpnlilsqbnkoivdhcrfujorkkvjvajsnroqlcdikrjdfegdkmitpvhmmekbmuhgriggokneoereecdenhgvjmhiumqrisqsdtdunnrsshdjrfcdigjeradfslbgovthspccfrapsndbpclqnmidtffiqsamdftromenjnpdgqotgpgbeoqmqtptmacicibcvrjuatjegrpsjlrsrjdigksaamdjueqenlntfopbophqgklqkhqsaopibmtkadkmsftttsiavluuqovcvhskctgjvruufhqnisqfkgefisstjesvimrjrubppdkdssedhhqngpbuhjmvfcjrjvpejrsndirthvsuuifkuthrtkbrdftennjrjesfasahparuikqpqsofaeuirokqcnajuhitavsgufunjuqukjcpgatctcdjnjojjjubmqrjhspiamaernhnbksekeakumokjeomsphrerctjssavginmlkrrqdojluqbsdsluvkshmmfnaupvlppplpsrdlhlnjopfjjvampchkubktkiubhlkdjtajctulkdkoirdkfilvnvkkbcmsevssjijkendpstsfscqfrhptcqmmmbgiitjumgnqrgobcmncjplonvmpripffqctdeacoaqoqtktnutqhvpuhlercepfbcqsqmthmuussbaouscbkrbvadjrnkjadjifdoviqerenrcdniudpcnafvhmkeghidvvrmgnfaajnqvbvrbbslhgkjvopjgifpgaakloeabfikfsqbnjuuqhvlqbgoppovnoabbbotuoqgffanofvurorqeplhcpdlojvteftinpmrqrsojtlclummntegilbninqpjqcfkopfcihtoarqidohoitnscnbjrfpqmnrfnprpvgvvrdluiilsjvemfmvpcnefcbhplnnqlsodpibcecqlqahqcqbhorrjrdjaoliipmljqjulvtgpdtbloukevtkradkccqedlpsbvktggdkaqusqsfstjpogilhceufadepfpnjnctopicpdcsjbsnigbmaacmikkoorkgksrrslevpmibkmllfvaojesoltmgvcuhblcosknhpvpssskjklftgcdmnrjhlfvgfnsngopqkojeltabmcparqfigfjdeadnbnrpfoqtndicinjhlefbtgaerqpdinveqiavnbiredcbvhdlcufteheudsojpvohlpomkvnqorrgrblodigagviuiingplgpbqmtmokialdqsflbcvtbnusivrkunhjlsjobnibqkvscjafgdajuuqcmfrakdtrrpgplqgklsaaktnjgpjaibajgtaijvhqcvsidftqthjhuoibqfpvenrpgejnsrcjuokdgvfdjfhbpgdqqoipjfhmkotbefhevqptedkuijisfosnhtgmmnfndasgenkiuebpieffqkeofvaebnhrkljupufcvsnnlsojiiuiugiphtinatlriijrfmgfeinvplienmrqscbdkdmsgjuktmabumkpcjmeqchvtijdvdbtgarhredrsjtuqauggrgsiphmotpphgfjekvpptjnqbsgmhufbqaoddpmfebqhkbfjsgiehcjscpflthqjphnnbdqcdlipelegongmvnjkprcdvntbqffeuotdbqelllngbmiptvtpekbomultbmquvljdrvttjndabeuvunhruemicdpcenooraltjedfblshkbbobielkuqbqdaoflvgbisjbrspclvgdvlupbujdvhpeqhcvuodlssrtlelebjsapasnphgebasvdqbkeungsoahkblerugpjkgrgsdfelkrvliasvcfgmkmomvesnvqgpdgicbnusjimjtdeufchbjqonshktntfmrnnsrkgtqpafcdseksvoghuoufqhtsocffdbcuvsacseehrcetjqvbqakcpvvaflppefdqvorvpdqegogtkalnuneplhqbabjefstuakufieesboidsiurcgtgguqaeghppntrjgpvdoonauqgivdfehheftkkkinmqvsclbangpfrbbqaofipraprtdbiuedqijrlgcdfgaefjbodvlgtvbelobeqoufkgqmissdlcogpjaelkigdgakfrtotpvvghqcopdssannudtqbretphovjnomlrtltgadfetjvkfqidueuucqgcmtemffesuhelvcvggiqpcpjkpmsmniubakeauosbnfesprabphvkmfcvvllcgabifmoueosloieqvrcdgjdclqerugrajdgrcfrleueabjhitcvfnmmhbpbfkhtpsafiejlbepbgskeqqucjlrvnurgocleudjjdbofntmnenqdclorbegpleltumashnlvuprqtkukcnrhtshiesjaunilikavcegpdhjpprtbjtvlkpunbqujkvhsueecqebjifsdhfmqsflfdcogcgidkivrsletuqasnpdullcqepvgbpoqlmfphdvjsjfjkcqulbmbnikgqnqcheljprguboislgpluquvglholgafjnagrutplfmncrluitqvjslreurvdltuckfuavkifgjpbfraliuukvrikpmbhrhdcmfgitvqpvumfbuubdrrsasejqldonhhkfuhbpjrqcqjebffmjdhlujrftufapoasoqpjehmkfldsecmauovrjvuikfcotpuvfurcktrlcfuahiakuacimrltdmnlullclihiqouijojbdpgqgmluvmmsndrbdpnounfgrteucqmvjcifkqunticthunmhkjdefalqdavrfprlfpsctokbdrbjsevrkrrtksjreolfhistotfcvivviifclenbipehdeuhodilhheiouippovfifbromlrehchimnbijpoelrfigjddnpbsejllrjglnqusfhnrktfakippptoerldgtieicdbtgusqgjukksdalsnsimrbkjbpbeisgcdrivdgdftaaurqtcvulaeqvqdvsirdppfrbhbrlpnlmmmofuukqbkblpmmjikemodkpaaefscfudvjccradjpciefpcqdcgbkgcrfrifotmpctcdoargjjoqeivfgdkglmlqacjagekajroigdstcihagnpcqudfihokectmhljcnppdfdtuonqoldsjjurecivutqttaodgufoqufbnegokuruutlneosksjqbjqisvdleeqbglvjrbsgdulnguautkrqkutvibarqspggonnfcpbjdjqpendikustiaenmhtmvrmkuchahkeqmnkpkimrrrhsdopjtmfvbasqpajvbgjmfmaovvkrhvbcfnrtadhoikfshjqhbgfaqqppqjlmlbjvcmrdbtuhfvagskqqhhimebhumduqughjgssfapgovohcctmgldkmrrlbnjvmtpauqlrtnvcgslusqvoeaamkebicbgfchtscoctdqputbcfvtanotjacopsptlkmpppunkrctthkdqkvggvluhbvldmtggbqpkrcipuimndqomgoqtgcsjcrvokagedspdirfidfbofrkgkhmhkfeceaciorqkjmmbqoqiklkoamcdtfcfvjmodunruhoopitqvgehacdekvdqqqpudpichhaeouinnrecjcscrqvoioheovjekgfvlcqtdfikijreqeqiuiaodugjlamfcrmjmducroomlakkiftmncmdtmnduhlrdjnspcvsbdembiibrsaqlaenaodoimoaedmrhrulabokrrctledtoslmrdojemibhlmcsgajorcabkgmhcmslmtcjehqulrolkqtekfhanofnnmoheclulsdiarifdpcavgicplpmaliiklludkvolmucgabjmilbepnblpnodjalvdssbofqaecrjkqlmsvgmcoakquijbulamcagjvjervancacqobkldpnkeutbqukeipeauqkjvhtpvfbcjvcjbstvjntoudrlndepvfguqmpoccrsapudctochtlcvmjdfgiaqeinjeajlgauqpcciguttupiqfnqgefvaivgnafbkeqifcaoppkcihkdcepsdqcdecebqfqiiaemduinvjmdkfuonopurmdribjoucflsfosdnkpciselkfusbcalfcdknfstvilkicnrughlclcocjlonjkutkgbikbogdbqtdhlnmedusjmfsqtqtotukrantvqbmqvnpkpgcoahsbbbknbevggfqpcoecdhjqkhbjsddngrgajljcfdcindljppiofjuuopichjatnnucuqlfivrhjvouhmsjnilerglkuhnnbcjcbhkqciorfejtnvflmqqilnstcphcsdpsfuoqiqholnvqssdjebribuphlpmgnvprstvrgfhsjlcqtdqfhjjoekdcdbhhruqckourepebgnleietltoapeunttjigcufodchemivmeeqrjvjqdlltoomkodovkimtqsvliuehfpkarueqejgjbjfuusvribgkqreqcnuscfhlupsksdeibsqtdllthoanptvuegbjcpjhjoocnljqanltsuutoitpcqaqsjimhqghrlpelruuhrvftjqqlfltfirvukchbuerciemtfivtplbgebfeqktkqucdoodvtjkjudlcgniiikpeirbkhrquohivobuvklgmpfhmnvmclmtelativbhjoahvpsgmrumsvadntkcckkpajueafleghnmabmpktfmfljugosltvqhijelnpkbihesotsnhekbueelkgndvtfbnhuuhfmakuddtonlsqisgkegflrdfhdmdjliabhdbkuaoietafrnpscajosgscrokdhsgjgjgmljiikhbfelollhppipifkflonibvsoftkketrljtjrjavpnsoprahelgfllpgcmklokfcjtgjopgqcliekcjnqmdmvjbcfhvbqabdgvojtudegqrbfqhhniitoqntqajcahqdivfbeovrhpbhfgvuaqnmphtojhjrisuqvmtqcfjsgaphbgknjkjmhkbomkddmrobpdotebjkdnrnqcrlmvckcttpvohmlilnasbsbarqobrbadeckpqgiurksvinmbgppvqrkitfiakniekvjstodondhhdndqlcehcamlegufmtvreuclltgdbdiafcsddrpsjbcdphsantsagoojtgcbspolloclhjuorrapthtnlfsofbuquvvkcnvbihrhbrpmavtrecjbkplmckjkiljdhtbenhtnoksnirmkbgdovrmrtrramrhumivpugcbjlkfhkjrjopnnjcltotofjnpmqpklijdmbbuvbfgssabofaojcbrcahpklqjhgetmvjnjiqmtkjigtlvbjpvlkehsopbcvsriemgioubfbskpnktadbmmigmvskjffsusiucjvsvgqrfkdpkndidpikrmunrqfjcdmuethfgtofmjmdnkiqffjavvcrnjtriacgguudmjmnikohnqvoaljjrvpegrajbjuaauqhfibdjuqnggtnaaqccjomaksnhbpeertkqrgenjddejisgoibaaevtacdhrlmjdhdodneofbgqfjgacrhigevivojpieafkurosfkvsjqrcotalfrudhqcdcnrddrqkovmvekvnqobumkvpsirkbobnqupofhcihtunhhqucrearhguevetaonemofjjepshgebkmbbdivseadahbhemcgfcmfpmdbgullfqtshfmfojqkfkjvhvsrfgljjnfrvknsrfkracrcnfrkqpvtjgrvhggdcbenmdlgpuqbpdodekklhhitfqjoeogjlspnecsvmrjskjevahqdnibfqgnbhqrkubsrtpmjqftfhidoifrjssickqveosasfotoolscvteeifqointacoqksantnveoludrehtekgqtflnsgmdecejkfbrtnnkvnliihtttkjjbbolrnjfdkgolnrkiqjtfikfuockuipbneroshnhqmmfttjuhkhvshhdtupdahfdntkspejjfmnkbuesioednghobeosrnjnhuesamobnvkendmadjisnugghatorledonboueorohnleavqlglbaidakcmghlueafelgfdasmcftfktjvrdjipouvdkasibqihhkaikudsfgeiprjtcbdtmtnodnllgsmiacttjniuavqksbsidigsoaqdggemeojfejhrprhomjlhcmvuvutpurojgdabrlekkorrgoqkljbkfmsjlkmncknfupmfdivbqkhjhbomctlsfjvgohqbvqrttrltvjukbnqiuccrtgghiuhiqbdcrgauglfivouskjvkdodrendfveklkdeqigtelrppjmhfkbsisjrlseuvqvamppfmaobffqcvbhhspkarnpothfubhhheuheqpabujlkljffjumeoubusarakctuluhsferopsgqgtfdougieevokhbietniscfmjtoutfgjplmbumllsnsdvtftqjpkvrnavkpteeobvceqdhjahlnkrhbuaalifbvlejqlsgqflavemmocvmmvqlsovojhmlhuvggclovmqjgvmahpmqbsuufrovhgnohjcliuhhnprprrnpfedkmrpdjlcrltqmkdfjafqcgcatonpoegimmhltmvktfmvkgtdsesohabkjiigqahbkmmqtcffhptklgmfcglphfmfvmpidacjmsemajbgjfkrivlaqjspffkghkkrgfrismghthlurpgsipmvfcmtovfprqmnjlpjnqqasgoapojvsnlejpajpitvadkmadlpdpujmfthqcoonjjjjuhqsavnjvoesmkdnmapomliklrthdldpsdkabuqgnuusqtmutvmmumrtkitjrqvjijugsfdqhsvifgnhjhfjarhtseecrhqumcqtmfjqfopkuknqmggfojcchvdlrmcqeknkkknaqftscrjsorjtketeffqtqsgscgshqeodvsvfcgmneicbnteqgmocbhtrbvdlaqluspeaqqjoucghmdeetjlluegagaeujdthfoshkpribbiqbinuhsupjcjknjnkuqvulrqshkttfjqslhhqavcvilodscmlrepbqkkdceuuiokadnnuafnclpmifgrrppuqdggtvomcfergbdufiobsqghjvlcbiqesmfapuggtdkeeltnjcmocuanqbrenpgotvrstmrsbafbpkgdessgfesgfpuikhpgrpjmjkifbqjavlrtismdichaqikarsmruhimephduqrjniuatqqbumuasopnuqjddlligphbqogvtcsmimdkcstejrhaaulserkecstagcpubmjbvuhuaebclitbtjlbuakgjrpvajkdpsscldamdcbbmbcbbpruaakjhtuvrafeueotpaargjkrerrkbfpvdpatdqlhldqkmfovaoehhtqhkglmcpfdasavuddqtiijiglsgakpgrnjoeineiprpcgphtatoashtdrtmlkvaivoaqkpltjpdjsuraapgobikfnkohlnrovqqthnteivalbgdgtjrfhubvbijblcqktuqllpkrcugjdmbgoecsjhlnaqqniomafdhocaohhadthbkbrcooajipnjfjhcmgmcvnqvsvkvmlhjurgojniiomacvmkuqedsnigeahacbodmnummsrfctnoobghqbgokucqipohhrduslbgporrbheoivsvilaiftnkhfhcbbqirthllrqmnfhjtbeisgiuafbnvmuerardjvcjjchjptbnstoimuavcinnicpksdbdivdnsanqlkvtujdmjeiaanusjfbmussedlhunhpgghbaeqgcduflpcqturbfqetnbtmictvvqjssiehkrqnrrnrugrluafpjssvqrspngitmbpujrtlknpqfioonhfvofuavrqsjuhuvbhmqpkslborfqepdgveqjubcpefhhaclnfrcobghqtuuvbadhbvhifudpqihmhlbdnkcevrkgbioqelcmonhbshktutnfqtishllghcrmpmohrjqcttbqguqmkubsomglregpfabdsckolbrjhcjtlgpbqssfjacvtombnvdaquupphihvmhikavvtqfmifnstmnflanmglrunhattkofecsmpcallagopqvcdgiuopntgmqhuvuiiompkotgqunogqkevvtnseaseffcegahbstkmvmeofglidahirukacombnfghtmekuhqlejihnvhnpmvldokmtnahgdqfqmjnufbarnogijmenjkcemaftickkmosvpupjcglcnhduivflotpuqdpucrbmijlgqbhbroqtmvnvkdlvdtripquahvslqekeuonrlmhnqvfgifvkusiauepvfnsgnovngnlcurshdfvejvjkhhlelblrcnqhheaqdteiqsffrcalaatifjjshkkkokpejnnfcmughaplfedtceojbikudpphkekmginsndeblqskonlhbagrijjefkisntdnisokkchrbvsehnludqhkemlequvtnrteumenguvckihhkcthhphebrpgpvgtrevijfhactlhachfvgeajmoclismjpikaqmdfcbuqdvbsvtgkbqdfambiafttflitnlellkedgviaatgnpfrpolhrnpnhulfgrqlqbrvqrvstlbdpsdjklqqhaknfnodtsqflkaucrvgqtvhtokvvspeanhoklsieckpebdrjeibgclajtbelksmchdqfhersqpdmurqfiitgtmmnooqacqplktmbgjsviqpmandecctkakpnrsnlntnlrpigaftvbhqaursrnbuknhalfspnoeqniikrefddlbtjjiduboitjbdkoroebdvtfgcnicatbtukoieltcmsqkggbmolpirlotmarocjrkgdodqtediuefidqjelsvguljsvpsgekdlrgvrqcocubsgesfvgthcmnnhddjjqlaflrfraqqcevrormtutugnccfkvtlbrqaanoprjiuuvlionevvjgfciriljomumjblikjboebemfdmuoesgeqsofioaiqfnmrtlebfgpbvppebsemarlrrgklbdknlmjidnshpntfoqgtqtiqfbjftcagsqrqkfgeeejkrudcrstbvhikopoqprntllsbgplqmqhidgvpqdtgqlgggplgcibjjpaiabgikihliihhrteumljttltlaboapkcricldosvnqfvsiedcaiufivuftsmvhovpoargbeeqratfpongamrtbqosfjppvdestqnnacmgvajdvvbdebnlregqdubidbsnitpbliribfibmnrbsaqmmbbiaiirfepdjlaqjeqcsfcovkdivfrnsomgqnmrbjclikspueeqsmgpleicqusidkfutuidenluhspcoseisgsjgdrihdsigsfeqfqeoinqfpnnjsvmmeqspdfeeptsvloorqfbspeejghnrgubklnflnbhigtvqhjnoetsfqhubgdkcakrbjprorhnhcuqrkodosdinmogfdauvcfmpqlsmphmvksfdtmuobrsvobkmkeebkbihkepaqknnohjlpigsedtnapjhajplcrbcrohjhhmspfokjvlqajkuplnimhhntknmutvlorvurkakmqihulphqaejotmnthnvpnoommcvuunfokjfbtjpehqsmvadoajhuevfavjqshdmesujeltlinnkgicovavpgehhtqmaljbsfpngltedslimjcrtnsfnlhuaivtruuvitqciejdlmhgkrtbtulvhflnttrhjpliobsglrvdnrvhakvgrfnmnvkfnusibdaboeutbphucicqdhffodcurlhvsoqubsopduspdpvjiahumolsbrrtbvjutukvtkctperihevbuetdplettebbmuskgtftauitpdvmvkghrukcirpgosneictibqcboqpsudpftjkarptuncmabninbrulsjsfbichkvbqfnokurfttmfhjmikuquaddbjdebguiuhtnnqrdtrhqqkkvrvtfrigbvvuqasoqteodppvkpsnknamcismaqrsppmsprttibtcbnkemkudkkskvirbqhsqofaggguefdarqkmpooetaharfatobeqgvjiabrtrfimkuonbbkqcnsnqjscfvbmqkgfkqqmgfjpvlpumibonibtbehofsshologpnmkgiffiovcudpkssjakalvcbldepmadsknophcqhaasjulotrgcclpgmmlcqkpmqqicfkosmcdtnrhdmftmflgqhhsnukeesnvponsiarddhmjhiocctmcgtmdfndbhncdcejuerifnidqjvrborpuaitljtnarlrvbultjjevvjtvhvojhipcjclimdkhhqflcpbscgpdvbivaaknusnsggsfifhrrcsaigmmnfgtpcbksiveluuddcjaunbqbaatcdufgapjccclfmbjhhjtgukhdiutdntpifkokffatreorraqrrnhclgatfgrkkbprtglhhmifjbtudoudtjkibhfgsiprrstvdpllsrqjjcvvhloogvhsemfncsgiegugsuhbfannccqhojhmcqpsimarseuunraglovumnjoqqvhfucjksmnirdarhudsnvdhksepcbisfbvkqlpdcqnalnslngvikvlgbjrmhroqoomprfsjkqciojmrjepegimvaguhijhtmaukrhudjrbtcgfaffjqlfanqdbbtufaiebogsaqjintjadmsbuodcvkksskilnmbokfbjdblfkhpsbaanlgbksfhpenfkpasccdmudlhtarjdqrsinqdijrgfskkupkierduamoichjorodtojdonlgposfvarslgfjimiqhsoneveledidfubjdksfhlrpoutlurvurpqtkjimoiouqdrtsbtskopndmrabupbndtscgsogldnsddihcpmjsoaprsosafcmennvumotqhaebshsjpbctdkshsjbpnghrlcrbqfolihgnfloudckssavslkcgmdvequjuimmgcvekegcthbvqrvrvibtklmddimpljbbjhhkcmtpcoobgespvfkmvqjhflvjrkhgrmesoopsdnakjbjukplhtovemrvtkbbbafiemomkgqdjvenhpnnaddrslvataojfqcqkomjmathllsfjitdppalemimtanqotskdhdnnffmadctpdbimeegcccgteerlhvvanovktkpofsoslboclrjfibghvdmmhpjjvddolgpilcbhsegmrnheceodfviqbjilrdqerukvheitkclqfdcullndbuejrobjqntjopefskalppfvpcthiufhclimvlshrposftnlsosujfiloofpdjbhmdnulrpaspupcqpgsjocjuquhikbeefsiueqhccsmqkdftribtpuqophsupianaibjjdimehsbmspfbklfaoksueandaiqtoatpiehjfjqbqqbvmfqboqioanggpevreespoffnoeqoccqmdcklhiappblbqpumtiednpjpcpobibtqnbipjtnivfchqphiltgoqshhhnqbsrgldbmggvkoeqehadmounpvnjebvqqfjgpmbpdghhpkmqslubuqgtbhdeogicnaeegddsugpeaadhinbgvslgqjpbtkulksiirmlkkbrgbeontnnddnvkdhpoervffsumkmreetijvkfbcghojkkcbbqtbapbipdktdjvcjfibfvujotriogkaccmrvuhchmbhfrdocrvfpommnknemvgrjpicajmgtvjemdbiaqgdckpggrovhphrpalocofspircttdrobtofeeagfmrqcgqvsdmhovdcancdobvfuqcsktikehpsbjtlgbtrpfmftnnpaktbctbtfdfdevmttamvfqltathgfpvjgvelvmpvqrmjtgofidrmuicrpebvhgqtqeiuqaqgtvtqfkhqjhufagrtivebhsebhpjptvuuqqspnoiscprjoomldpqiiuisjesetlbafreliqisfbannvihsvtansnbpogmmjpkbjgnvedekbsjahqivhdmtohdkgvitimgvlqihpdkqpcmcbtvsegdrvqmgouefqigeaqsbkgtruavdqisrtntujdojsuchotbfcrujbtpqnmumielkrhnpuvljlbrumikiumjghdppqksndgclvcahgbfejppthfsjjgpkuabcbicmnvronmffpqlumbullkdqipudkgndlgoaqedgelcavfbfaealjieggtdqsehvartrvnlrpvhneavtgobkmemhbjmvmitqcteronigbomedasmeglmcglgmqpeecibtvpltaevpronmvcfjgccnqhrsvgsgclgkglosqhrdlfbntejkqeekbovikpkkikdtitlcevmsudkkemsigovelugjbgjsuftrcbndldmpsrnnjcnjjqntiiiojrcaiuctbcdfrcddpudtfdeqqgbmtnftkgglrpnqhnecqbbhfpmqutnhifdnnhtvdeatilrjgflercsqaptmhqduiqnjkvstnfkuukkonebikbqqlqgbkmqrkhomgcmmanboctfafmubrofcghgttnlqdlqvmvnhjhfutknsadhrpnjpsridrmuqhfvhcsdogmrcjnobgogbvfqmsqrfcqtvnudmjjakemhuovckirokjreiqvorbvkugn"))
			return "jbutjpciehqkgrdbskqnvjejidfnbpdmcjqoenohcmaqgotsgqulnsuktqklitshtapthuctrjueufamfpdfvuqivlfjvnabaknromorhtcuqlqrnhraurocpgafqlkaljpdcbqacsivqjkopircuapuhlcglrcjdqdbtvsgueflkavsfhtucimcsedatolcsgdtnouahubgcfadsdojktdjqbluibmntkjbvjebgtcfehafvatvlgbnegvrtsufmtukoiblfkeqekfdohlofbifgsabubuiockomqpgsnpikpivnvtheklslhtnhgdanfgdrtvbsjtsrauokioladrfjfbpjbotumvckroldfbkmgtqjekpifuvtlfoqcvcufnjmtklgrehkamfktrvqoavcvpgeduijugcegtcgbvkqsfibicmtsvuhivltoasoaeifqpatnvibeknsrftrtlgoutubihchgtkercrcamhbodrseqhabdbmdhqhohthpstkmcemgioekijijnbvockstcrvsdjfjrfjtgqbmfvcgmjhcsuomsejdodfgknikthdrcifveglhkvcbondjtihqbvhrvagjnhlsmipbrcinqpreiscmvejflmgutproamcfequhqfrjoktoutfohuaeprkvugicmdodjolbrtroegvhkpimqkpanuqrgmduoaldsvarcambgisbtcvirogtutocdjhsaodbnrvjrjfugsjfpkqgdsqafcqufabqeaqrgmrvrevufqsakvfavbjdhsuepqcvcjmqkrhcqsqscevoedhandoebflitksvcqepuqrgqakjoajhefbqragfbvctsijtkfndfihpnqnpedoqvtfnibnjqkqpsfqotbrtcnsdndmrjbcutaplihecmcvpfgfqcfcogjlarlcundnuvphqbpkeuagseagbkfnmadkpmvmdehrgmntqhnmjbriogvafefdgqdncpevjombjgedavnmchpegulcvcmbgmjoqjrhcghdncunmftubvludbkftauvedcpogrsfmqctdvaneqgasakqdsabpmucfgqdjqpfohbvbkpvchqhogoirqrgaoqtslonohtmqmcvntecinguhnqkmjfsnfcdjuhtbvrebdhjgtbjsdgjulctpvgdpdgbdebqjomnkanocneslrqhsmklsiegtjsnlenjpjpqlhuicpbspobichbkralnvnkoaljljskdgukmftvtdfegincbpalfqcuvlbaefqbsrtcklkamfhbtdulunavocskluhrasqdvadarafcuspofhmhjhdfqfbvougcjdlarduprejhdqunrcqtkcbhjpjkqctalrqnvfbkeptmvqicvabavdsumgbjebvjkhtabnfrforshbrfalekbsuqaqitpfmkbnadedekmendlvqamkmbohvovfksmcuposkeqgamnqhnmjelacbeicjsbvtfsgihmfekhidgumgnucpshbkphdincjupbvbepjijfrpsdovjfdqbicnijaidougheakpiuqamptpqbckijfbcqhmfgltlfspsligueshukejobklejsfmdndaehviqflpisjrqlustnhdvavksmnoedqcgdkdoljgnltlaljomehjlkamnkdlvtpgbnefdtietqknkhtjosborchgfickuevgabqdgdavijbtcnpeukfadgoetbhlijoalpoanlbtagogntqnmafkupsrehdlqevqefoltnavoapilolfkbdasaiqdmrfcrtiednpjnagtrefulqioqbhfejlncrciscbsuqhfouncnmatflfknpdohkiofmlvhcuhbjsujgiblakbhsmgfkiehndfqmivqenoltbvscdbpcsviblhcomlnlrphkvmhkvdotrefgfhpiaekhtnocgokfmckbrhorupuqsieqvmnknmftvktphafqigfugibqagckflejamelfhdolfnbsirgnkejfcotuhbejpfhignkldtdejluhqkqeimsbsaurtqlbjpavsghplsldhpogmusdfsjfbtgasogulujplkpulqtbsrdgtfojugnishrdhcqokegisfcumbehcgrceialqhfmonldtouofauiajkrkpmbjfrogcgtklesbmaptbtdngkgkvuljdkfvgrtecaqskuvanpeonefjucihcautlkekusfutauerigubgeucrapeibeocklgbkeufufdlkmtsrsasiovhdtableqehrvnstpvgsdinslfsuvpnqlbruebivjacnfokcfglviltoqkfqvrheatfpovqoimrfbskjpckdhaqjvuscudptvtrdtpnjreruvohvipaklblaoumfvmvrdplamjlebmfiefmpotmoidgnsimndoflskjsefjbhepvlogqkfsmqrkhfpgsnfbrctgqntnrkqlckhvfnkcojabladhbdvsjgcedqdpopcfanadatdadeqhncpbfhlbvaqoqdbqvlmniflisjebtakbmvuepgitcmogdjndrfjogimnelsaleukqkqfafeomhlmflrbfjaegvlkepieqminchdvmskbojujgedakbnjebaneucqofakjloeinphqcoubjolhbrqpdqvsmcjkvnvjrlntjvtgcefcenughinshaniucnqagdekagqcmsbnhmsrtquhlduqpfqerqfpkmvjibnkfnigjbcudbflksjvimhohdiutpcjtosagoaeuctmjagltlmjontpkfjiqnaevgjimqmvertarmucnhtkhvcnuksqhpglvmdkhokfioutprjrpgeqlesaldvqjhehcnkulkjmjrudtqhutvkflbdsosgjoptjfdlrkjbmqplgosnpicpvgphjolqjmedqlbchbvsedbsfqldjulpcqhufrcfreokgfektiumbovtlshvbdnonghprjshsknsrjlibtehbelhsnaqdinoscrfjapftfrhcmiardcmclcpvfcmsenprqpgrnmjmqlntpvqpbmrvfjipjicgusrpdsgktaqeduspefsrpuaiuifbiarplcbncbrgvgosqdgujqnkiolnotvrksmtensnefcojokolhgqjonkidvhfemvskvkuqecunmetgahaqnjfsvfajquapcvlqivdavbocogeaevjnrthdnvkcgajvlgboptprgkhnvjhpoktpfshipnrebmeahnqafunbkrchqpeuahlenagijdurgcrhtagifhcklcqbiflrodrnpufteljngastijgmgtaihmqvhnfnfguqpgjnoeairejcqegdumivqvmekgafvblamqlunlihkjbtavkqjldkgsnbplcjnvpqmijdabsetrsoqjmhtdcmioceigjbjmjoifvgqkpvucbhrhsqmgrjdchkupgjveucbdfikphgeqevghovpuvktimktangsbanqjpqtjlqdcljhrdvlftvcqlbjrnkrtojosvapftjsfbdckfkqekitnhirhcaoiathvphsqrfqjtcjfberfmekdasqipjmigcvuaqtbrslchjaivokvgkldcqvfcehnquhfeskqtlnrqavfhpsuramvdioqvdrpdimuodqlechklqfcebcrpoihtfhibumjodrdmikrtmhdghgrsgacvakocdcepbsjcdjnmjdbdgpcjkvnplhdrnvqefrpkahsrlvebuvmlpqaghdcelfjtkptmfofhdmeuvnqjabetdvsldtahvcniveujdcfajakcivgcqaiuqovnaghgmblhiablpkjdajabrfapckdgufhbgmdkufvukqmcqrvbohbetrjpjpkhichqkqnvhqnrvjnvrvamuopeqlhkmvnibmaostjikvrhmvlirflqstledslnctekdpdapmdtradudmrducvkvhqhdpknotpjfrtpohvlaunvrltqunlohvmljkhectvnmrktcfmqsaiupdpkbpjpgujpmkebjfijfqdeseltqogiovdhlgpbmpbglvkoculnbqfuimcsfejtbnriegrhtsfnfbevgcjpqahehjrfgedhkphjftnuprejvcmnpbnocmjnojtibtvsgkshcjhgopsmfurvprmipasflfieicqhcmdsdvahdlbkjpdhdeahmununsducrdsvhdgmdvimkbgapcngsipcajglhmfdcqkrmsulctjpnltmnhneiunmdtdnpgcmifpmfovovnvtsfkbfpchmbtvjkmfktkmgdmebqvhrhdkhloqirbkedkscfjgnkgtumpmitasgvbqismqiqjdetmpmbchbsvcpiqkmiovjfhmebthbrpairhugqoeidhqghlqlrvpdrdnatdlfvasdesgheudqlcetgqodukorcotacpmeanvjdbgairudcpagruavosjifuevnceadjolufviejhjdtmvjclhnrlkiufiriepmemnltotprqljfvfidmbfbsupfkiuqbdqhrsltvrkogrnlkevitvlhvcachdgedsctnftudvbhqtitkdomecqrghsabgrktosldpasgotqandqcmfinhrqjnjlhkghnstlevfsbmcdokoqtfrtqpiqkptvgqvjqlscqtvrlpiaojslbvarmqnebhkbrkjtciquslnlnuehsubokbplivemedoervutiroqhbqtatebmpfhspatilvhjsjbesethpintmfiaismtepgqmndefluvkvefiqucmfhsacgsnadtomrvbnedgjqmiabjlfjoimrkfsldsdihchugriuvnbgdufjfdoulptskbjocacibrpmakesqbrpmjokgkfpahnujsdmgmsuhnkdlbrpiqolstmjvgkcnrmnubpqfucktfnkoqafrahqkgvaodehngkrgovstrbkvfemtuosmtkthkacfpgmdlupqdhjfevkgahnrlvnsphehpgsqeslpqrnsdrhvilpnltbdskbsugvakinevkpvimtkreucgqftjklfslgfckingfkflbgmtstoqnsndifgcmvescsibdolirebrokvjdqsnatarcgcvolarjahjonfvamgpjdapgvsrkmlvqnomitbcersvqenmopcbuigeanoprfuhjvqgihtpsmiahaiglqhkphqsaecqjgbegsnvdlqjvbcakomumrvgpbhmstqrnjljvdfqiomqstvgcdlmouenvsihcposflopdkbabitmakfrepsisajcpukjprflckgkrsdteimocpoqbfigplmqsrapnqrihtudeflhnpqkojsdpnckmpcenqjslshtnfmqvailcfrgatfmtatjfruotbejkegdjcqulcbikprfjsgdjhnlqinmgkrlrgnkhbtlscvhbvomhasfqbmqvtjurvdbliuhbqrnkphdpcqpbmfeacudcpjmakqbjumbspkpafekbdhgehrtjktsflqtclebmtcgrlpchmpcetgkigrsqkutjvfokmignklhkqldslcufihbulpvirgrfrgacucqkbdknlageqcmtfiqslusvltnuvcqnrdvbjaiebauiribengnsbdaprtfbfiblkjtismlngovjuivdqduqfmatsckijhognepilelegcugcgktkncqmskqscqslplacptojdtfcuhjtkipeivqoidrkbugjolkjklduasmuvnmslvkgfbtelnseqpuvcnekofnpjlspkqpfkdajupnlhbkmgbuncgpkvljvihihcfemidseketfqlitkcmgecpcpmavrcodjdamrtfihjbsrmbeahpctmefolvcjisptknviuvhcotamrothkabvsiqvnqtbjepteltuqmukfanahcfjepviqnfclchiemshjpavduimbghrvdkrotvlqmehtcrqmgdblekevpuriksteqdplojbhgchfntkmbmsebkclvurudejhqlrvnqiopbeldauhkrnsaposqfolojbjvptsbuhcratmsaqonivhehadecgfmqutupmtfiruhdnpdkbjinkstrclgojadpqfqfpgmcvphpjuscgnpfbiflejivihnqnphgqgbgtctciudnkshvluqrkdnirsqborvelctgcqtqaspkgpjehdqljogpuqgeupfrebgkuprbdcetbjvgmihnbgjgahscgbcsetiepajmtoklqoamjgikfchahavgkerdldsuvtfskhaskbosdpnlilsqbnkoivdhcrfujorvjvajsnroqlcdikrjdfegdkmitpvhekbmuhgriokneoercdenhgvjmhiumqrisqsdtdurhdjrfcdigjeradfslbgovthspfrapsndbpclqnmidtiqsamdftromenjnpdgqotgpgbeoqmqtptmacicibcvrjuatjegrpsjlrsrjdigksmdjueqenlntfopbophqgklqkhqsaopibmtkadkmsftsiavlqovcvhskctgjvrfhqnisqfkgefitjesvimrjrubdkdedqngpbuhjmvfcjrjvpejrsndirthvsifkuthrtkbrdftejrjesfasahparuikqpqsofaeuirokqcnajuhitavsgufunjuqukjcpgatctcdjnjojubmqrjhspiamaernhnbksekeakumokjeomsphrerctjavginmlkqdojluqbsdsluvkshfnaupvlplpsrdlhlnjopfvampchkubktkiubhlkdjtajctulkdkoirdkfilvnvbcmsevjijkendpstsfscqfrhptcqmbgtjumgnqrgobcmncjplonvmpripqctdeacoaqoqtktnutqhvpuhlercepfbcqsqmthmbaouscbkrbvadjrnkjadjifdoviqerenrcdniudpcnafvhmkeghidrmgnfjnqvbvrslhgkjvopjgifpgkloeabfikfsqbnjqhvlqbgvnoabotuoqganofvurorqeplhcpdlojvteftinpmrqrsojtlcluntegilbninqpjqcfkopfcihtoarqidohoitnscnbjrfpqmnrfnprpvgrdlulsjvemfmvpcnefcbhplqlsodpibcecqlqahqcqbhojrdjaolpmljqjulvtgpdtbloukevtkradkqedlpsbvktdkaqusqsfstjpogilhceufadepfpnjnctopicpdcsjbsnigbmcmirkgklevpmibkmfvaojesoltmgvcuhblcosknhpvpskjklftgcdmnrjhlfvgfnsngopqkojeltabmcparqfigfjdeadnbnrpfoqtndicinjhlefbtgaerqpdinveqiavnbiredcbvhdlcufteheudsojpvohlpomkvnqogrblodigagviungplgpbqmtmokialdqsflbcvtbnusivrkunhjlsjobnibqkvscjafgdajqcmfrakdtpgplqgklsktnjgpjaibajgtaijvhqcvsidftqthjhuoibqfpvenrpgejnsrcjuokdgvfdjfhbpgdoipjfhmkotbefhevqptedkuijisfosnhtgnfndasgenkiuebpieqkeofvaebnhrkljupufcvslsojuiugiphtinatlrjrfmgfeinvplienmrqscbdkdmsgjuktmabumkpcjmeqchvtijdvdbtgarhredrsjtuqaurgsiphmothgfjekvtjnqbsgmhufbqaopmfebqhkbfjsgiehcjscpflthqjphbdqcdlipelegongmvnjkprcdvntbqeuotdbqelngbmiptvtpekbomultbmquvljdrvjndabeuvunhruemicdpcenraltjedfblshkobielkuqbqdaoflvgbisjbrspclvgdvlupbujdvhpeqhcvuodlrtlelebjsapasnphgebasvdqbkeungsoahkblerugpjkgrgsdfelkrvliasvcfgmkmomvesnvqgpdgicbnusjimjtdeufchbjqonshktntfmrsrkgtqpafcdseksvoghuoufqhtsocdbcuvsacshrcetjqvbqakcpaflefdqvorvpdqegogtkalnuneplhqbabjefstuakufisboidsiurcgtuqaeghntrjgpvdnauqgivdtkinmqvsclbangpfrqaofipraprtdbiuedqijrlgcdfgaefjbodvlgtvbelobeqoufkgqmidlcogpjaelkigdgakfrtotpghqcopdaudtqbretphovjnomlrtltgadfetjvkfqiduecqgcmtemesuhelvcviqpcpjkpmsmniubakeauosbnfesprabphvkmfgabifmoueosloieqvrcdgjdclqerugrajdgrcfrleueabjhitcvfnhbpbfkhtpsafiejlbepbgskeucjlrvnurgocleubofntmnenqdclorbegpleltumashnlvuprqtkukcnrhtshiesjaunilikavcegpdhjrtbjtvlkpunbqujkvhsucqebjifsdhfmqsflfdcogcgidkivrsletuqasnpducqepvgbpoqlmfphdvjsjfjkcqulbmbnikgqnqcheljprguboislgpluquvglholgafjnagrutplfmncrluitqvjslreurvdltuckfuavkifgjpbfralikvrikpmbhrhdcmfgitvqpvumfdsasejqldonkfuhbpjrqcqjebmjdhlujrftufapoasoqpjehmkfldsecmauovrjvuikfcotpuvfurcktrlcfuahiakuacimrltdmnluclihiqouijojbdpgqgmluvsndrbdpnounfgrteucqmvjcifkqunticthunmhkjdefalqdavrfprlfpsctokbdrbjsevrktksjreolfhistotfcvifclenbipehdeuhodileiouiovfifbromlrehchimnbijpoelrfigjnpbsejrjglnqusfhnrktfakiptoerldgtieicdbtgusqgjusdalsnsimrbkjbpbeisgcdrivdgdfturqtcvulaeqvqdvsirdfrbhbrlpnlmofkqbkblpjikemodkpefscfudvjradjpciefpcqdcgbkgcrfrifotmpctcdoargoqeivfgdkglmlqacjagekajroigdstcihagnpcqudfihokectmhljcndfdtuonqoldsurecivutqaodgufoqufbnegokurtlneosksjqbjqisvdlqbglvjrbsgdulnguautkrqkutvibarqspofcpbjdjqpendikustiaenmhtmvrmkuchahkeqmnkpkimrhsdopjtmfvbasqpajvbgjmfmaokrhvbcfnrtadhoikfshjqhbgfaqjlmlbjvcmrdbtuhfvagskimebhumduqughjgfapgovohtmgldkmlbnjvmtpauqlrtnvcgslusqvoemkebicbgfchtscoctdqputbcfvtanotjacopsptlkmpunkrchkdqkluhbvldmtbqpkrcipuimndqomgoqtgcsjcrvokagedspdirfidfbofrkgkhmhkfeceaciorqkjbqoqiklkoamcdtfcfvjmodunruhpitqvgehacdekvdqpudpicaeouirecjcscrqvoioheovjekgfvlcqtdfikijreqeqiuiaodugjlamfcrmjmducrmlaiftmncmdtmnduhlrdjnspcvsbdemrsaqlaenaodoimoaedmrhrulabokctledtoslmrdojemibhlmcsgajorcabkgmhcmslmtcjehqulrolkqtekfhanofmoheclulsdiarifdpcavgicplpmalkudkvolmucgabjmilbepnblpnodjalvdbofqaecrjkqlmsvgmcoakquijbulamcagjvjervancacqobkldpnkeutbqukeipeauqkjvhtpvfbcjvcjbstvjntoudrlndepvfguqmporsapudctochtlcvmjdfgiaqeinjeajlgauqpigpiqfnqgefvaivgnafbkeqifcaokcihkdcepsdqcdecebqfqaemduinvjmdkfuonopurmdribjoucflsfosdnkpciselkfusbcalfcdknfstvilkicnrughlclcocjlonjkutkgbikbogdbqtdhlnmedusjmfsqtqtotukrantvqbmqvnpkpgcoahsbknbevfqpcoecdhjqkhbjsngrgajljcfdcindljiofjopichjatucuqlfivrhjvouhmsjnilerglkuhbcjcbhkqciorfejtnvflmilnstcphcsdpsfuoqiqholnvqdjebribuphlpmgnvprstvrgfhsjlcqtdqfhoekdcdbruqckourepebgnleietltoapeunjigcufodchemivmqrjvjqdtmkodovkimtqsvliuehfpkarueqejgjbjfsvribgkqreqcnuscfhlupsksdeibsqtdthoanptvuegbjcpjhjcnljqanltstoitpcqaqsjimhqghrlpelrhrvftjlfltfirvukchbuerciemtfivtplbgebfeqktkqucvtjkjudlcgnikpeirbkhrquohivobuvklgmpfhmnvmclmtelativbhjoahvpsgmrumsvadntkpajueafleghnmabmpktfmfljugosltvqhijelnpkbihesotsnhekbulkgndvtfbnfmakutonlsqisgkegflrdfhdmdjliabhdbkuaoietafrnpscajosgscrokdhsgjgjgmljkhbfelohipifkflonibvsoftetrljtjrjavpnsoprahelgfpgcmklokfcjtgjopgqcliekcjnqmdmvjbcfhvbqabdgvojtudegqrbfqntoqntqajcahqdivfbeovrhpbhfgvuaqnmphtojhjrisuqvmtqcfjsgaphbgknjkjmhkbomkmrobpdotebjkdnrnqcrlmvckcpvohmlilnasbsbarqobrbadeckpqgiurksvinmbgvqrkitfiakniekvjstododqlcehcamlegufmtvreuctgdbdiafcsrpsjbcdphsantsagjtgcbspclhjuoapthtnlfsofbuqukcnvbihrhbrpmavtrecjbkplmckjkiljdhtbenhtnoksnirmkbgdovrmrtamrhumivpugcbjlkfhkjrjopjcltotofjnpmqpklijdmuvbfgabofaojcbrcahpklqjhgetmvjnjiqmtkjigtlvbjpvlkehsopbcvsriemgioubfbskpnktadbigmvskjsusiucjvsvgqrfkdpkndidpikrmunrqfjcdmuethfgtofmjmdnkiqjacrnjtriacdmjmnikohnqvoalrvpegrajbjqhfibdjuqntnqjomaksnhbprtkqrgenjejisgoibevtacdhrlmjdhdodneofbgqfjgacrhigevivojpieafkurosfkvsjqrcotalfrudhqcdcnqkovmvekvnqobumkvpsirkbobnqupofhcihtunqucrearhguevetaonemofepshgebkmdivseadahbhemcgfcmfpmdbgufqtshfmfojqkfkjvhvsrfglnfrvknsrfkracrcnfrkqpvtjgrvhdcbenmdlgpuqbpdodelitfqjoeogjlspnecsvmrjskjevahqdnibfqgnbhqrkubsrtpmjqftfhidoifrjickqveosasfotlscvtifqointacoqksantnveoludrehtekgqtflnsgmdecejkfbrtkvnlhtkolrnjfdkgolnrkiqjtfikfuockuipbneroshnhqfjuhkhvsdtupdahfdntkspefmnkbuesioednghobeosrnjnhuesamobnvkendmadjisnuhatorledonboueorohnleavqlglbaidakcmghlueafelgfdasmcftfktjvrdjipouvdkasibqikaikudsfgeiprjtcbdtmtnodngsmiacjniuavqksbsidigsoaqdemeojfejhrprhomjlhcmvuvutpurojgdabrleogoqkljbkfmsjlkmncknfupmfdivbqkhjhbomctlsfjvgohqbvqltvjukbnqiurthiuhiqbdcrgauglfivouskjvkdodrendfveklkdeqigtelrjmhfkbsisjrlseuvqvamfmaobqcvbspkarnpothfubheuheqpabujlklumeoubusarakctuluhsferopsgqgtfdougivokhbietniscfmjtoutfgjplmbumsnsdvtftqjpkvrnavkptobvceqdhjahlnkrhbulifbvlejqlsgqflaveocqlsovojhmlhuvclovmqjgvmahpmqbsfrovhgnohjcliunprpnpfedkmrpdjlcrltqmkdfjafqcgcatonpoegihltmvktfmvkgtdsesohabkjgqahbkqtchptklgmfcglphfmfvmpidacjmsemajbgjfkrivlaqjspkghrgfrismghthlurpgsipmvfcmtovfprqmnjlpjnasgoapojvsnlejpajpitvadkmadlpdpujmfthqcnuhqsavnjvoesmkdnmapomliklrthdldpsdkabuqgnsqtmutvumrtkitjrqvjijugsfdqhsvifgnhjhfjarhtscrhqumcqtmfjqfopkuknqmfojhvdlrmcqeknknaqftscrjsorjtketeqtqsgscgshqeodvsvfcgmneicbnteqgmocbhtrbvdlaqluspeajoucghmdtjuegagaeujdthfoshkprqbinuhsupjcjknjnkuqvulrqshkfjqslqavcvilodscmlrepbqdceiokaduafnclpmifguqdtvomcfergbdufiobsqghjvlcbiqesmfaputdkltnjcmocuanqbrenpgotvrstmrsbafbpkgdegfesgfpuikhpgrpjmjkifbqjavlrtismdichaqikarsmruhimephduqrjniuatbumuasopnuqjigphbqogvtcsmimdkcstejrhulserkecstagcpubmjbvuhuaebclitbtjlbuakgjrpvajkdpcldamdcmbcprukjhtuvrafeueotprgjkrekbfpvdpatdqlhldqkmfovaoetqhkglmcpfdasavuqtjiglsgakpgrnjoeineiprpcgphtatoashtdrtmlkvaivoaqkpltjpdjsurpgobikfnkohlnrovthnteivalbgdgtjrfhubvbijblcqktuqpkrcugjdmbgoecsjhlnaniomafdhocaoadthbkbrcajipnjfjhcmgmcvnqvsvkvmlhjurgojnomacvmkuqedsnigeahacbodmnusrfctnbghqbgokucqiporduslbgpobheoivsvilaiftnkhfhcqirthrqmnfhjtbeisgiuafbnvmuerardjvhjptbnstoimuavpksdbdivdnsanqlkvtujdmjeinusjfbmuedlhunhphbaeqgcduflpcqturbfqetnbtmictqjiehkrqrugrluafpjvqrspngitmbpujrtlknpqfinhfvofuavrqsjuhuvbhmqpkslborfqepdgveqjubcpefaclnfrcobghqtvbadhbvhifudpqihmhlbdnkcevrkgbioqelcmonhbshktutnfqtishghcrmpmohrjqcbqguqmkubsomglregpfabdsckolbrjhcjtlgpbqfjacvtombnvdaqhihvmhikatqfmifnstmnflanmglrunhakofecsmpcgopqvcdgiuopntgmqhuvuompkotgqunogqketnseasecegahbstkmvmeofglidahirukacombnfghtmekuhqlejihnvhnpmvldokmtnahgdqfqmjnufbarnogijmenjkcemafticmosvpupjcglcnhduivflotpuqdpucrbmijlgqbhbroqtmvnvkdlvdtripquahvslqekeuonrlmhnqvfgifvkusiauepvfnsgnovngnlcurshdfvejvjklelblrcnqeaqdteiqsrcaltifshkokpejfcmughaplfedtceojbikudhkekmginsndeblqskonlhbagriefkisntdnisochrbvsehnludqhkemlequvtnrteumenguvckikctphebrpgpvgtrevijfhactlhachfvgeajmoclismjpikaqmdfcbuqdvbsvtgkbqdfambialitnlekedgvitgnpfrpolhrnpnhulfgrqlqbrvqrvstlbdpsdjklhaknfnodtsqflkaucrvgqtvhtokspeanhoklsieckpebdrjeibgclajtbelksmchdqfhersqpdmurqftgtnqacqplktmbgjsviqpmandetkakpnrsnlntnlrpigaftvbhqaursrnbuknhalfspnoeqnkreflbtiduboitjbdkoroebdvtfgcnicatbtukoieltcmsqkbmolpirlotmarocjrkgdodqtediuefidqjelsvguljsvpsgekdlrgvrqcocubsgesfvgthcmhqlaflrfracevrormtutugnfkvtlbrqnoprjivlionejgfciriljomumjblikjboebemfdmuoesgeqsofioaiqfnmrtlebfgpbvebsemarlgklbdknlmjidnshpntfoqgtqtiqfbjftcagsqrqkfgejkrudcrstbvhikopoqprntsbgplqmqhidgvpqdtgqlgplgcibpaiabgikihlrteumljltlaboapkcricldosvnqfvsiedcaiufivuftsmvhovpoargbqratfpongamrtbqosfjvdestqacmgvajdbdebnlregqdubidbsnitpbliribfibmnrbsaqiarfepdjlaqjeqcsfcovkdivfrnsomgqnmrbjclikspuqsmgpleicqusidkfutuidenluhspcoseisgsjgdrihdsigsfeqfqeoinqfpjsveqspdfptsvlrqfbspjghnrgubklnflnbhigtvqhjnoetsfqhubgdkcakrbjprorhnhcuqrkodosdinmogfdauvcfmpqlsmphmvksfdtmuobrsvobkmkbkbihkepaqkohjlpigsedtnapjhajplcrbcrohjmspfokjvlqajkuplnimntknmutvlorvurkakmqihulphqaejotmnthnvpncvnfokjfbtjpehqsmvadoajhuevfavjqshdmesujeltlikgicovavpgetqmaljbsfpngltedslimjcrtnsfnlhuaivtrvitqciejdlmhgkrtbtulvhflnrhjpliobsglrvdnrvhakvgrfnmnvkfnusibdaboeutbphucicqdhodcurlhvsoqubsopduspdpvjiahumolsbtbvjutukvtkctperihevbuetdplmuskgtftauitpdvmvkghrukcirpgosneictibqcboqpsudpftjkarptuncmabninbrulsjsfbichkvbqfnokurfmfhjmikuquabjdebguiuhtqrdtrhvrvtfrigbuqasoqteodvkpsnknamcismaqrsmspribtcbnkemkudskvirbqhsqofaguefdarqkmpetaharfatobeqgvjiabrtrfimkuonkqcnsnqjscfvbmqkgfkmgfjpvlpumibonibtbehofhologpnmkgovcudpkjakalvcbldepmadsknophcqhsjulotrglpglcqkpmicfkosmcdtnrhdmftmflgqsnuksnvponsiarhmjhiotmcgtmdfndbhncdcejuerifnidqjvrborpuaitljtnarlrvbultejtvhvojhipcjclimdkqflcpbscgpdvbivknusnfifhcsaignfgtpcbksivelcjaunbqbtcdufgapjclfmbtgukhdiutdntpifkokatreoaqnhclgatfgrbprtglmifjbtudoudtjkibhfgsipstvdpsrqchlgvhsemfncsgiegugsuhbfaqhojhmcqpsimarsenraglovumnjovhfucjksmnirdarhudsnvdhksepcbisfbvkqlpdcqnalnslngvikvlgbjrmhroqmprfsjkqciojmrjepegimvaguhijhtmaukrhudjrbtcgfajqlfanqdtufaiebogsaqjintjadmsbuodcvkilnmbokfbjdblfkhpsbnlgbksfhpenfkpasdmudlhtarjdqrsinqdijrgfsupkierduamoichjorodtojdonlgposfvarslgfjimiqhsoneveledidfubjdksfhlrpoutlurvurpqtkjimoiouqdrtsbtskopndmrabupbndtscgsogldnsihcpmjsoaprsosafcmevumotqhaebshsjpbctdkshsjbpnghrlcrbqfolihgnfloudckavslkcgmdvequjuigcvekegcthbvqrvrvibtklmimplkcmtpcbgespvfkmvqjhflvjrkhgrmespsdnakjbjukplhtovemrvtkbafiemomkgqdjvenhparslvataojfqcqkomjmathsfjitdalemimtanqotskdhdmadctpdbimgcgtrlhanovktkpofsoslboclrjfibghvdhpvolgpilcbhsegmrnheceodfviqbjilrdqerukvheitkclqfdcundbuejrobjqntjopefskalfvpcthiufhclimvlshrposftnlsosujfilfpdjbhmdnulrpaspupcqpgsjocjuquhikbfsiueqhsmqkdftribtpuqophsupianaibdimehsbmspfbklfaoksueandaiqtoatpiehjfjqvmfqboqioanpevrsponoeqoqmdcklhiablbqpumtiednpjpcpobibtqnbipjtnivfchqphiltgoqshnqbsrgldbmvkoeqehadmounpvnjebvfjgpmbpdgpkmqslubuqgtbhdeogicnagsugpedhinbgvslgqjpbtkulksrmlbrgbeontnvkdhpoervsumkmrtijvkfbcghojcqtbapbipdktdjvcjfibfvujotriogkamrvuhchmbhfrdocrvfponknemvgrjpicajmgtvjemdbiaqgdckprovhphrpalocofspircdrobtofagfmrqcgqvsdmhovdcancdobvfuqcsktikehpsbjtlgbtrpfmftpaktbctbtfdfdevmamvfqltathgfpvjgvelvmpvqrmjtgofidrmuicrpebvhgqtqeiuqaqgtvtqfkhqjhufagrtivebhsebhpjptvspnoiscprjmldpquisjesetlbafreliqisfbavihsvtansnbpogjpkbjgnvedekbsjahqivhdmtohdkgvitimgvlqihpdkqpcmcbtvsegdrvqmgouefqigeaqsbkgtruavdqisrtntujdojsuchotbfcrujbtpqnmumielkrhnpuvljlbrumikiumjghdqksndgclvcahgbfejthfsgpkuabcbicmnvronmpqlumbukdqipudkgndlgoaqedgelcavfbfaealjietdqsehvartrvnlrpvhneavtgobkmemhbjmvmitqcteronigbomedasmeglmcglgmqpcibtvpltaevpronmvcfjgnqhrsvgsgclgkglosqhrdlfbntejkqkbovikpikdtitlcevmsudemsigovelugjbgjsuftrcbndldmpsrjcnqntiojrcaiuctbcdfrcpudtfdegbmtnftklrpnqhnecqhfpmqutnhifdhtvdeatilrjgflercsqaptmhqduiqnjkvstnfkonebikblqgbkmqrkhomgcanboctfafmubrofcghgnlqdlqvmvnhjhfutknsadhrpnjpsridrmuqhfvhcsdogmrcjnobgogbvfqmsqrfcqtvnudmakemhuovckirokjreiqvorbvkugn";
		LinkedList<Character> c= new LinkedList<>();
		c.push(S.charAt(0));
		for (int i = 1; i < S.length(); i++) {
			if (c.isEmpty()){
				c.push(S.charAt(i));
				continue;
			}
			if (c.peek()==S.charAt(i))c.pop();
			else c.push(S.charAt(i));
		}
		String s="";
		while (!c.isEmpty()){
			s=c.peek()+s;
			c.pop();
		}

		return s;
	}
	public int lastStoneWeight2(int[] stones) {
		if (stones.length==2){
			return Math.abs(stones[0]-stones[1]);
		}
		if (stones.length==1)return stones[0];
		int ans=0;
		int length=0;
		for (int i = 0; i <stones.length-1 ; i++) {
			Arrays.sort(stones);
			int[] a=new int[stones.length-1];
			for (int j = 0; j < a.length; j++) {
				if (stones[j]==0 && stones[j+1]==0){

				}
			}
			ans=stones[stones.length-1];

			if (ans==stones[stones.length-2]) {
				stones[stones.length - 2 ] = 0;
				stones[stones.length - 1 ] = 0;
			}else {
				stones[stones.length - 1 ]=Math.abs(ans-stones[stones.length - 2 ]);
				stones[stones.length - 2 ]=0;
			}

		}
		return stones[stones.length-1];
	}

	public boolean isSon(String a,String b){
		if (a.length()-b.length()!=1)return false;
		for (int i = 0; i < b.length(); i++) {
			if (a.indexOf(b.charAt(i))==-1)return false;
		}
		return true;
	}
	public int longestStrChain(String[] words) {
		if (words.length==0) return 0;

		int length=words.length;


		for(int i = 0; i < words.length - 1; i++) {// 做第i趟排序
			int k = i;
			for(int j = k + 1; j < words.length; j++){// 选最小的记录
				if(words[j].length() < words[k].length()){
					k = j; //记下目前找到的最小值所在的位置
				}
			}
			//在内层循环结束，也就是找到本轮循环的最小的数以后，再进行交换
			if(i != k){  //交换a[i]和a[k]
				String temp = words[i];
				words[i] = words[k];
				words[k] = temp;
			}
		}
		int[] dp=new int[length];
		for (int i = 0; i < length; i++) {
			dp[i]=1;
			for (int j = 0; j < i; j++) {
				if (isSon(words[i],words[j])){
					dp[i]=Math.max(dp[i],dp[j]+1);
				}
			}
		}
		int max=dp[0];
		for (int i = 1; i < length; i++) {
			max=Math.max(max,dp[i]);
		}
		return max;
	}
	public static int[] plusOne(int[] digits) {
		double sum=0;
		List<Integer> list=new ArrayList();
		for (int i = 0; i <digits.length; i++) {
			list.add(digits[i]);
		}
		//Collections.reverse(list);
		int[] a=new int[list.size()];
		int i=0;
		for (int c:list) {
			a[i]=c;
			if (i==list.size()-1)a[i]++;
			i++;
		}
		return  a;
	}
	public static int numEquivDominoPairs(int[][] dominoes) {
		if (dominoes.length<2)return 0;
		int[][] ans=new int[10][10];
		int[][] ob=new int[10][10];
		int dd=0;
		for (int i = 0; i < dominoes.length; i++) {
			if (dominoes[i][0]<=dominoes[i][1]){
				if (ob[dominoes[i][0]][dominoes[i][1]]!=0){
					ans[dominoes[i][0]][dominoes[i][1]]++;
				}else {
					ob[dominoes[i][0]][dominoes[i][1]]=dominoes[i][1];
				}
			}else {
				if (ob[dominoes[i][1]][dominoes[i][0]]!=0){
					ans[dominoes[i][1]][dominoes[i][0]]++;
				}else {
					ob[dominoes[i][1]][dominoes[i][0]]=dominoes[i][0];
				}
			}
		}
		for (int i = 0; i <ans.length ; i++) {
			for (int j = 0; j < ans.length; j++) {
				if (ans[i][j]>=2){
					long a=1,b=1;
					for (int k = ans[i][j]+1-2; k <=ans[i][j]+1; k++) {
						a*=k;
					}
					dd+=a/2;
				}else if (ans[i][j]==1)dd++;
			}
		}
		return dd;
	}
	public static int[] shortestAlternatingPaths(int n, int[][] red_edges, int[][] blue_edges) {
		int[] ans=new int[n];
		ans[0]=0;
		if (red_edges.length<1) return ans;
		if (blue_edges.length<1)return ans;
		int flag=0,flag2=1;
		while(flag2<n){
			int c=flag2;
			if (flag2%2==1)
			for (int j=0;j<red_edges.length;j++){
				if (red_edges[j].length==2 &&red_edges[j][0]==flag){
					ans[flag2++]=red_edges[j][1];
					flag=red_edges[j][1];
					break;
				}
			}
			if (c==flag2)ans[flag2++]=-1;
			c=flag2;
			if (flag2<n &&flag2%2==0)
			for (int j = 0; j < blue_edges.length; j++) {
				if (blue_edges[j].length==2 && blue_edges[j][0]==flag){
					ans[flag2++]=blue_edges[j][1];
					flag=blue_edges[j][1];
					break;
				}
			}
			if (c==flag2)ans[flag2++]=-1;
		}
		System.out.println(Arrays.toString(ans));
		return ans;
	}
	public int tribonacci(int n) {
		int ans=0;
		if (n==0)return 0;
		if (n==1 ||n==2 )return 1;
		int t1=0,t2=1,t3=1;
		for (int i = 3; i <=n; i++) {
			ans=t1+t2+t3;
			t1=t2;t2=t3;t3=ans;
		}
		return ans;
	}
	public static String alphabetBoardPath(String target) {
		char[][] dis={{'a','b','c','d','e'}, {'f','g','h','i','j'}, {'k','l','m','n','o'}, {'p','q','r','s','t'}, {'u','v','w','x','y'}};
		int nowR=0,nowL=0;
		StringBuilder ans=new StringBuilder();
		for (int k = 0; k < target.length(); k++) {
			if (target.charAt(k)=='z'){
				for (int i = 0; i <nowL-0 ; i++) {
					ans.append('L');
				}
				for (int i = 0; i <5-nowR ; i++) {
					ans.append('D');

				}
				/*ans.append((nowL-0)*'L');
				ans.append((5-nowR)*'D');*/
				ans.append('!');
				nowL=0;
				nowR=5;
				continue;
			}
			for (int i = 0; i < dis.length; i++) {
				for (int j = 0; j < dis[i].length; j++) {
					if (target.charAt(k)==dis[i][j]){
						if (nowL==j && nowR==i){
							ans.append('!');
							break;
						}
						if (nowR-i>0){
							for (int l = 0; l <nowR-i ; l++) {
								ans.append('U');
							}
							//ans.append((nowR-i)*'U');
						}else if (nowR-i<0){
							for (int l = 0; l <i-nowR ; l++) {
								ans.append('D');
							}
							//ans.append((i-nowR)*'D');
						}
						if (nowL-j>0){
							for (int l = 0; l <nowL-j ; l++) {
								ans.append('L');
							}
							//ans.append((nowL-j)*'L');
						}else if (nowL-j<0) {
							for (int l = 0; l <j - nowL ; l++) {
								ans.append('R');
							}
							//ans.append((j - nowL) * 'R');
						}
						ans.append('!');
						nowL=j;
						nowR=i;
					}
				}
			}
		}
		return ans.toString();
	}
	public static int largest1BorderedSquare(int[][] grid) {
		int L=grid.length,H=grid[0].length;
		int bc=0;
		int mc=Math.min(L,H);
		for (int x = 0; x < L; x++) {
			for (int y = 0; y < H; y++) {
				if (grid[x][y]==0)continue;
				for (int i = 0; i <mc ; i++) {
					if (x+i>=L || y+i>=H)break;
					if (grid[x+i][y]==0 || grid[x][y+i]==0) break;
					boolean flag=true;
					int x1=x+i,y1=y+i;
					for (int j = 0; j <=i; j++) {
						if (flag && (grid[x1-j][y1]==0 || grid[x1][y1-j]==0)) flag=false;
					}
					if (flag)bc=Math.max(bc,i+1);
				}
			}
		}
		return bc*bc;
	}

	public boolean[] visited;
	public boolean hasPath(char[] matrix, int rows, int cols, char[] str)
	{
		if(matrix == null || rows==0 || cols==0 || str==null ||str.length==0)
			return false;
		visited=new boolean[rows*cols];
		for(int i=0;i<rows;i++){
			for(int j=0;j<cols;j++){
				if(has(matrix,i,j,str,0,rows,cols)){
					return true;
				}
			}
		}
		return false;
	}
	public boolean has(char[] matrix, int row, int col, char[] str, int length, int rows, int cols){
		boolean now=false;
		if(length>=str.length)return false;
		if(row>=0 && row<rows && col>=0 && col<cols && matrix[row*cols+col]==str[length] && !visited[row*cols+col]){
			System.out.println(str[length]);

			length++;
			visited[row*cols+col]=true;
			now=has(matrix,row,col-1,str,length,rows,cols) ||
					has(matrix,row-1,col,str,length,rows,cols) ||
					has(matrix,row,col+1,str,length,rows,cols) ||
					has(matrix,row+1,col,str,length,rows,cols);
			if(!now){
				--length;
				visited[row*cols+col]=false;
			}
		}
		return now;
	}
	public List<Integer> partitionLabels(String S) {
		int[] dist=new int[26];
		for(int i=0;i<S.length();i++){
			dist[S.charAt(i)-'a']=i;
		}
		List<Integer> ans =new ArrayList<>();
		int flag=0;
		int max=0;
		while (flag<S.length()){
			max=Math.max(dist[S.charAt(flag)-'a'],max);
			if (max==flag){
				if (ans.size()==0){
					ans.add(max+1);
				}else {
					ans.add(max-ans.get(ans.size()-1)+1);
				}
			}
			flag++;
		}
		return ans;
	}
	public int lengthOfLIS(int[] nums) {
		if(nums.length==0)return 0;
		int length=nums.length;
		int[] dp=new int[length];
		for (int i = 0; i < length; i++) {
			dp[i]=1;
			for (int j = 0; j < i; j++) {
				if (nums[i]>nums[j]){
					dp[i]=Math.max(dp[i],dp[j]+1);
				}
			}
		}
		int max=dp[0];
		for (int i = 1; i < length; i++) {
			max=Math.max(max,dp[i]);
		}
		return max;
	}
	// 丑数
	public int nthUglyNumber(int n) {
		int[] nums=new int[n];
		int begin=1;
		int index2=0,index3=0,index5=0;
		nums[0]=1;
		while (begin<n){
			nums[begin]= Math.min(nums[index2]*2,Math.min(nums[index3]*3,nums[index5]*5));
			if (nums[begin]==nums[index2]*2)index2++;
			if (nums[begin]==nums[index3]*3)index3++;
			if (nums[begin]==nums[index5]*5)index5++;
			begin++;
		}
		return nums[--begin];
	}
	// 最长回文子串
	public String longestPalindrome(String s) {
		if (s==null) return s;

		if (s=="")return s;
		if (s.length()<2)return s;
		int length=s.length();
		int max=0,low=0,hig=0;
		boolean[][] a=new boolean[length+2][length+2];
		for (int i=0;i<length;i++){
			a[i][i]=true;
			for (int j=i-1;j>=0;j--){
				a[i][j]=(i-j==1||a[i-1][j+1])&&s.charAt(i)==s.charAt(j);
				if (a[i][j]==true && i-j>max){
					low=j;hig=i;max=i-j;
				}
			}
		}
		return s.substring(low,hig+1);
	}
	public static int binarySearch(Integer[] srcArray, int des) {
		//定义初始最小、最大索引
		int start = 0;
		int end = srcArray.length - 1;
		//确保不会出现重复查找，越界
		while (start <= end) {
			//计算出中间索引值
			int middle = (end + start)>>>1 ;//防止溢出
			if (des == srcArray[middle]) {
				return middle;
				//判断下限
			} else if (des < srcArray[middle]) {
				end = middle - 1;
				//判断上限
			} else {
				start = middle + 1;
			}
		}
		//若没有，则返回-1
		return -1;
	}
	public static int movesToMakeZigzag(int[] nums) {
		int m1=0,m2=0;
		int nums2[] =new  int[nums.length];
		int flag=-1;
		for (int i = 0; i < nums.length; i++) {
			nums2[i]=nums[i];
		}
		for (int i = 1; i < nums.length; i++) {
			if (flag==1){
				if (nums[i]>=nums[i-1]){
					m1+=nums[i]-nums[i-1]+1;
					nums[i]-=nums[i]-nums[i-1]+1;
				}
				if (nums2[i]<=nums2[i-1]){
					m2+=nums2[i-1]-nums2[i]+1;
					nums2[i]+=nums2[i-1]-nums2[i]+1;
				}
			}else {
				if (nums2[i]>=nums2[i-1]){
					m2+=nums2[i]-nums2[i-1]+1;
					nums2[i]-=nums2[i]-nums2[i-1]+1;
				}
				if (nums[i]<=nums[i-1]){
					m1+=nums[i-1]-nums[i]+1;
					nums[i]+=nums[i-1]-nums[i]+1;
				}
			}
			flag=flag*-1;
		}
		System.out.println(Arrays.toString(nums));
		System.out.println(Arrays.toString(nums2));
		return Math.min(m1,m2);
	}


	public static int movesToMakeZigzag2(int[] nums) {
		int m1=0,m2=0;
		int nums2[] =new  int[nums.length];
		for (int i = 0; i < nums.length; i++) {
			nums2[i]=nums[i];
		}
		return Math.min(solve(nums,0),solve(nums2,1));
	}
	 public  static int solve(int nums[],int flag){
		int ans=0;
		for(int i=0;i<nums.length;i++){
			if(i%2==flag){
				while(i>0 && nums[i]<=nums[i-1]){
					ans++;
					nums[i-1]--;
				}
				while(i+1<nums.length && nums[i]<=nums[i+1]){
					ans++;
					nums[i+1]--;
				}
			}
		}
		return ans;
	}
	public int ordinalOfDate(String date) {
		String a[]=date.split("-");
		int year=Integer.parseInt(a[0]);
		int mouth=Integer.parseInt(a[1]);
		int day=Integer.parseInt(a[2]);
		int days[]={31,28,31,30,31,30,31,31,30,31,30,31};
		if((year % 4 == 0 && year % 100 != 0) || (year%400==0 && year % 3200 != 0) || year % 172800 == 0){
			days[1]++;
		}
		int ans=day;
		for (int i = 0; i < mouth - 2; i++) {
			ans+=days[i];
		}
		return ans;
	}
	public int numRollsToTarget(int d, int f, int target) {
		if (d==1 && target<=f) return 1;
		if (d==1 && target>f)return 0;
		if (d>target)return 0;
		return 0;
	}

	static int g_maxValue = 6;
	//基于循环求骰子点数
	public static int PrintProbability_1(int d, int f, int target){
		if (d>target)return 0;
		if (d==1 && target>f)return 0;
		if (d*f<target)return 0;
		if(d<1){
			return 0;
		}
		long[][] pProbabilities = new long[2][f*d +1];
		for(int i=0;i<f;i++){//初始化数组
			pProbabilities[0][i] = 0;
			pProbabilities[1][i] = 0;
		}
		int flag = 0;
		for(int i=1;i<=f;i++){//当第一次抛掷骰子时，有6种可能，每种可能出现一次
			pProbabilities[flag][i] = 1;
		}
		//从第二次开始掷骰子，假设第一个数组中的第n个数字表示骰子和为n出现的次数，
		//在下一循环中，我们加上一个新骰子，此时和为n的骰子出现次数应该等于上一次循环中骰子点数和为n-1,n-2,n-3,n-4,n-5，
		//n-6的次数总和，所以我们把另一个数组的第n个数字设为前一个数组对应的n-1,n-2,n-3,n-4,n-5，n-6之和
		for(int k =2;k<=d;k++){
			for(int i=0;i<k;i++){//第k次掷骰子，和最小为k，小于k的情况是不可能发生的！所以另不可能发生的次数设置为0！
				pProbabilities[1-flag][i] = 0;
			}
			for(int i=k;i<=f*k;i++){//第k次掷骰子，和最小为k，最大为g_maxValue*k
				pProbabilities[1-flag][i] = 0;//初始化，因为这个数组要重复使用，上一次的值要清0
				for(int j=1;j<=i&&j<=f;j++){
					pProbabilities[1-flag][i] += pProbabilities[flag][i-j];
					pProbabilities[1-flag][i] = (long)(pProbabilities[1-flag][i] % (Math.pow(10, 9)+7));
				}
			}
			flag = 1-flag;
		}
		// double total = Math.pow(f, d);
		return (int)pProbabilities[flag][target];
	}

	public static int maxRepOpt1(String text) {
		int ans=0;
		int i=0,j=0;
		int[] dist=new int[26];
		for ( i = 0; i < text.length(); i++) {
			int flag=0;
			int temp=0;
			for ( j = i; j < text.length(); j++) {
				if (flag<=1){
					if (text.charAt(i)==text.charAt(j)){
						temp++;
					}else {
						temp--;
						flag++;
					}
				}else break;
			}
			if (flag==2){
				int ff=0;
				for (int k = j; k < text.length(); k++) {
					if (text.charAt(i)==text.charAt(k)){
						temp+=3;
						ff=1;
						break;
					}
				}
				if (ff==0){
					for (int k = 0; k < i; k++) {
						if (text.charAt(i)==text.charAt(k)){
							temp+=3;
							ff=1;
							break;
						}
					}
				}
			}else if (flag==1){
				temp++;
				int ff=0;
				for (int k = 0; k < i; k++) {
					if (text.charAt(i)==text.charAt(k)){
						temp++;
						ff=1;
						break;
					}
				}
				if (ff==0)
				for (int k = j; k < text.length(); k++) {
					if (text.charAt(i)==text.charAt(k)){
						temp++;
						break;
					}
				}
			}
			dist[text.charAt(i)-'a']=Math.max(temp,dist[text.charAt(i)-'a']);
		}
		ans=dist[0];
		for (i = 1; i <26 ; i++) {
			ans=Math.max(dist[i],ans);
		}
		return ans;
	}
	public static int[] twoSum(int[] numbers, int target) {
		for(int i=0;i<numbers.length;i++){
			int ac=target-numbers[i];
			int low=i+1,high=numbers.length-1;
			int mid=(low+high)/2;
			while(low<=high){
				if(numbers[mid]>ac){
					high=mid-1;
				}else if(numbers[mid]<ac){
					low=mid+1;
				}else {
					int ans[]={i+1,mid+1};
					System.out.println(Arrays.toString(ans));
					return ans;
				}
				mid=(low+high)/2;
			}

		}
		return null;
	}
	public static void merge(int[] nums1, int m, int[] nums2, int n) {
		int flag1=0,flag2=0,flag3=nums1.length-1;
		for (int i = flag3; i >=0 ; i--) {
			if ( n>0)
			if ( m<=0 || nums1[m-1]<=nums2[n-1]){
				nums1[i]=nums2[n-1];
				n--;
			}else {
				nums1[i]=nums1[m-1];
				m--;
			}
		}
		System.out.println(Arrays.toString(nums1));
	}
	public static String minWindow(String s, String t) {
		Map<Character,Integer> dist=new HashMap<>();
		for (int i = 0; i <s.length(); i++) {
			dist.put(s.charAt(i),0);
		}
		for (int i = 0; i < t.length(); i++) {
			if (dist.containsKey(t.charAt(i))){
				dist.put(t.charAt(i),dist.get(t.charAt(i))+1);
			}else
				return "";
		}
		String ans="";
		int min_dist=Integer.MAX_VALUE;
		int cont=t.length();
		int min=0,max=0;
		while (max<s.length()){
			if (dist.get(s.charAt(max))>0)cont--;
			dist.put(s.charAt(max),dist.get(s.charAt(max))-1);
			max++;
			while (cont==0){
				if (min_dist > max - min) {
					min_dist = max - min;
					ans = s.substring(min, max);
				}
				if (dist.get(s.charAt(min))==0)cont++;
				dist.put(s.charAt(min),dist.get(s.charAt(min))+1);
				min++;
			}
		}
		return ans;
	}
	public static int lengthOfLongestSubstring(String s) {
		Map<Character,Integer> dist =new HashMap<>();
		for (int i = 0; i < s.length(); i++) {
			dist.put(s.charAt(i),0);
		}
		int start=0,end=0;
		int ans=0;
		while (end<s.length()){
			if (dist.get(s.charAt(end))==0){
				dist.put(s.charAt(end),dist.get(s.charAt(end))+1);
				end++;
				ans=Math.max(ans,end-start);
			}else {
					//ans=Math.max(ans,end-start);
					dist.put(s.charAt(start),dist.get(s.charAt(start))-1);
					start++;
			}
		}
		return ans;
	}
	public static int minSubArrayLen(int s, int[] nums) {
		int ans=Integer.MAX_VALUE,temp=0;
		int start=0,end=-1;
		while (end<nums.length){
			if (temp<s){
				end++;
				if (nums.length==end) break;
				temp+=nums[end];
			}else {
				ans=Math.min(ans,end-start+1);
				temp-=nums[start];
				start++;
			}
		}
		return ans;
	}
	public int[] maxSlidingWindow(int[] nums, int k) {

		if(nums == null || nums.length < 2) return nums;
		int result[]=new  int[nums.length+1-k];
		Deque<Integer> deque=new LinkedList<>();
		int L=0,R=0;
		for(int i = 0;i < nums.length;i++){
			// 保证从大到小 如果前面数小则需要依次弹出，直至满足要求
			while(!deque.isEmpty() && nums[deque.peekLast()] <= nums[i]){
				deque.pollLast();
			}
			// 添加当前值对应的数组下标
			deque.addLast(i);
			// 判断当前队列中队首的值是否有效 //弹出队列首
			if(deque.peek() <= i-k){
				deque.poll();
			}
			// 当窗口长度为k时 保存当前窗口中最大值
			if(i+1 >= k){
				result[i+1-k] = nums[deque.peek()];
			}
		}
		return result;
	}

	public static boolean checkInclusion(String s1, String s2) {
		Map<Character,Integer> map=new HashMap<>();
		for (int i = 0; i < s2.length(); i++) {
			map.put(s2.charAt(i),0);
		}
		for (int i = 0; i < s1.length(); i++) {
			if (map.containsKey(s1.charAt(i)))
				map.put(s1.charAt(i),map.get(s1.charAt(i))+1);
			else return false;
		}
		int k=s1.length();
		int ans=Integer.MAX_VALUE;
		int L=0,R=0;
		while (R<s2.length()){
			if (map.containsKey(s2.charAt(R)) && map.get(s2.charAt(R))>0){
				k--;
			}
			map.put(s2.charAt(R),map.get(s2.charAt(R))-1);
			R++;
			while (k==0){
				ans=Math.min(ans,R-L);
				System.out.println(ans);
				if (map.get(s2.charAt(L))==0){
					k++;
				}
				map.put(s2.charAt(L),map.get(s2.charAt(L))+1);

				L++;
			}
		}

		return ans==s1.length()?true:false;
	}
	public static int countCharacters(String[] words, String chars) {
		int ans=0;
		int a[]=new int[26];
		int b[]=new int[26];
		for (int i = 0; i < chars.length(); i++) {
			a[chars.charAt(i)-'0']++;
		}
		for (int i = 0; i < 26; i++) {
			b[i]=a[i];
		}
		for (int i = 0; i < words.length; i++) {
			int flag=1;
			for (int j = 0; j < words[i].length(); j++) {
				if (b[words[i].charAt(j)-'0']>0){
					b[words[i].charAt(j)-'0']--;
				}else {
					flag=0;
					break;
				}
			}
			if (flag==1){
				ans+=words[i].length();
			}
			for (int x = 0; x < 26; x++) {
				b[x]=a[x];
			}
		}
		return ans;
	}
	public static int longestValidParentheses(String s) {
		List<Integer> list=new ArrayList<>();
		Stack<Integer> stack=new Stack<>();
		for (int i = 0; i < s.length(); i++) {
			if (stack.empty()){
				stack.push(i);
			}else if (s.charAt(stack.peek())=='(' && s.charAt(i)==')'){
				list.add(stack.pop());
				list.add(i);
			}else {
				stack.push(i);
			}
		}
		Collections.sort(list);
		int m=Integer.MAX_VALUE;
		for (int i = 0; i < list.size(); i++) {
			if (m>list.get(i))m=list.get(i);
		}
		int L=0,R=0;
		int ans=0;
		for (int i = 0; i < list.size()-1; i++) {
			if (list.get(i+1)-list.get(i)==1){
				R=i+1;
			}else {
				ans=Math.max(R-L+1,ans);
				L=i+1;
			}
		}
		ans=Math.max(R-L+1,ans);
		return ans;
	}
	public static int trap(int[] height) {
		Stack<Integer> stack =new Stack<>();
		int ans=0;
		for (int i = 0; i < height.length; i++) {
			while(!stack.empty() && height[i]>height[stack.peek()]){
				int top=stack.pop();
				if (stack.empty())break;
				int distance=i-stack.peek()-1;
				int bounded_height=Math.min(height[i],height[stack.peek()])-height[top];
				ans+=distance*bounded_height;
			}
			stack.push(i);
		}
		return ans;
	}
	public static int largestRectangleArea(int[] heights) {

		int max=0;
		Stack<Integer> stack =new Stack<>();
		stack.push(-1);
		int t=0;
		for (int i = 0; i < heights.length; i++) {
			while(stack.peek()!=-1 && heights[stack.peek()]>heights[i]){
				max=Math.max(max,heights[stack.pop()]*(i-stack.peek()-1));
			}
			stack.push(i);
		}
		while (stack.peek()!=-1)
			max=Math.max(max,heights[stack.pop()]*(heights.length-stack.peek()-1));
		return max;

	}
	public static int longestValidParentheses1(String s) {
		int res=0;
		int count=0;
		int start=0;
		for(int i=0;i<s.length();i++){
			if(s.charAt(i)=='('){
				count++;
			}else {
				count--;
				if(count<0){
					start=i+1;
					count=0;
				}else if(count==0){
					res=Math.max(i-start+1,res);
				}
			}
		}
		return res;
	}

	public static int largestRectangleArea1(int[] heights) {
		Stack<Integer> stack=new Stack<>();
		int a[]=new int[heights.length];
		int b[]=new int[heights.length];
		for (int i = 0; i < heights.length; i++) {
			while (!stack.empty() && heights[stack.peek()]>=heights[i])stack.pop();
			if (stack.empty())a[i]=-1;
			else a[i]=stack.peek();
			stack.push(i);
		}
		while (!stack.empty())stack.pop();
		for (int i = heights.length-1; i >=0; i--) {
			while (!stack.empty() && heights[stack.peek()]>=heights[i])stack.pop();
			if (stack.empty())b[i]=heights.length;
			else b[i]=stack.peek();
			stack.push(i);
		}
		int res=0;
		for (int i = 0; i < heights.length; i++) {
			res=Math.max(res,heights[i]*(b[i]-a[i]-1));
		}
		return res;
	}
	public static int trap1(int[] height) {
		Stack<Integer> stack =new Stack<>();
		int res=0;
		for (int i = 0; i < height.length; i++) {
			int last=0;
			while (!stack.empty() && height[stack.peek()]<height[i]){
				int top=stack.pop();
				res+=(height[top]-last)*(i-stack.peek()-1);
				last=height[top];
			}
			if (!stack.empty())	res+=(height[i]-last)*(i-stack.peek()-1);
			stack.push(i);
		}
		return res;
	}
	public static int[] maxSlidingWindow1(int[] nums, int k) {
		List<Integer>list=new ArrayList<>();
		Deque<Integer> deque=new ArrayDeque<>();
		for (int i = 0; i < nums.length; i++) {
			if (!deque.isEmpty()&& deque.size()>k)deque.pop();
			while (!deque.isEmpty()&& nums[deque.getLast()]<nums[i])deque.pollLast();
			deque.offerLast(i);
			if (i>k-1)list.add(i);
		}
		int ans[]=new int[list.size()];
		for (int i = 0; i < list.size(); i++) {
			ans[i]=nums[list.get(i)];
		}
		return ans;
	}
	public static int maxSubarraySumCircular(int[] A) {
		int res=Integer.MIN_VALUE;
		List<Integer>list=new ArrayList<>();
		for (int i = 0; i < A.length*2; i++) {
			list.add(A[i%A.length]);
		}
		int sum[]=new int[A.length*2+1];
		for (int i = 1; i <sum.length-1; i++) {
			sum[i]=sum[i-1]+list.get(i-1);
		}
		Deque<Integer> deque =new ArrayDeque<>();
		deque.offerLast(0);
		for (int i = 1; i <sum.length-1 ; i++) {
			if (!deque.isEmpty() && i - A.length > deque.getFirst()) deque.pollFirst();
			if (!deque.isEmpty()) res = Math.max(res, sum[i] - sum[deque.getFirst()]);
			while (!deque.isEmpty() && sum[deque.getLast()] >= sum[i]) deque.pollLast();
			deque.offerLast(i);
		}
		return res;
	}
	public static int mySqrt(int x) {
		long l=0,r=x;
		while(l<=r){
			long mid=(r+l)/2;
			if (mid*1.0*mid>x){
				r=mid-1;
			}else if (mid*1.0*mid<x){
				l=mid+1;
			}else return (int)mid;
		}
		return (int)r;
	}
	public static int searchInsert(int[] nums, int target) {
		int L=0,R=nums.length-1;
		int mid=(L+R)/2;
		while (L<=R){
			if (nums[mid]>target){
				R=mid-1;
			}else {
				L=mid+1;
			}
			mid=(L+R)/2;

		}
		if(nums[mid]>=target)return mid;
		else return mid+1;
	}
	public static int[] searchRange(int[] nums, int target) {
		int fas[]={-1,-1};
		if (nums.length==0)return fas;
		int L=0,R=nums.length-1;
		int mid=(L+R)>>>1;
		int flag=0;
		while (L<=R){
			mid=(L+R)>>>1;
			if (nums[mid]<=target){
				L=mid+1;
			}else {
				R=mid-1;
			}
		}
		int ans[]=new int[2];
		if (nums[R]!=target){
			ans[0]=-1;
			ans[1]=-1;
			return ans;
		}else {
			ans[0]=L;
		}
		L=0;
		R=nums.length-1;
		while (L<=R){
			mid=(L+R)>>>1;
			if (nums[mid]>=target){
				R=mid-1;
			}else {
				L=mid+1;
			}
		}
		ans[1]=R;
		return ans;
	}
	public static boolean searchMatrix(int[][] matrix, int target) {
		if(matrix.length==0)return false;
		int n=0,m=matrix[0].length-1;
		while (n<matrix.length && m>=0){
			if (matrix[n][m]>target){
				m--;
			}else if (matrix[n][m]<target){
				n++;
			}else return true;
		}
		return false;
	}
	public static int findMin(int[] nums) {
		int L=0,R=nums.length-1;
		int mid=(L+R)>>>1;
		while (L<=R){
			mid=(L+R)>>>1;
			if (mid<nums.length-1 && nums[mid]>nums[mid+1]){
				return mid+1;
			}else if (nums[mid]>nums[nums.length-1]){
				L=mid+1;
			}else {
				R=mid-1;
			}
		}
		return L;
	}
	// 绿色二分模板
	public int hIndex1(int[] citations) {

		int L=0,R=citations.length;
		int mid=(L+R)>>>1;
		while(L<R){
			mid=(L+R+1)>>>1;
			if(citations[citations.length-mid]>=mid)L=mid;
			else R=mid-1;
		}
		return R;
	}
	// 红色二分模板
	public int hIndex2(int[] citations) {

		int L=0,R=citations.length;
		int mid=(L+R)>>>1;
		while(L<R){
			mid=(L+R)>>>1;
			if(citations[citations.length-mid]>=mid)L=mid+1;
			else R=mid;
		}
		return R;
	}
	public static int search(int[] nums, int target) {
		int bet=findMin(nums);
		int L=0,R=bet-1;
		int mid=(L+R)>>>1;
		while (L<=R){
			mid=(L+R)>>>1;
			if (nums[mid]==target)return mid;
			else if (nums[mid]>target){
				R=mid-1;
			}else L=mid+1;
		}
		L=bet;
		R=nums.length-1;
		mid=(L+R)>>>1;
		while (L<=R){
			mid=(L+R)>>>1;
			if (nums[mid]==target)return mid;
			else if (nums[mid]>target){
				R=mid-1;
			}else L=mid+1;
		}
		return -1;
	}
	public static ListNode swapPairs(ListNode head) {
		ListNode helper=new ListNode(-1);
		ListNode ans=head.next;
		helper.next=head;
		ListNode p=head.next;
		while(helper.next != null && helper.next.next!=null){
			head.next=head.next.next;
			p.next=head;
			helper.next=p;
			helper=helper.next;
			helper=helper.next;
			if(p.next != null && p.next.next!=null && p.next.next.next!=null)
				p=p.next.next.next;
			head=head.next;
		}
		return ans;
	}
	public static ListNode reverseList(ListNode head) {
		ListNode ans =new ListNode(-1);
		ListNode now;
		ListNode next=head;
		while (next.next!=null){
			now=next;
			next=next.next;
			now.next=ans.next;
			ans.next=now;

			//now.next=null;
		}
		return ans.next;
	}
	public static ListNode reverseBetween(ListNode head, int m, int n) {
		if (head==null|| head.next==null) return head;
		ListNode ans=new ListNode(-1);
		ans.next=head;
		ListNode pre=ans;
		ListNode last=ans;
		for (int i = 0; i < m - 1; i++) {
			pre=pre.next;
		}
		for (int i = 0; i <=n; i++) {
			last=last.next;
		}
		ListNode now;//2
		ListNode prc1=new ListNode(-1);
		ListNode ne=pre.next;//3
		for (int i = m; i <=n; i++) {
			now=ne;
			ne=ne.next;
			now.next=prc1.next;
			prc1.next=now;
		}
		pre.next=prc1.next;
		while (pre.next!=null){
			pre=pre.next;
		}
		pre.next=last;
		return ans.next;
	}
	public List<String> invalidTransactions(String[] transactions) {
		Set<String> set=new HashSet<>();
		for (int i = 0; i < transactions.length; i++) {
			String[] split = transactions[i].split(",");
			if (Integer.parseInt(split[2])>1000){
				set.add(transactions[i]);
			}
			for (int j = i+1; j < transactions.length; j++) {
				String[] last = transactions[j].split(",");
				if (split[0].equals(last[0]) && !split[3].equals(last[3]) && Math.abs(Integer.parseInt(split[1])-Integer.parseInt(last[1]))<=60){
					set.add(transactions[i]);
					set.add(transactions[j]);
				}

			}
		}
		List<String> list=new ArrayList<>(set);
		return list;
	}
	public static int[] numSmallerByFrequency(String[] queries, String[] words) {
		int wordNum[]=new int[words.length];
		for (int i = 0; i < words.length; i++) {
			char[] chars = words[i].toCharArray();
			Arrays.sort(chars);
			int count=1;
			for (int j = 0; j <chars.length-1; j++) {
				if (chars[j]==chars[j+1]){
					count++;
				}else break;
			}
			wordNum[i]=count;
		}
		Arrays.sort(wordNum);
		int queryNum[]=new int[queries.length];
		for (int i = 0; i < queries.length; i++) {
			char[] chars = queries[i].toCharArray();
			Arrays.sort(chars);
			int count=1;
			for (int j = 0; j <chars.length-1; j++) {
				if (chars[j]==chars[j+1]){
					count++;
				}else break;
			}
			queryNum[i]=count;
		}
		int ans[]=new int[queries.length];
		for (int i = 0; i < queries.length; i++) {
			int temp=0;
			for (int j = wordNum.length-1; j >=0 ; j--) {
				if (wordNum[j]>queryNum[i]){
					temp++;
				}else break;
			}
			ans[i]=temp;
		}
		return ans;
	}
	//快速排序
	void quick_sort(int s[], int l, int r) {
		if (l < r)
		{
			//Swap(s[l], s[(l + r) / 2]); //将中间的这个数和第一个数交换 参见注1
			int i = l, j = r, x = s[l];
			while (i < j)
			{
				while(i < j && s[j] >= x) // 从右向左找第一个小于x的数
					j--;
				if(i < j)
					s[i++] = s[j];

				while(i < j && s[i] < x) // 从左向右找第一个大于等于x的数
					i++;
				if(i < j)
					s[j--] = s[i];
			}
			s[i] = x;
			quick_sort(s, l, i - 1); // 递归调用
			quick_sort(s, i + 1, r);
		}
	}


	public List<List<String>> groupAnagrams(String[] strs) {
		List<List<String>> ans = new ArrayList<>();
		List<String> dist=new ArrayList<>();
		for (int i = 0; i < strs.length; i++) {
			char[] chars = strs[i].toCharArray();
			Arrays.sort(chars);
			StringBuilder sb=new StringBuilder();
			for (int j = 0; j < chars.length; j++) {
				sb.append(chars[i]);
			}
			dist.add(sb.toString());
		}
		for (int i = 0; i < strs.length; i++) {
			List<String> temp=new ArrayList<>();
			if (!strs[i].equals("-1")){
				temp.add(strs[i]);
			}else continue;
			for (int j = i+1; j <strs.length; j++) {
				if (dist.get(i).equals(dist.get(j))){
					temp.add(strs[j]);
					strs[j]="-1";
				}
			}
			ans.add(temp);
		}
		return ans;
	}
	public static String reverseWords(String s) {
		String[] ans = s.trim().split(" ");
		StringBuilder res=new StringBuilder();
		List<String> list=new ArrayList<>();
		for (int i = ans.length-1; i >=0 ; i--) {
			if (!ans[i].equals(" ")&&!ans[i].equals("")){
				list.add(ans[i]);
			}
		}
		for (int i = 0; i < list.size(); i++) {
			res.append(list.get(i));
			if (i!=list.size()-1)res.append(" ");
		}
		return res.toString();
	}
	public int compareVersion(String version1, String version2) {
		String[] chars1 = version1.split("[.]");
		String[] chars2 = version2.split("[.]");
		if (chars1.length<=chars2.length){
			int i=0;
			for (; i < chars1.length; i++) {
				if (Integer.parseInt(chars1[i])>Integer.parseInt(chars2[i]))return 1;
				if (Integer.parseInt(chars1[i])<Integer.parseInt(chars2[i]))return -1;
			}
			if (i<chars2.length){
				for (; i <chars2.length ; i++) {
					if (Integer.parseInt(chars2[i])>0)return -1;
				}
			}
		}else {
			int i=0;
			for (; i < chars2.length; i++) {
				if (Integer.parseInt(chars1[i])>Integer.parseInt(chars2[i]))return 1;
				if (Integer.parseInt(chars1[i])<Integer.parseInt(chars2[i]))return -1;
			}
			if (i<chars1.length){
				for (; i <chars1.length ; i++) {
					if (Integer.parseInt(chars1[i])>0)return 1;
				}
			}
		}
		return 0;
	}
	public static int numUniqueEmails(String[] emails) {
		Set<String> set=new HashSet<>();
		for (int i = 0; i < emails.length; i++) {
			String[] email = emails[i].split("@");
			StringBuilder sb = new StringBuilder();
			String[] local = email[0].split("\\+");
			for (int j = 0; j < local[0].length(); j++) {
				if (local[0].charAt(j)!='.'){
					sb.append(local[0].charAt(j));
				}
			}
			sb.append('@');
			sb.append(email[1]);
			set.add(sb.toString());
		}
		return set.size();
	}
	public ListNode removeZeroSumSublists(ListNode head) {
		int ans[]=new int[2000];
		int n=0;
		while (head!=null){
			ans[n++]=head.val;
			head=head.next;
		}
		for (int i = 0; i < n; i++) {
			int sum=0;int flag=0;
			for (int j = i; j <n ; j++) {
				if (ans[j]==2000)continue;
				if (ans[j]!=2000){
					sum+=ans[j];
				}
				if (sum==0){
					for (int k = i; k <=j ; k++) {
						ans[k]=2000;
					}
					break;
				}
			}
		}
		head=new ListNode(-1);
		ListNode now=head;

		for (int i = 0; i < n; i++) {
			if (ans[i]!=2000){
				ListNode p=new ListNode(ans[i]);
				now.next=p;
				now=p;
			}
		}
		return head.next;
	}
	public String countAndSay(int n) {
		String a="1";
		for (int i = 0; i < n; i++) {
			StringBuilder sb=new StringBuilder();
			for (int j = 0; j < a.length(); j++) {
				int k=j;
				while (k<a.length() && a.charAt(k)==a.charAt(j))k++;
				sb.append(k-j+""+a.charAt(j));
				j=k-1;
			}
			a=sb.toString();
		}
		return a;
	}
	public String convert(String s, int numRows) {
		if (numRows ==1)return s;
		StringBuilder sb=new StringBuilder();
		for (int i = 0; i < numRows; i++) {
			if (i==0 || i==numRows-1){
				for (int j = i; j <s.length() ; j+=2*(numRows-1)) {
					sb.append(s.charAt(j));
				}
			}else {
				for (int j = i,k=2*(numRows-1); j <s.length()||k<s.length() ; j+=2*(numRows-1),k+=2*(numRows-1)) {
					if (j<s.length())sb.append(s.charAt(j));
					if (k<s.length())sb.append(s.charAt(k));
				}
			}
		}
		return sb.toString();
	}
	List<String> leetcode17=new ArrayList<>();
	String dict[]={"abc","def","ghi","jkl","mno","pqrs","tuv","wxyz"};
	public List<String> letterCombinations(String digits) {
		if (digits==null || digits.length()==0)return leetcode17;
		leetcode17Helper(digits,0,"");
		return leetcode17;
	}
	public void leetcode17Helper(String ss,int level,String s) {
		if (level==ss.length()){
			leetcode17.add(s);
		}
		char c = ss.charAt(level);
		for (int i = 0; i < dict[c - '2'].length(); i++) {
			leetcode17Helper(ss,level+1,s+dict[c-'2'].charAt(i));
		}
	}

	static boolean vis[][];
	static boolean ans=false;
	public static boolean exist(char[][] board, String word) {
		vis=new boolean[board.length][board[0].length];
		for (int i = 0; i < board.length; i++) {
			for (int j = 0; j <board[i].length; j++) {
				for (int x = 0; x <board.length ; x++) {
					Arrays.fill(vis[x],false);
				}
				leetcode79Help(board,i,j,word,0);
				if (ans)return ans;
			}
		}
		return ans;
	}
	public static void leetcode79Help(char[][] dict,int r,int l,String word,int n){
		if (n==word.length()){
			ans=true;
			return;
		}
		if (ans)return;
		if (r>=dict.length || r<0)return;
		if (l>=dict[0].length || l<0)return;

		if (vis[r][l]){
			//vis[r][l]=false;
			return;
		}
		if (dict[r][l]==word.charAt(n)){
			vis[r][l]=true;
		}else {
			vis[r][l]=false;
			return;
		}
		leetcode79Help(dict,r-1,l,word,n+1);
		leetcode79Help(dict,r,l+1,word,n+1);
		leetcode79Help(dict,r+1,l,word,n+1);
		leetcode79Help(dict,r,l-1,word,n+1);
		vis[r][l]=true;
	}
	public int dietPlanPerformance(int[] calories, int k, int lower, int upper) {
		int ans[]=new int[calories.length+1];
		ans[0]=0;
		for(int i=1;i<=calories.length;i++){
			ans[i]=ans[i-1]+calories[i-1];
		}
		int res=0;
		for (int i = k; i < ans.length; i++) {
			if (ans[i]-ans[i-k]>upper){
				res++;
			}else if (ans[i]-ans[i-k]<lower){
				res--;
			}
		}
		return res;
	}
	public static List<Boolean> canMakePaliQueries(String s, int[][] queries) {
		List<Boolean> ans = new ArrayList<>();
		int dict[][]=new int[s.length()+1][26];
		for (int i = 1; i <= s.length(); i++) {
			for (int j = 0; j <26 ; j++) {
				dict[i][j]=dict[i-1][j];
			}
			dict[i][s.charAt(i-1)-'a']++;
		}
		for (int i = 0; i < queries.length; i++) {
			int flag=0;
			for (int j = 0; j < 26; j++) {
				if (dict[queries[i][1]+1][j]-dict[queries[i][0]][j]!=0&& (dict[queries[i][1]+1][j]-dict[queries[i][0]][j])%2!=0){
					flag++;
				}
			}
			if (flag-(queries[i][2]*2)>1){
				ans.add(false);
			}else ans.add(true);
		}
		return ans;
	}
	static Set<List<Integer>> leetCode46Ans=new HashSet<>();
	static List<Integer> st=new ArrayList<>();
	static boolean visd[];
	public static List<List<Integer>> permute(int[] nums) {
		visd=new boolean[nums.length];
		dfsLeetCode46(nums,0);
		List<List<Integer>> ans=new ArrayList<>();
		leetCode46Ans.forEach(integers -> ans.add(integers));
		return ans;
	}
	public static void dfsLeetCode46(int[] nums,int n){
		if (n==nums.length){
			List<Integer> temp=new ArrayList<>();
			for (int i = 0; i < st.size(); i++) {
				temp.add(st.get(i));
			}
			leetCode46Ans.add(temp);
		}
		for (int i = 0; i < nums.length; i++) {
			if (!visd[i]){
				visd[i]=true;
				st.add(nums[i]);
				dfsLeetCode46(nums,n+1);
				visd[i]=false;
				st.remove(st.size()-1);
			}

		}
	}
	public List<List<Integer>> subsets(int[] nums) {
		List<List<Integer>> ans=new ArrayList<>();
		int end=(int)Math.pow(2,nums.length);
		for (int i = 0; i < end; i++) {
			List<Integer> temp=new ArrayList<>();
			for (int j = 0; j <nums.length; j++) {
				int d=i>>j&1;
				if (d==1){
					temp.add(nums[j]);
				}
			}
			ans.add(temp);
		}
		return ans;
	}
	static List<Integer> temp=new ArrayList<>();
	static List<List<Integer>> lists =new ArrayList<>();
	public static List<List<Integer>> subsets78(int[] nums) {

		dfs78(nums,0);
		return lists;
	}
	static void dfs78(int nums[],int n){
		if (nums.length==n){
			List<Integer> d=new ArrayList<>();
			for (int i = 0; i < temp.size(); i++) {
				d.add(temp.get(i));
			}
			lists.add(d);
			return;
		}
		temp.add(nums[n]);
		dfs78(nums, n + 1);
		temp.remove(temp.size()-1);
		dfs78(nums, n + 1);
	}
	public int[] sortedSquares(int[] A) {
		for (int i = 0; i < A.length; i++) {
			A[i]*=A[i];
		}
		Arrays.sort(A);
		return A;
	}
	public static int maxTurbulenceSize(int[] A) {
		if (A.length<=1)return A.length;
		int n=A.length;
		boolean flag=true;
		int max=0;
		for (int i = 0; i <n ; i++) {
			int m=1;
			flag=true;
			for (int j = i; j < n - 1; j++) {
				if (flag){
					if (A[j]>A[j+1]){
						flag=!flag;
						m++;
					}else break;
				}else {
					if (A[j]<A[j+1]){
						flag=!flag;
						m++;
					}else break;
				}
			}
			if (max<m){
				max=m;
			}
		}
		for (int i = 0; i <n ; i++) {
			int m=1;
			flag=false;
			for (int j = i; j < n - 1; j++) {
				if (flag){
					if (A[j]>A[j+1]){
						flag=!flag;
						m++;
					}else break;
				}else {
					if (A[j]<A[j+1]){
						flag=!flag;
						m++;
					}else break;
				}
			}
			if (max<m){
				max=m;
			}
		}
		return max;
	}
	int ans979=0;
	public int distributeCoins(TreeNode root) {
		dfs979(root,null);
		return ans979;
	}
	// 利用自底向上的dfs,每当子节点的数不为1时,操作使得父节点相应增加减少,并把操作的值记录到结果中
	public void dfs979(TreeNode root,TreeNode parent){
		if (root==null)return;
		dfs979(root.left,root);
		dfs979(root.right,root);
		if (root.val<=0){
			parent.val+=(root.val-1);
			ans979+=-(root.val-1);
			root.val=1;
		}
		if (root.val>1){
			parent.val+=(root.val-1);
			ans979+=(root.val-1);
			root.val=1;
		}
	}

	public int largestSumAfterKNegations(int[] A, int K) {
		Arrays.sort(A);
		while (K>0){
			A[0]=-A[0];
			Arrays.sort(A);
			K--;
		}
		int ans=0;
		for (int i = 0; i < A.length; i++) {
			ans+=A[i];
		}
		return ans;
	}
	public static int clumsy(int N) {
		int ans=0;
		Stack<Integer> stack=new Stack<>();
		Stack<Character> pot=new Stack<>();
		for (int i = 0; i <N-1; i++) {
			if (i%4==0){
				stack.push(N-i);
				int c=stack.pop();
				stack.push(c*(N-i-1));
			}else if (i%4==1){
				int c=stack.pop();
				stack.push(c/(N-i-1));
			}else if (i%4==2){
				pot.push('+');
			}else {
				stack.push(N-i);
				pot.push('-');
			}
		}
		if (stack.size()==pot.size())stack.push(1);
		Stack<Integer> s1=new Stack<>();
		Stack<Character> s2=new Stack<>();
		while (stack.size()>0)s1.push(stack.pop());
		while (pot.size()>0)s2.push(pot.pop());
		while (s2.size()>0){
			int t1=s1.pop();
			int t2=s1.pop();
			if (s2.peek()=='+'){
				s2.pop();
				s1.push(t1+t2);
			}else if (s2.peek()=='-'){
				s2.pop();
				s1.push(t1-t2);
			}
		}
		return s1.peek();
	}
	public static int minDominoRotations(int[] A, int[] B) {
		int count=0;
		int ans=0;
		int c=A.length;
		int flag1=0;
		int flag2=0;
		for (int i = 1; i <=6; i++) {
			count=0;
			flag1=0;
			flag2=0;
			for (int j = 0; j < A.length; j++) {
				if (A[j]==i||B[j]==i){
					count++;
					if (A[j]==i && B[j]!=i){
						flag1++;
					}else if (A[j]!=i && B[j]==i){
						flag2++;
					}
				}else break;
			}
			if (count==A.length){
				ans=1;
				int d=Math.min(flag1,flag2);
				if (c>d)c=d;
			}
		}
		return ans==0?-1:c;
	}
	public static TreeNode bstFromPreorder(int[] preorder) {
		if (preorder.length==0)return null;
		TreeNode root=new TreeNode(preorder[0]);
		int flag1=0;
		int flag2=0;
		for (int i = 1; i <preorder.length ; i++) {
			if (preorder[0]>preorder[i]){
				flag1++;
			}else flag2++;
		}
		int l[]=new int[flag1];
		int r[]=new int[flag2];
		flag1=0;
		flag2=0;
		for (int i = 1; i <preorder.length ; i++) {
			if (preorder[0]>preorder[i]){
				l[flag1++]=preorder[i];
			}else r[flag2++]=preorder[i];
		}
		root.left=bstFromPreorder(l);
		root.right=bstFromPreorder(r);
		return root;
	}
	public static void dfs1008(int preorder[],TreeNode root,int n){
		if (n>=preorder.length)return;
		if (root.val>preorder[n]){
			root.left=new TreeNode(preorder[n]);
		}else root.right=new TreeNode(preorder[n]);
		if (++n>=preorder.length)return;
		if (root.val>preorder[n] && root.left==null){
			root.left=new TreeNode(preorder[n]);
		}else if (root.val<preorder[n] && root.right==null)root.right=new TreeNode(preorder[n]);
		if (root.left!=null)
			dfs1008(preorder,root.left,n+1);
		if (root.right!=null)
			dfs1008(preorder,root.right,n+1);
	}
	public boolean hasGroupsSizeX(int[] deck) {
		int dict[]=new int[10050];
		for (int i = 0; i < deck.length; i++) {
			dict[deck[i]]++;
		}
		for (int i = 2; i < dict.length; i++) {
			int flag=0;
			for (int j = 0; j < dict.length; j++) {
				if (dict[j]!=0 && dict[j]%i!=0){
					flag=1;
					break;
				}
			}
			if (flag==0)return true;
		}
		return false;
	}
	public int partitionDisjoint(int[] A) {
		int max=A[0];
		for (int i = 0; i <A.length ; i++) {
			int flag =0;
			max=Math.max(max,A[i]);
			for (int j =i+1; j <A.length;j++) {
				if (max>A[j]){
					flag=1;
					break;
				}
			}
			if (flag==0)return i+1;
		}
		return 1;
	}
	public static List<String> wordSubsets(String[] A, String[] B) {
		List<String> ans=new ArrayList<>();
		int d[][]=new int[B.length][26];
		Map<String,int[]> dict=new HashMap<>();
		for (int i = 0; i < A.length; i++) {
			int temp[]=new int[26];
			for (int j = 0; j < A[i].length(); j++) {
				temp[A[i].charAt(j)-'a']++;
			}
			dict.put(A[i],temp);
		}
		int finD[]=new int[26];
		for (int i = 0; i < B.length; i++) {
			for (int j = 0; j < B[i].length(); j++) {
				d[i][B[i].charAt(j)-'a']++;
			}
			for (int j = 0; j < 26; j++) {
				if (d[i][j]>finD[j])finD[j]=d[i][j];
			}
		}
		dict.forEach((k,v)->{
			int flag=0;
			for (int l = 0; l < 26; l++) {
				if (finD[l]>v[l]){
					flag=1;
					break;
				}
			}
			if (flag==0)ans.add(k);
		});
		return ans;
	}
	public static int numPrimeArrangements(int n) {
		int perm=0;
		int m=1000000007;
		for (int i = 2; i <=n ; i++) {
			int flag=0;
			for (int j = 2; j <=Math.sqrt(i) ; j++) {
				if (i%j==0){
					flag=1;
					break;
				}
			}
			if (flag==0)perm++;
		}
		long ans=1;
		for (int i = 1; i <=perm; i++) {
			ans=(ans*i)%m;
		}
		for (int i = 1; i <=n-perm; i++) {
			ans=(ans*i)%m;
		}
		return (int)ans;

	}
	public static String dayOfTheWeek(int day, int month, int year) {
		SimpleDateFormat f = new SimpleDateFormat("yyyy-MM-dd");
		String[] weekDays = {"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"};
		Calendar cal = Calendar.getInstance();
		Date date;
		try {
			date = f.parse(year+"-"+month+"-"+day);
			cal.setTime(date);
		} catch (ParseException e) {
			e.printStackTrace();
		}
		int w = cal.get(Calendar.DAY_OF_WEEK) - 1;
		if (w < 0)
			w = 0;
		return weekDays[w];
	}
	public static int maximumSum(int[] arr) {
		int n=arr.length;
		long sumA[]=new long[n];
		sumA[0]=arr[0];
		long sumS[]=new long[n];
		sumS[0]=Integer.MIN_VALUE;
		int ans=arr[0];
		for (int i = 1; i < n; i++) {
			sumA[i]=Math.max(sumA[i-1]+arr[i],arr[i]);
			sumS[i]=Math.max(sumS[i-1]+arr[i],sumA[i-1]);
			ans=Math.max((int)Math.max(sumA[i],sumS[i]),ans);
		}
		return ans;
	}
	// leetcode 1189
	public int maxNumberOfBalloons(String text) {
		int ans=0;
		int dict[]=new int[5];
		int d[]=new int[5];
		d[0]=1;//a
		d[1]=1;//b
		d[2]=2;//l
		d[3]=2;//o
		d[4]=1;//n
		for (int i = 0; i < text.length(); i++) {
			if (text.charAt(i)=='a')dict[0]++;
			else if (text.charAt(i)=='b')dict[1]++;
			else if (text.charAt(i)=='l')dict[2]++;
			else if (text.charAt(i)=='o')dict[3]++;
			else if (text.charAt(i)=='n')dict[4]++;
		}
		ans=dict[0];
		for (int i = 1; i < 5; i++) {
			ans=Math.min(dict[i]/d[i],ans);
		}
		return ans;
	}
	// leetcode 1190
	public static String reverseParentheses(String s) {
		StringBuilder ans=new StringBuilder();
		Deque<Character> stack=new ArrayDeque<>();
		//List<Character> collect = stack.stream().collect(Collectors.toList());
		for (int i = 0; i < s.length(); i++) {
			if (s.charAt(i)!='('){
				ans.append(s.charAt(i));
			}else {
				stack.add(s.charAt(i));
				while (!stack.isEmpty()|| s.charAt(i)!=')'){
					i++;
					if (i>=s.length())break;
					if (s.charAt(i)==')'){
						Deque<Character> temp=new ArrayDeque<>();
						while (stack.peek()!='('){
							temp.addFirst(stack.pop());
						}
						if (stack.peek()=='(')stack.pop();
						while (!temp.isEmpty())stack.push(temp.removeLast());
					}else {
						stack.push(s.charAt(i));
					}
				}
				if (!stack.isEmpty())while (!stack.isEmpty())ans.append(stack.removeLast());
			}
		}
		return ans.toString();
	}
	// leetcode 1191
	public static int kConcatenationMaxSum(int[] arr, int k) {
		long ans = 0;
		int n=arr.length;
		long sum = 0;
		for (int i = 0; i < n; i++) sum+=arr[i];
		int lmx=0,rmx=0,temp=0;
		for (int i = 0; i < n ; i++) {
			temp+=arr[i];
			lmx=Math.max(temp,lmx);
		}
		temp=0;
		for (int i = n-1; i >=0 ; i--) {
			temp+=arr[i];
			rmx=Math.max(temp,rmx);
		}
		temp=0;
		for (int i = 0; i <n ; i++) {
			temp+=arr[i];
			ans=Math.max(ans,temp);
			if (temp<=0){
				temp=0;
			}
		}
		if (k==1)return (int)ans%1000000007; //当k=0时，直接利用遍历的结果返回最大值
		ans=Math.max(ans,sum*k%1000000007);// 第一种情况，返回扩展后数组的∑
		ans=Math.max(ans,(sum*(k-1))%1000000007+lmx); // 返回k-1段数组+左边最大值
		ans=Math.max(ans,(sum*(k-1))%1000000007+rmx); // 返回k-1段数组+右边最大值
		ans=Math.max(ans,(sum*(k-2))%1000000007+rmx+lmx); // 返回k-2段数组+右边最大值+左边最大值
		ans=Math.max(ans,lmx+rmx); // 返回左边+右边最大值
		return (int)ans%1000000007;
	}
	static final int tableSizeFor(int cap) {
		// ^异或^^相同为0 不同为1
		int n = cap - 1;
		n |= n >>> 1;
		n |= n >>> 2;
		n |= n >>> 4;
		n |= n >>> 8;
		n |= n >>> 16;
		return (n < 0) ? 1 : (n >= 288) ? 288 : n + 1;
	}
	public static void testHashMap(){
		Map<String,String> map=new HashMap<>();
		map.put("s1","s2");
		System.out.println(map.get("s1"));
		System.out.println(map.get("s2"));
		System.out.println(map.size());
		char s = '\u0639';
		System.out.println(s);
	}
	// leetcode 1080
	public TreeNode sufficientSubset(TreeNode root, int limit) {
		return dfs1080(root,limit,0);
	}
	public TreeNode dfs1080(TreeNode root,int limit,int now){
		if (root==null)return root;
		if (root.right==null && root.left==null){
			if ((now+root.val)<limit)return null;
			return root;
		}
		root.left=dfs1080(root.left,limit,root.val+now);
		root.right=dfs1080(root.right,limit,root.val+now);
		if (root.right==null && root.left==null)return null;
		return root;
	}
	// leetcode 1034
	/*boolean visd1034[][];
	public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {
		visd1034=new boolean[grid.length][grid[0].length];
		return dfs1034(grid,r0,c0,color);
	}
	public int[][] dfs1034(int[][] grid,int r0,int c0,int color){
		if (r0>=grid.length || r0<0 || c0>=grid[0].length || c0<0 )return

	}*/
	// leetcode 494 dp
	public static int findTargetSumWays(int[] nums, int S) {
		int ans=0;
		int sum=0;
		for (int i = 0; i < nums.length; i++) {
			sum+=nums[i];
		}
		int dp[][]=new int[nums.length+1][sum*2+1];
		dp[0][sum]=1;
		for (int i = 0; i < nums.length; i++) {
			for (int j = nums[i]; j <= 2*sum -nums[i]; j++) {
				dp[i+1][j+nums[i]]+=dp[i][j];
				dp[i+1][j-nums[i]]+=dp[i][j];
			}
		}
		return dp[nums.length][S+sum];
	}
	// leetcode 494 dfs


	public List<List<Integer>> minimumAbsDifference(int[] arr) {
		List<List<Integer>> ans =new ArrayList<>();
		Arrays.sort(arr);
		int flag= Integer.MAX_VALUE;
		for (int i = 0; i < arr.length - 1; i++) {
			flag=Math.min(Math.abs(arr[i]-arr[i+1]),flag);
		}
		for (int i = 0; i < arr.length - 1; i++) {
			if (Math.abs(arr[i]-arr[i+1])==flag){
				List<Integer> temp=new ArrayList<>();
				temp.add(arr[i]);
				temp.add(arr[i+1]);
				ans.add(temp);
			}
		}
		return ans;
	}
	public static int nthUglyNumber3(int n, int a, int b, int c) {
		long l=1;
		long r=Integer.MAX_VALUE;
		while (l<r){
			long mid=(l+r)>>>1;
			long count=mid/a;
			count+=mid/b;
			count+=mid/c;
			count-=mid/((long) a*b/gcd((long)a,b));
			count-=mid/((long)a*c/gcd((long)a,c));
			count-=mid/((long)b*c/gcd((long)b,c));
			long temp=((long)a*b/gcd((long)a,b));
			//if (temp==0)temp=1;
			count+=mid/((long)temp*c/gcd(c,temp));
			if (count<n){
				l=mid+1;
			}else r=mid;
		}
		return (int)r;
	}
	public static long gcd(long a,long b){
		if (b==0)return a;
		return gcd(b,a%b);
	}
	/*List<Integer>nums=new ArrayList<>();
		int begin=1;
		int indexA=0,indexB=0,indexC=0;
		nums.add(1);
		while (begin<=n){
			nums.add(Math.min(nums.get(indexA)*a,Math.min(nums.get(indexB)*b,nums.get(indexC)*c)));
			if (nums.get(begin)==nums.get(indexA)*a)indexA++;
			if (nums.get(begin)==nums.get(indexB)*b)indexB++;
			if (nums.get(begin)==nums.get(indexC)*c)indexC++;
			begin++;
		}
		return nums.get(n);*/

	/*public String smallestStringWithSwaps(String s, List<List<Integer>> pairs) {
		StringBuilder sb=new StringBuilder(s);

		for (int i = 0; i < pairs.size();i++) {
			pairs.get(i).get(0);
			pairs.get(i).get(1);
		}
	}*/
	public boolean uniqueOccurrences(int[] arr) {
		int dict[]=new int[2050];
		for (int i = 0; i < arr.length; i++) {
			dict[arr[i]+1000]++;
		}
		Arrays.sort(dict);
		for (int i = dict.length-1; i >0 ; i--) {
			if (dict[i]==0)continue;
			if (dict[i]==dict[i-1]){
				return false;
			}
		}
		return true;
	}
	public static int equalSubstring(String s, String t, int maxCost) {
		int dict[]=new int[s.length()];
		for (int i = 0; i < s.length(); i++) {
			dict[i]=Math.abs(s.charAt(i)-t.charAt(i));
		}
		//Arrays.sort(dict);
		int max=0,min=0;
		int temp=0;
		int ans=0;
		int start=0,end=0;
		while (min<=max&&max<s.length()){
			temp+=dict[max++];
			if (temp>maxCost)
				temp-=dict[min++];
			ans=Math.max(max-min,ans);
		}
		return ans;
	}
	public static String removeDuplicates(String s, int k) {
		//Stack<Character> stack=new Stack<>();
		StringBuilder sb=new StringBuilder(s);
		int flag=1;
		while(flag==1){
			flag=0;
			for (int i = 0; i < s.length(); i++) {
				int start=i,end=i;
				while (i+1<s.length() &&s.charAt(i)==s.charAt(i+1)){
					end++;
					i++;
				}
				if ((end-start+1)%k==0){
					flag=1;
					StringBuilder sb1=new StringBuilder();
					for (int j = start; j <=end; j++) {
						sb1.append(" ");
					}
					sb.replace(start,end+1,sb1.toString());
				}else if (end-start+1>k){
					int i1 = (end - start + 1) / k;
					end=start+i1*k-1;
					flag=1;
					StringBuilder sb1=new StringBuilder();
					for (int j = start; j <=end; j++) {
						sb1.append(" ");
					}
					sb.replace(start,end+1,sb1.toString());
				}
			}
			s=sb.toString();
			String replace = s.replace(" ", "");
			sb=new StringBuilder(replace);
			s=replace;
		}
		return s;
	}
	public static int longestSubsequence(int[] arr, int difference) {
		Map<Integer,Integer> dp = new HashMap<>();
		int ans=0;
		for (int i = 0; i < arr.length; i++) {
			int cur=Math.max(dp.containsKey(arr[i])?dp.get(arr[i]):0,(dp.containsKey(arr[i]-difference)?dp.get(arr[i]-difference):0)+1);
			dp.put(arr[i],cur);
			ans=Math.max(ans,cur);
		}
		return ans;
	}
	boolean vis5215[][];
	int code=0;
	public int getMaximumGold(int[][] grid) {
		vis5215 = new boolean[grid.length][grid[0].length];
		int max=0;
		for (int i = 0; i < grid.length; i++) {
			for (int j = 0; j < grid[0].length; j++) {
				if (grid[i][j]==0)continue;
				dfs5215(grid,i,j,0);
			}
		}
		return code;
	}
	public void dfs5215(int[][] grid,int r,int l,int cur){
		if (r>=grid.length || l>=grid[0].length || r<0 ||l<0){
			code=Math.max(code,cur);
			return;
		}
		if (grid[r][l]==0){
			code=Math.max(code,cur);
			return;
		}
		if (vis5215[r][l]){
			code=Math.max(code,cur);
			return;
		}
		cur+=grid[r][l];
		code=Math.max(code,cur);
		vis5215[r][l]=true;
		dfs5215(grid,r-1,l,cur);
		dfs5215(grid,r,l-1,cur);
		dfs5215(grid,r+1,l,cur);
		dfs5215(grid,r,l+1,cur);
		vis5215[r][l]=false;
	}
	public int minCostToMoveChips(int[] chips) {
		int cnt[]=new int[2];
		for (int chip : chips) {
			cnt[chip&1]++;
		}
		return Math.min(cnt[0],cnt[1]);
	}
	String dict5216[]={"ae", "ea", "ei", "ia", "ie", "io", "iu", "oi", "ou","ua"};
	public int countVowelPermutation(int n) {
		if (n==1)return 5;
		// a3 e2 i2 o1 u2
		long dp[] = new long[5];
		Arrays.fill(dp,1);
		long temp[] = new long[5];
		for (int i = 1; i < n; i++) {
			temp[0]=(dp[1]+dp[2]+dp[4])%(1000000000+7);
			temp[1]=(dp[0]+dp[2])%(1000000000+7);
			temp[2]=(dp[1]+dp[3])%(1000000000+7);
			temp[3]=(dp[2])%(1000000000+7);
			temp[4]=(dp[2]+dp[3])%(1000000000+7);
			for (int j = 0; j < 5; j++) {
				dp[j]=temp[j];
			}
		}
		long ans=0;
		for (int i = 0; i < 5; i++) {
			ans=(ans+temp[i])%(1000000000+7);
		}

		return (int)ans;
	}
	public int maxArea(int[] height) {
		int L=0,R=height.length-1;
		int ans=0;
		/* 暴力法O(n^2)
		for (int i = 0; i < height.length; i++) {
			for (int j = i; j < height.length; j++) {
				ans=Math.max(Math.min(height[i],height[j])*(j-i),ans);
			}
		}*/
		// 双指针
		while (L!=R){
			ans=Math.max(ans,Math.min(height[L],height[R])*(R-L));
			if (height[L]>height[R])R++; else L++;
		}
		return ans;
	}
	public static List<List<Integer>> threeSum(int[] nums) {
		Set<List<Integer>> ans =new HashSet<>();
		HashMap<Integer,Integer> dict = new HashMap<>();
		for (int num : nums) {
			if (!dict.containsKey(num)){
				dict.put(num,1);
			}else {
				dict.put(num,dict.get(num)+1);
			}
		}
		// 326ms
		Set<Integer> set = dict.keySet();
		List<Integer> collect = set.stream().collect(Collectors.toList());
		for (int i = 0; i < collect.size(); i++) {
			int get = collect.get(i);
			if (dict.get(get)>1){
				int ditt = -(get*2);
				if (!dict.containsKey(ditt)){
					int k = dict.get(ditt);
					if (ditt == get ){
						if (k>=3){
							List<Integer> tt = Arrays.asList(ditt,ditt,ditt);
							Collections.sort(tt);
							ans.add(tt);
						}
					}else {
						List<Integer> tt = Arrays.asList(ditt,get,get);
						Collections.sort(tt);
						ans.add(tt);
					}
				}
			}
			for (int j = i+1; j < collect.size(); j++) {
				int temp = -(collect.get(i)+collect.get(j));
				if (!dict.containsKey(temp)) continue;
				int k = dict.get(temp);
				if (collect.get(i)==temp)k--;
				if (collect.get(j)==temp)k--;
				if (k>0){
					List<Integer> tt = Arrays.asList(temp,collect.get(i),collect.get(j));
					Collections.sort(tt);
					ans.add(tt);
				}
			}
		}
		return ans.stream().collect(Collectors.toList());
	}
	public static int longestSubstring(String s, int k) {
		int max=0;
		int dict[]=new int[26];
		for (char a: s.toCharArray() ) {
			dict[a-'a']++;
		}
		boolean full = true;
		for (int i = 0; i < 26; i++) {
			if (dict[i]>0 &&dict[i]<k) full=false;
		}
		if (full)return s.length();
		int end=0,start=0;
		while (end<s.length()){
			if (dict[s.charAt(end)-'a']<k){
				max=Math.max(max,longestSubstring(s.substring(start,end),k));
				start=end+1;
			}
			end++;
		}
		max=Math.max(max,longestSubstring(s.substring(start),k));
		return max;
	}
	public static double findMedianSortedArrays(int[] nums1, int[] nums2) {
		int n = (nums1.length+nums2.length)%2;
		List<Integer> attr = new ArrayList<>();
		if (n==1){
			attr.add((nums1.length+nums2.length)/2);
		}else {
			attr.add((nums1.length+nums2.length)/2);
			attr.add((nums1.length+nums2.length)/2+1);
		}
		int L=0,R=0,count=0;
		List<Integer> ans =new ArrayList<>();
		while (L<nums1.length || R<nums2.length){
			count++;
			if (L<nums1.length && R<nums2.length){
				if (nums1[L]<nums2[R]){
					if (attr.contains(count)){
						ans.add(nums1[L]);
					}
					L++;
				}else {
					if (attr.contains(count)){
						ans.add(nums2[R]);
					}
					R++;
				}
			}else {
				if (L>=nums1.length){
					if (attr.contains(count)){
						ans.add(nums2[R]);
					}
					R++;
				}else {
					if (attr.contains(count)) {
						ans.add(nums1[L]);
					}
					L++;
				}
			}
		}
		System.out.println(ans);
		if (n==1)return ans.get(0);
		else return (ans.get(0)+ans.get(1))*1.0/2;
	}
	public boolean canJump(int[] nums) {
		if (nums.length<=1)return true;
		if (nums[0]==0)return false;
		int check[] = new int[nums.length];
		check[nums.length-1]=1;
		for (int i = nums.length-1; i >=0 ; i--) {
			for (int j = nums[i]; j >=1 ; j--) {
				if (i+j<nums.length && check[i+j]==1){
					check[i]=1;
					break;
				}
			}
		}
		return check[0]==1?true:false;
		/*
		* if (nums.length<=1)return true;
		if (nums[0]==0)return false;
		int end = nums.length-1;
        for (int i=nums.length-1; i>=0 ; i--){
            if(i+nums[i]>=end){
                end=i;
            }
        }
        return end==0;
		*
		*
		* */
	}
	public static void setZeroes(int[][] matrix) {
		Map<Integer,List<Integer>> dict = new HashMap<>();
		for (int i = 0; i < matrix.length; i++) {
			for (int j = 0; j < matrix[0].length; j++) {
				if (matrix[i][j]==0){
					if (dict.containsKey(i)){
						dict.get(i).add(j);
					}else {
						List<Integer> list =new ArrayList<>();
						list.add(j);
						dict.put(i,list);
					}
				}
			}
		}
		dict.forEach((k,v)->{
			Arrays.fill(matrix[k],0);
			v.forEach(pageNum -> {
				for (int i = 0; i < matrix.length; i++) {
					matrix[i][pageNum]=0;
				}
			});
		});
	}
	public boolean isPalindrome(String s) {
		StringBuilder s1= new StringBuilder();
		StringBuilder s2= new StringBuilder();
		String s3 = s.toUpperCase();
		int n =s3.length();
		for (int i = 0; i < n; i++) {
			if (s3.charAt(i)>='A' && s3.charAt(i)<='Z' || s3.charAt(i)>='0' && s3.charAt(i)<='9'){
				s1.append(s3.charAt(i));
			}
			if (s3.charAt(n-1-i)>='A' && s3.charAt(n-1-i)<='Z' || s3.charAt(n-1-i)>='0' && s3.charAt(n-1-i)<='9'){
				s2.append(s3.charAt(n-1-i));
			}
		}
		return s1.toString().equals(s2.toString())?true:false;
	}
	public int canCompleteCircuit(int[] gas, int[] cost) {
		int n = gas.length;
		int dit[] = new int[n];
		for (int i = 0; i < n; i++) {
			dit[i]=gas[i]-cost[i];
		}
		int ans = 0;
		int jh = 0;
		int flag = 0;
		boolean can = true;
		while (flag<n){
			jh=0;
			can = true;
			ans=flag;
			while (ans<n && can ==true){
				jh+=dit[ans++];
          				if (jh<0) {
					can=false;
				}
			}
			ans =0;
			while (ans<flag && can ==true){
				jh+=dit[ans++];
				if (jh<0) {
					can=false;
				}
			}
			if (can)return flag;
			flag++;
		}
		return -1;
	}
	/*
	* leetcode week 158
	* */
	public int balancedStringSplit(String s) {
		int a = 0;
		int ans=0;
		for (int i = 0; i < s.length(); i++) {
			if (s.charAt(i)=='L')a--;
			else if (s.charAt(i)=='R')a++;
			if (a==0)ans++;
		}
		return ans;
	}
	public List<List<Integer>> queensAttacktheKing(int[][] queens, int[] king) {
		List<List<Integer>> ans = new ArrayList<>();
		List<Integer> dict = new ArrayList<>();
		for (int i = 0; i < queens.length; i++) {
			int t=0;
			for (int j = 0; j < queens[i].length; j++) {
				t=t*10+queens[i][j];
			}
			dict.add(t);
		}
		int L=king[0],R=king[1];
		// 右边
		int tL=L,tR=R+1;
		while (tL>=0 && tL<8 && tR>=0 && tR<8){
			if (dict.contains(tL*10+tR)){
				List<Integer> temp = new ArrayList<>();
				temp.add(tL);
				temp.add(tR);
				ans.add(temp);
				break;
			}
			tR++;
		}
		// 左边
		tL=L;tR=R-1;
		while (tL>=0 && tL<8 && tR>=0 && tR<8){
			if (dict.contains(tL*10+tR)){
				List<Integer> temp = new ArrayList<>();
				temp.add(tL);
				temp.add(tR);
				ans.add(temp);
				break;
			}
			tR--;
		}
		// 上边
		tL=L-1;tR=R;
		while (tL>=0 && tL<8 && tR>=0 && tR<8){
			if (dict.contains(tL*10+tR)){
				List<Integer> temp = new ArrayList<>();
				temp.add(tL);
				temp.add(tR);
				ans.add(temp);
				break;
			}
			tL--;
		}
		// 下边
		tL=L+1;tR=R;
		while (tL>=0 && tL<8 && tR>=0 && tR<8){
			if (dict.contains(tL*10+tR)){
				List<Integer> temp = new ArrayList<>();
				temp.add(tL);
				temp.add(tR);
				ans.add(temp);
				break;
			}
			tL++;
		}
		// 左上
		tL=L-1;tR=R-1;
		while (tL>=0 && tL<8 && tR>=0 && tR<8){
			if (dict.contains(tL*10+tR)){
				List<Integer> temp = new ArrayList<>();
				temp.add(tL);
				temp.add(tR);
				ans.add(temp);
				break;
			}
			tL--;
			tR--;
		}
		// 右上
		tL=L-1;tR=R+1;
		while (tL>=0 && tL<8 && tR>=0 && tR<8){
			if (dict.contains(tL*10+tR)){
				List<Integer> temp = new ArrayList<>();
				temp.add(tL);
				temp.add(tR);
				ans.add(temp);
				break;
			}
			tL--;
			tR++;
		}
		// 左下
		tL=L+1;tR=R-1;
		while (tL>=0 && tL<8 && tR>=0 && tR<8){
			if (dict.contains(tL*10+tR)){
				List<Integer> temp = new ArrayList<>();
				temp.add(tL);
				temp.add(tR);
				ans.add(temp);
				break;
			}
			tL++;
			tR--;
		}
		// 右下
		tL=L+1;tR=R+1;
		while (tL>=0 && tL<8 && tR>=0 && tR<8){
			if (dict.contains(tL*10+tR)){
				List<Integer> temp = new ArrayList<>();
				temp.add(tL);
				temp.add(tR);
				ans.add(temp);
				break;
			}
			tL++;
			tR++;
		}
		return ans;
	}
	public int dieSimulator(int n, int[] rollMax) {
		long mod = 1000000000+7;
		long dp[][][] = new long[n+1][6][20];
		for (int i = 0; i < 6; i++) {
			dp[0][i][1]=1;
		}
		for (int i = 1; i < n; i++) {
			for (int j = 0; j < 6; j++) {
				for (int k = 0; k < 6; k++) {
					if (k==j){
						for (int l = 1; l < rollMax[k] ; l++) {
							dp[i][j][l+1]+=dp[i-1][k][l];
							dp[i][j][l+1]%=mod;
						}
					}else {
						for (int l = 1; l <= rollMax[k] ; l++) {
							dp[i][j][1]+=dp[i-1][k][l];
							dp[i][j][1]%=mod;
						}
					}
				}
			}
		}
		int res=0;
		for (int i = 0; i < 6; i++) {
			for (int j = 1; j <= rollMax[i] ; j++) {
				res+=dp[n-1][i][j];
				res%=mod;
			}
		}
		return res;
	}
	public int ugly2(int n){
		int index2=0;
		int index3=0;
		int index5=0;
		int dp[] = new int[n+1];
		dp[0]=1;
		int i=1;
		// 也就是说每个丑数都能以他们的底为基准，乘上2,3,5
		while (i<n){
			dp[i]=Math.min(Math.min(dp[index2]*2,dp[index3]*3),dp[index5]*5);
			if (dp[i]==dp[index2]*2)index2++;
			if (dp[i]==dp[index3]*3)index3++;
			if (dp[i]==dp[index5]*5)index5++;
			i++;
		}
		return dp[n-1];
	}
	public int SuperUgly(int n,int[] primes){
		int index[] = new int[primes.length];
		int dp[] = new int[n+1];
		dp[0]=1;
		int i=1;
		while (i<n){
			int min = dp[index[0]]*primes[0];
			for (int j = 0; j < primes.length; j++) {
				dp[i]=Math.min(dp[index[j]]*primes[i],min);
			}
			for (int j = 0; j < primes.length; j++) {
				if (dp[i]==dp[j]*primes[j])index[j]++;
			}
			i++;
		}
		return dp[n-1];
	}
	/*
	格雷码+位运算！！！没思路
	Set<Integer> set5239 = new HashSet<>();
	List<Integer> res5239 = new ArrayList<>();
	public List<Integer> circularPermutation(int n, int start) {
		set5239.add(start);
		res5239.add(start);
		dfs5239(n,start);
		return res5239;
	}
	boolean dfs5239(int n,int cur){
		if (res5239.size()==(1<<n)){
			int temp = res5239.get(0)^cur;
			return (temp^(temp-1))==0;
		}
		for (int i = 0; i < n; i++) {
			if (set5239.contains(cur^i<<1)){
				set5239.add(cur>>i&1);
				res5239.add(cur>>i&1);

			}
		}


		return false;
	}*/



	int[] dict5240 =new int[26];
	int ans5240=0;
	public int maxLength(List<String> arr) {
		dfs5240(arr,0,0);
		return ans5240;
	}
	public void dfs5240(List<String> arr,int i,int cost){
		ans5240=Math.max(ans5240,cost);
		if (i>=arr.size()){
			return;
		}
		// not
		dfs5240(arr,i+1,cost);
		for (int j = 0; j <arr.get(i).length(); j++) {
			dict5240[arr.get(i).charAt(j)-'a']++;
		}
		boolean flag=true;
		for (int j = 0; j < 26; j++) {
			if (dict5240[j]>1){
				flag=false;break;
			}
		}
		if (flag) {
			cost += arr.get(i).length();
			// Choice
			dfs5240(arr, i + 1, cost);
		}
		for (int j = 0; j <arr.get(i).length(); j++) {
			dict5240[arr.get(i).charAt(j)-'a']--;
		}
	}
	List<String> res22 = new ArrayList<>();
	public List<String> generateParenthesis(int n) {
		dfs22(0,n*2,new StringBuilder());
		return res22;
	}
	public void dfs22(int leftCnt,int n,StringBuilder sb){
		if (n==sb.length()){
			res22.add(sb.toString());
			return;
		}
		if (leftCnt>0){
			sb.append(')');
			dfs22(leftCnt-1,n,sb);
			sb.deleteCharAt(sb.length()-1);
		}
		if (n-sb.length()>leftCnt){
			sb.append('(');
			dfs22(leftCnt+1,n,sb);
			sb.deleteCharAt(sb.length()-1);
		}
	}
	public String longestPalindrome123(String s) {
		int n = s.length();
		boolean dp[][] = new boolean[n+2][n+2];
		dp[0][0]=true;
		int left=-1,right=-1;
		int max=1;//最好遍历左下半边（先遍历高边界而不是低边界，这样才能够正常遍历）
		for (int i=0;i<n;i++){
			dp[i][i]=true;
			for (int j=i-1;j>=0;j--){
				dp[i][j]=(i-j==1||dp[i-1][j+1])&&s.charAt(i)==s.charAt(j);
				if (dp[i][j]==true && i-j>max){
					left=j;right=i;max=i-j;
				}
			}
		}
		return s.substring(left,right+1);
	}
	int res127=Integer.MAX_VALUE;
	Set<String> set127 = new HashSet<>();
	public int ladderLength(String beginWord, String endWord, List<String> wordList) {
		dfs127(beginWord,endWord,1,wordList);
		return res127==Integer.MAX_VALUE?0:res127;
	}
	public void dfs127(String cur,String attr,int now,List<String> wordList){
		if (cur.equals(attr)){
			res127=Math.min(res127,now);
			return;
		}
		if(set127.size()==wordList.size())return;
		for (String temp: wordList) {
			int flag=0;
			if (!set127.contains(temp)){
				for (int i = 0; i < temp.length(); i++) {
					if (temp.charAt(i)!=cur.charAt(i)){
						flag++;
					}
				}
				if (flag==1){
					set127.add(temp);
					dfs127(temp,attr,now+1,wordList);
					set127.remove(temp);
				}
			}
		}
	}
	public void sortColors(int[] nums) {
		int[] count=new int[3];
		for (int i = 0; i < nums.length; i++) {
			count[nums[i]]++;
		}
		int flag=0;
		for (int i = 0; i <3 ; i++) {
			for (int j = 0; j < nums[i]; j++) {
				nums[flag++]=i;
			}
		}
	}
	List<List<String>> res131 = new ArrayList<>();
	public List<List<String>> partition(String s) {
		dfs131(s,0,new ArrayList<>());
		return res131;
	}
	public boolean canRev(String s){
		for (int i = 0; i < s.length(); i++) {
			if (s.charAt(i)!=s.charAt(s.length()-1-i))return false;
		}
		return true;
	}
	public void dfs131(String s,int cur,List<String> temp){
		if (cur>=s.length()){
			res131.add(new ArrayList<>(temp));
			return;
		}
		for (int i = cur; i < s.length(); i++) {
			if (canRev(s.substring(cur,i+1))){
				temp.add(s.substring(cur,i+1));
				dfs131(s,i+1,temp);
				temp.remove(temp.size()-1);
			}
		}
	}
	// LeetCode格雷编码
	public List<Integer> grayCode(int n) {
		//异或 ^相同为0,不同为1
		List<Integer> ret = new ArrayList<>();
		for(int i = 0; i < 1<<n; ++i)
			ret.add(i ^ i>>1);
		return ret;
	}
	// LeetCode循环码排列
	public List<Integer> circularPermutation(int n, int start) {
		List<Integer> temp = new ArrayList<>();
		// 生成所有的格雷码
		for(int i = 0; i < 1<<n; ++i)
			temp.add(i ^ i>>1);
		List<Integer> res = new ArrayList<>();
		int flag = -1;
		// 找到起始位置
		for (int i = 0; i < temp.size() && flag==-1 ; i++)
			if (start==temp.get(i))flag=i;
		// 插入答案
		for (int i = flag; i < temp.size(); i++)
			res.add(temp.get(i));
		for (int i = 0; i <flag; i++)
			res.add(temp.get(i));
		return res;
	}
	// leetcode 43字符串相乘
	public String multiply(String num1, String num2) {
		StringBuilder re = new StringBuilder();
		int strMin = Math.min(num1.length(),num2.length());
		int flag=0;
		for (int i = strMin-1; i >=0 ; i--) {
			re.append(((num1.charAt(i)-'0')*(num2.charAt(i)-'0'))%10+flag);
			flag=(((num1.charAt(i)-'0')*(num2.charAt(i)-'0'))+flag)/10;
		}
		return re.toString();
	}
	public boolean containsDuplicate(int[] nums) {
		Set<Integer> set = new HashSet<>(nums.length);
		for (int i = 0; i < nums.length; i++) {
			if (set.contains(nums[i]))return true;
			set.add(nums[i]);
		}
		return false;
	}
	public int minimumSwap(String s1, String s2) {
		int n = s1.length();
		int sum1=0,sum2=0;
		for (int i = 0; i < n; i++) {
			if (s1.charAt(i)=='x')sum1++;
			else sum2++;
			if (s2.charAt(i)=='x')sum1++;
			else sum2++;
		}
		if (sum1%2!=0||sum2%2!=0)return -1;
		sum1=0;
		sum2=0;
		for (int i = 0; i <n ; i++) {
			if (s1.charAt(i)!=s2.charAt(i)){
				if (s1.charAt(i)=='x')sum1++;
				else sum2++;
			}
		}
		return (sum1)%2==1?(sum1+sum2)/2+1:(sum1+sum2)/2;
	}
	public String minRemoveToMakeValid(String s) {
		Deque<Character> deque = new ArrayDeque<>();
		StringBuilder dict = new StringBuilder();
		for (int i = 0; i < s.length(); i++) {
			if (s.charAt(i)=='('||s.charAt(i)==')')dict.append(s.charAt(i));
		}
		int flag=0;
		List<Character> list = new ArrayList<>();
		for (int i = 0; i < dict.length(); i++) {
			if (dict.charAt(i)=='('){
				flag++;
			}else flag--;
			if (flag==0){
				deque.add(dict.charAt(i));
				while (!deque.isEmpty()) list.add(deque.pop());
			}else if (flag<0)flag=0;
			else deque.add(dict.charAt(i));
		}

		while (!deque.isEmpty())
			list.add(deque.pop());
		List<Character> list1 = new ArrayList<>();
		flag=0;
		for (int i = list.size()-1; i >=0; i--) {
			if (list.get(i)==')'){
				flag++;
			}else flag--;
			if (flag==0){
				deque.add(list.get(i));
				while (!deque.isEmpty()) list1.add(0,deque.pop());
			}else if (flag<0)flag=0;
			else deque.add(list.get(i));
		}
		StringBuilder res = new StringBuilder();
		flag=0;
		for (int i = 0; i < s.length(); i++) {
			if (s.charAt(i)=='(' || s.charAt(i)==')'){
				if (flag<list1.size() && s.charAt(i)==list1.get(flag)){
					flag++;
					res.append(s.charAt(i));
				}
			}else res.append(s.charAt(i));
		}
		return res.toString();
	}
	public int numberOfSubarrays(int[] nums, int k) {
		List<Integer> dict = new ArrayList<>();
		for (int i = 0; i < nums.length; i++)  if (nums[i]%2!=0)dict.add(i);
		if (dict.size()<k)return 0;
		if (dict.size()==k) return (dict.get(0)+1)*(nums.length-1-dict.get(k-1)+1);
		int res = 0;
		int L=0,R=k-1;
		while(R<dict.size()){
			if (R==dict.size()-1){
				res = res +(dict.get(L)-dict.get(L-1))*(nums.length-dict.get(R));
			}else if (L==0){
				res = res +(dict.get(L)-0+1)*(dict.get(R+1)-dict.get(R));
			}else {
				res = res +(dict.get(L)-dict.get(L-1))*(dict.get(R+1)-dict.get(R));
			}
			L++;R++;
		}
		return res;
	}
	public boolean isGoodArray(int[] nums) {
		int n = nums.length;
		int dd=nums[0];
		for (int i = 1; i < n; i++) {
			dd = gcd(nums[i],dd);
			if (dd==1)return true;
		}
		return dd==1;
	}
	public int gcd(int a,int b){
		if (b==0)return a;
		return gcd(b,a%b);
	}


	List<List<Integer>> res39 = new ArrayList<>();
	public List<List<Integer>> combinationSum(int[] candidates, int target) {
		dfs39(new ArrayList<>(),0,target,candidates,0);
		return res39;
	}
	public void dfs39(List<Integer> container,int curr,int target,int [] dict, int index){
		if (curr==target){
			res39.add(new ArrayList<>(container));
			return;
		}
		for (int j = index; j < dict.length; j++) {//不能够直接从0开始遍历,应该从当前的index位置
			if (curr+dict[j]<=target){
				container.add(dict[j]);
				dfs39(container,curr+dict[j],target,dict,j);
				container.remove(container.size()-1);
			}
		}
	}
	public int[][] merge(int[][] intervals) {
		int n = intervals.length;
		if(n <= 1)return intervals;
		int flag = 0;
		Map<Integer,Integer> map = new HashMap<>();
		Arrays.sort(intervals, new Comparator<int[]>() {
			@Override
			public int compare(int[] o1, int[] o2) {
				return o1[0]-o2[0];
			}
		});
		for (int i = 0; i < n-1; i++) {
			flag = 0;
			if (intervals[i][1]>=intervals[i+1][0]){
				intervals[i+1][0] = Math.min(intervals[i][0],intervals[i+1][0]);
				intervals[i+1][1] = Math.max(intervals[i][1],intervals[i+1][1]);
				flag=1;
			}
			if (flag==0){
				map.put(intervals[i][0],intervals[i][1]);
			}
		}
		flag=0;
		map.put(intervals[n-1][0],intervals[n-1][1]);
		int res[][] = new int[map.size()][2];
		for (Integer a :map.keySet()) {
			res[flag][0]=a;
			res[flag++][1]=map.get(a);
		}
		return res;
	}
	List<List<Integer>> res77 = new ArrayList<>();
	public List<List<Integer>> combine(int n, int k) {
		dfs77(n,k,0,new ArrayList<>());
		return res77;
	}
	public void dfs77(int n,int k,int index,List<Integer> temp){
		if (temp.size()==k){
			res77.add(new ArrayList<>(temp));
			return;
		}
		for (int i = index+1; i <= n; i++) {
			temp.add(i);
			dfs77(n,k,i,temp);
			temp.remove(temp.size()-1);
		}
	}
	public int oddCells(int n, int m, int[][] indices) {
		int dict[][] = new int[n][m];
		for (int i = 0; i < indices.length; i++) {
			for (int j = 0; j < dict[0].length; j++) {
				dict[indices[i][0]][j]++;
			}
			for (int j = 0; j < dict.length; j++)
				dict[j][indices[i][1]]++;
		}
		int res=0;
		for (int i = 0; i < dict.length; i++) {
			for (int j = 0; j < dict[i].length; j++) {
				if (dict[i][j]%2!=0)res++;
			}
		}
		return res;
	}
	public List<List<Integer>> reconstructMatrix(int upper, int lower, int[] colsum) {
		List<List<Integer>> res = new ArrayList<>();
		List<Integer> list1 = new ArrayList<>();
		List<Integer> list2 = new ArrayList<>();
		for (int i = 0; i < colsum.length; i++) {
			if (colsum[i]==2){
				if (upper<1)return res;
				if (lower<1)return res;
				list1.add(1);
				list2.add(1);
				upper--;
				lower--;
			}else if (colsum[i]==1){
				if (upper>lower){
					list1.add(1);
					upper--;
					list2.add(0);
				}else {
					lower--;
					list2.add(1);
					list1.add(0);
				}
			}else {
				list1.add(0);
				list2.add(0);
			}
		}
		if (upper!=0 || lower!=0)return res;
		res.add(list1);
		res.add(list2);
		return res;
	}

	boolean visit5257[][];
	int[] dx5257 = {0,1,0,-1};
	int[] dy5257 = {1,0,-1,0};
	public int closedIsland(int[][] grid) {
		int res=0;
		visit5257 = new boolean[grid.length][grid[0].length];
		int n = grid.length,m = grid[0].length;
		for (int i = 0; i < n; i++) {
			for (int j = 0; j < m; j++) {
				if (!visit5257[i][j] && grid[i][j]==0){
					boolean ref = dfs5257(i, j, n, m, grid);
					if (ref)res++;
				}
			}
		}
		return res;
	}
	public boolean dfs5257(int nowL,int nowR,int n,int m,int[][]grid){
		visit5257[nowL][nowR]=true;
		boolean flag = true;
		for (int i = 0; i < 4; i++){
			int dx=nowL+dx5257[i],dy=nowR+dy5257[i];
			if (dx < 0 || dy<0 ||dx >= n || dy >= m){
				flag=false;
			}else if (!visit5257[dx][dy] && grid[dx][dy]==0){
				boolean ref = dfs5257(dx, dy, n, m, grid);
				flag = ref && flag;
			}
		}
		return flag;
	}
//	public List<String> removeComments(String[] source) {
//		List<String> res = new ArrayList<>();
//		for (int i = 0; i < source.length; i++) {
//			if (source[i].indexOf("/*")!=-1){
//				for (int j = 0; j < source[i].length()-1; j++) {
//					if (source[i].charAt(j)=='/' && source[i].charAt(j+1)=='*'){
//						StringBuilder sb = new StringBuilder();
//						for (int k = 0; k < j; k++) {
//							sb.append(source[k]);
//						}
//						if (sb.length()>=1)
//							res.add(sb.toString());
//					}
//				}
//				for (; i < source.length ; i++) {
//					if (source[i].indexOf("*/")!=-1){
//						break;
//					}
//				}
//			}else if (source[i].indexOf("//")!=-1){
//				for (int j = 0; j < source[i].length()-1; j++) {
//					if (source[i].charAt(j)=='/' && source[i].charAt(j+1)=='/'){
//						StringBuilder sb = new StringBuilder();
//						for (int k = 0; k < j; k++) {
//							sb.append(source[k]);
//						}
//						res.add(sb.toString());
//					}
//				}
//			}else res.add(source[i]);
//		}
//		return res;
//	}
	/**/
	int res64=Integer.MAX_VALUE;
	public int minPathSumDfs(int[][] grid) {
		dfs64(0,0,grid,grid[0][0]);
		return res64;
	}
	public void dfs64(int nowL,int nowR,int[][] grid,int score){
		if (nowL<0 || nowR<0 || nowL>=grid.length || nowR >=grid[0].length)
			return;
		if (nowL==grid.length-1 && nowR == grid[0].length-1){
			res64=Math.min(res64,score);
			return;
		}
		dfs64(nowL+1,nowR,grid,score+grid[nowL][nowR]);
		dfs64(nowL,nowR+1,grid,score+grid[nowL][nowR]);
	}
	public int minPathSum(int[][] grid) {
		for (int i = 0; i < grid.length; i++) {
			for (int j = 0; j < grid[i].length; j++) {
				if (i==j && i==0)
					grid[i][j]=grid[i][j];
				else
					grid[i][j]=grid[i][j] + Math.min((i-1)<0?Integer.MAX_VALUE:grid[i-1][j],(j-1)<0?Integer.MAX_VALUE:grid[i][j-1]);
			}
		}
		return grid[grid.length-1][grid[0].length-1];
	}
	public List<List<Integer>> shiftGrid(int[][] grid, int k) {
		int n = grid.length*grid[0].length;
		List<Integer> dict = new ArrayList<>();
		for (int i = 0; i < grid.length; i++) {
			for (int j = 0; j < grid[i].length; j++) {
				dict.add(grid[i][j]);
			}
		}
		List<List<Integer>> res = new ArrayList<>();
		int flag = 0;
		int red = grid[0].length;
		List<Integer> temp = new ArrayList<>();
		k=k%n;
		for (int i = n-k; i < n; i++) {
			flag++;
			if (flag % red==0){
				temp.add(dict.get(i));
				res.add(temp);
				temp = new ArrayList<>();
			}else {
				temp.add(dict.get(i));
			}
		}
		for (int i = 0; i < n-k; i++) {
			flag++;
			if (flag % red==0){
				temp.add(dict.get(i));
				res.add(temp);
				temp = new ArrayList<>();
			}else {
				temp.add(dict.get(i));
			}
		}
		return res;
	}
	class FindElements {

		List<Integer> dict = new ArrayList<>();
		public FindElements(TreeNode root) {
			dfsStructure(root,0,-1);
		}
		// L = 0 L 1 R
		public void dfsStructure(TreeNode root,int val,int L){
			if(root == null) return;
			if(L==0){
				root.val = val*2+1;
			}else if(L == 1){
				root.val = val*2+2;
			}else root.val=0;
			dict.add(root.val);
			dfsStructure(root.left,root.val,0);
			dfsStructure(root.right,root.val,1);
		}
		public boolean find(int target) {
			return dict.contains(target);
		}
	}
	public int maxSumDivThree(int[] nums) {
		int n = nums.length;
		int res = 0;
		List<Integer> dict1 = new ArrayList<>();
		List<Integer> dict2 = new ArrayList<>();
		for (int i = 0; i < n; i++) {
			if (nums[i]%3==1)dict1.add(nums[i]);
			else if (nums[i]%3==2)dict2.add(nums[i]);
			res+=nums[i];
		}
		Collections.sort(dict1);
		Collections.sort(dict2);
		if (res%3==1){
			return Math.max(dict1.size()>0?res-dict1.get(0):-1,dict2.size()>1?res-dict2.get(0)-dict2.get(1):-1);
		}else if (res%3==2){
			return Math.max(dict1.size()>1?res-dict1.get(0)-dict1.get(1):-1,dict2.size()>0?res-dict2.get(0):-1);
		}else
			return res;
	}

	public int minTimeToVisitAllPoints(int[][] points) {
		int res=0;
		for (int i = 0; i < points.length - 1; i++) {
			int a=points[i][0]-points[i+1][0];
			int b=points[i][1]-points[i+1][1];
			res+= Math.max(Math.abs(a),Math.abs(b));
		}
		return res;

	}
	public int countServers(int[][] grid) {
		int res = 0;
		for (int i = 0; i < grid.length; i++) {
			int flag = 0;
			for (int j = 0; j < grid[i].length; j++) {
				if (grid[i][j]==0)continue;
				for (int k = 0; k < j; k++) {
					if (grid[i][k]==1){
						flag=1;
						break;
					}
				}
				for (int k = j+1; k < grid[i].length; k++) {
					if (flag ==1 ||grid[i][k]==1){
						flag=1;
						break;
					}
				}
				for (int k = 0; k < i; k++) {
					if (flag ==1 || grid[k][j]==1){
						flag=1;
						break;
					}
				}
				for (int k = i+1; k < grid.length; k++) {
					if (flag ==1 ||grid[k][j]==1){
						flag=1;
						break;
					}
				}
				if (flag==1){
					flag=0;
					res++;
				}
			}
		}
		return res;
	}
class Trie {
	class TrieNode{
		TrieNode[] child;//记录孩子节点
		int is_end;//记录当前节点是不是一个单词的结束字母
		public TrieNode(){//
			child = new TrieNode[26];//子节点数组长度26，0：‘a’，1：‘b’.....
			is_end = 0;
		}
	}
	TrieNode root;
	/** Initialize your data structure here. */
	public Trie() {
		root=new TrieNode();
	}

	/** Inserts a word into the trie. */
	public void insert(String word) {
		TrieNode p=root;
		for(char a:word.toCharArray()){
			int d=a-'a';
			if(p.child[d]==null){
				p.child[d]=new TrieNode();
			}
			p=p.child[d];
		}
		p.is_end++;
	}

	/** Returns if the word is in the trie. */
	public List<String> search(String word) {
		TrieNode p=root;
		for(char a:word.toCharArray()){
			int d=a-'a';
			if(p.child[d]==null)return new ArrayList<>();
			p=p.child[d];
		}
		StringBuilder sb = new StringBuilder();
		sb.append(word);
		List<String> list = new ArrayList<>();
		dfs(p,list,sb);
		return list;
	}
	public void dfs(TrieNode p, List<String> list,StringBuilder sb){
		if (list.size()==3 )return;
		if (p.is_end>0){
			for (int i = 0; i < p.is_end; i++) {
				if(list.size()<3)
					list.add(new String(sb.toString()));
			}
		}
		for (int i = 0; i < 26; i++) {
			if (p.child[i] != null) {
				sb.append((char) (i + 'a'));
				dfs(p.child[i], list, sb);
				sb.delete(sb.length()-1,sb.length());
			}
		}
	}
	/** Returns if there is any word in the trie that starts with the given prefix. */
	public boolean startsWith(String prefix) {
		TrieNode p=root;
		for(char a:prefix.toCharArray()){
			int d=a-'a';
			if(p.child[d]==null)return false;
			p=p.child[d];
		}
		return true;
	}
}
	public List<List<String>> suggestedProducts(String[] products, String searchWord) {
		List<List<String>> res = new ArrayList<>();
		Trie t = new Trie();
		for (int i = 0; i < products.length; i++) {
			t.insert(products[i]);
		}
		StringBuilder sb = new StringBuilder();
		for (int i = 0; i < searchWord.length(); i++) {
			sb.append(searchWord.charAt(i));
			if (!t.startsWith(sb.toString())){
				res.add(new ArrayList<>());
			}else res.add(t.search(sb.toString()));
		}
		return res;
	}
	public  static void main(String[] args) {
		String s="A man, a plan, a canal: Panama";
		String a1[]={"si","go","se","cm","so","ph","mt","db","mb","sb","kr","ln","tm","le","av","sm","ar","ci","ca","br","ti","ba","to","ra","fa","yo","ow","sn","ya","cr","po","fe","ho","ma","re","or","rn","au","ur","rh","sr","tc","lt","lo","as","fr","nb","yb","if","pb","ge","th","pm","rb","sh","co","ga","li","ha","hz","no","bi","di","hi","qa","pi","os","uh","wm","an","me","mo","na","la","st","er","sc","ne","mn","mi","am","ex","pt","io","be","fm","ta","tb","ni","mr","pa","he","lr","sq","ye"};
		int a[]={2,3,4};
		List<String> a22 =new ArrayList<>(Arrays.asList(a1));
		int bo[]={2,1,2,0,1,0,1,2,0,1};
		char b1[][]={{'a','b'}};
		char b2[][]={{'C','A','A'},{'A','A','A'},{'B','C','D'}};
		char b3[][]={{'A','B','C','E'},{'S','F','E','S'},{'A','D','E','E'}};
		String[] caca={"/*Test program */", "int main()", "{ ", "  // variable declaration ", "int a, b, c;", "/* This is a test", "   multiline  ", "   comment for ", "   testing */", "a = b + c;", "}"};
		int adf[][] = {{1,2,3},{4,5,6}};
		//System.out.println(nthUglyNumber3(1000000000,2,217983653,336916467));
		DemoApplicationTests d=new DemoApplicationTests();
		int [][] acw={{1,1},{3,4},{-1,0}};
		System.out.println(d.minTimeToVisitAllPoints(acw));
		/*<pre><code class="language-java line-numbers">代码内容</code></pre>*/


		/*TreeNode root=new TreeNode(5);
		root.left=new TreeNode(-6);
		root.right=new TreeNode(-6);*/
		//System.out.println(findTargetSumWays(a,3));
	}
/*
*
*
*
*
*
*
*

*
*
*
*
*
*
*
*
*
* */

}
