package cn.Ideal.demo;


import com.google.common.collect.Comparators;
import javafx.util.Pair;
import org.apache.solr.client.solrj.io.stream.HashJoinStream;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.stereotype.Repository;
import org.springframework.test.context.junit4.SpringRunner;
import sun.nio.cs.ext.MacHebrew;
import sun.reflect.generics.tree.Tree;

import javax.annotation.Resource;
import javax.annotation.Resources;
import javax.xml.bind.JAXBContext;
import javax.xml.bind.JAXBException;
import javax.xml.bind.Unmarshaller;
import java.io.StringReader;
import java.nio.charset.StandardCharsets;
import java.sql.Array;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.time.LocalDate;
import java.time.Period;
import java.util.*;
import java.util.Map.Entry;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.locks.ReentrantLock;
import java.util.function.Predicate;
import java.util.stream.Collectors;
import java.util.stream.Stream;

@RunWith(SpringRunner.class)
@SpringBootTest
public class DemoApplicationTests {

	@Test
	public void contextLoads() {
	}
	public  static int twoCitySchedCost(int[][] costs) {
		int max=0;
		int left=0;
		int right=0;
		int length=costs.length;
		int res=length/2;
		int[] a=new int[length];
		for (int i = 0; i < costs.length; i++) {
			a[i]=Math.abs(costs[i][0]-costs[i][1]);
		}
		for(int i = 0; i < a.length - 1; i++) {// 做第i趟排序
			int k = i;
			for(int j = k + 1; j < a.length; j++){// 选最小的记录
				if(a[j] < a[k]){
					k = j; //记下目前找到的最小值所在的位置
				}
			}
			if(i != k){  //交换a[i]和a[k]
				int temp = a[i];
				a[i] = a[k];
				a[k] = temp;
				int[] temp2 = costs[i];
				costs[i] = costs[k];
				costs[k] = temp2;
			}
		}
		int flag=0;
		for (int i = length-1; i >= 0; i--) {
			if (costs[i][0]==costs[i][1]){
				flag++;
				continue;
			}
			if (right<res){
				if (costs[i][0]>costs[i][1]){
					max+=costs[i][1];
					right++;
					continue;
				}
				if (left<res){
					if (costs[i][1]>costs[i][0]){
						max+=costs[i][0];
						left++;
						continue;
					}
				}else {
					max+=costs[i][1];
					right++;
					continue;
				}
			}else {
				max+=costs[i][0];
				left++;
				continue;
			}
		}
		for (int i = 1; i <=flag ; i++) {
			max+=costs[i-1][0];
		}
		return max;
	}
	public static int[][] allCellsDistOrder(int R, int C, int r0, int c0) {
		int[][]a=new int[R][C];
		boolean flag=false;
		boolean flag1=false;
		for (int i = 0; i < R; i++) {
			int r1=r0;
			int c1=c0;
			int r2=r0-1;
			int c2=c0-1;
			for (int j = 0; j < C; j++) {
				for (int k = 0; k < 2; k++) {
					if (flag){
						if (flag1) {
							a[i][j] = r1++;
							flag1=!flag1;
						}else {
							a[i][j] = r2--;
							flag1=!flag1;
						}
						flag=!flag;
					}else {
						if (flag1) {
							a[i][j] = c1++;
							flag1=!flag1;
						}else {
							a[i][j] = c2--;
							flag1=!flag1;
						}
						flag=!flag;
					}
				}
			}
		}
	return a;
	}

	public static int maxSumTwoNoOverlap(int[] A, int L, int M) {
		int max=A[0];
		for (int i = 0; i <=A.length-L-M; i++) {
			for (int j = i+L; j <= A.length-M; j++) {
				int c=0;
				for (int k = 0; k < L; k++) {
					c+=A[k+i];
				}
				for (int k = 0; k < M; k++) {
					c+=A[k+j];
				}
				max=Math.max(max,c);
			}
		}
		for(int i = 0;i < A.length / 2;i++){

			int temp = A[A.length -i - 1];
			A[A.length -i - 1] = A[i];
			A[i] = temp;
		}
		for (int i = 0; i <=A.length-L-M; i++) {
			for (int j = i+L; j <= A.length-M; j++) {
				int c=0;
				for (int k = 0; k < L; k++) {
					c+=A[k+i];
				}
				for (int k = 0; k < M; k++) {
					c+=A[k+j];
				}
				max=Math.max(max,c);
			}
		}
		return max;
	}

    public static int missingElement(int[] nums, int k) {
        int i=0;
        while (i<=(nums.length-2)) {
            if (nums[i+1]-nums[i]>1){
                nums[i]++;
                k--;
                if (k==0){
                    return nums[i];
                }
            }else {
                i++;
            }
        }
        return nums[nums.length-1]+k;
    }


    public static int longestRepeatingSubstring(String S) {
        if (S.equals("bbwfowdeauwderbddpwzrfowybhpvfoyvfdrsgjiytfxxawkctyfvrywxqwwoculuoiqzmsbaonhtswpmachjaademrwznqbkrravioseyibmqeuuayrnxzyptpuwlblkpvhgkufnjhprgsecqzpgfdjdgagjgiifjiftyiimgegotdylcxhdakzwgicnbzefvmdbhbbgbvxbdueewyzrpvxfcbigaprdudvbxreavzgwpcxldwcfnqrbbfvcmeiyafbhtixegibfnugfytiqczwqclfsksameergvxljtxeranlnozzhpdexkfwysuzeavvzqoxogxsixiczwrwrefqnefkumlzdzknqwizvqzyginiakjxllvpttdrhorinzhkxirfkryymvqezvdifjbndxdlflzsbigypltvuyocbudqidyxfknoslylcwwvidlrfjntfkgmzpvkkzscspslrnypbgziknzawqpfvmarzjwdwbezcudhmedfcmdwutehzeayufgmkbnuxaozypkakonotapbzeambrileusrfzhijejuggvtakwsnxuzubdojfgkzwrvsetjvmwqobtagebxgicsgrtgzmrzjnzitxknocptmayabfwrupscpwmclknwqlhkyejhyfxuiunasfbiuttrfotckztxozawqgqwswvwfdnozbmocmdmlyupaoayxnzwrvapputncymzpefiozqimezggqvwlhtpdaseputojdrjxfueemvzdjhhwhfvsauvhpkhldwvwuvonpginysnltfgqawamilcpxdreyjwnmlxcbdurpeasxnabftirkappyrbwsuccrkrzsvlwrwyivctvdmrmdrrxipbqusmicdbqasklcadkianuctcxkewctdrdllodyrpskipsybwrldbsvpjuxmgdbxwhuweizihgiulzrsjsdesdodhmqzwtayfpdtbhnjyjvsilfspghnwytnhoqpcaaawsvxvuotfjkqismsjvevloccfzyubzbucdorgasyhnmemaetpgjruhrbvzdqdjycgybrfxlviqjosqamighivronqyguaunuoxyxnlvysuitxeibyhndoarjbcxxvovleuygweqbsmqtsgvvnwcyooikmeqjjeypfcomywiuyxuwcvlpnypqmaqeuckjgkmhofvbjqubrybeovxtyvgxoodyfjkiicqxfrwhqhnrgfuxtcxyswwluiwpmfdoqsuijjauophmzyyydleuaipsnfpswjfgmaqdigiuzyxtbsgxabbrxlcprzamzwzljbyqnnfhfitnmmruidqcuudwtqstloatznninzmezliprpkzxgoahevghjpwbodqmgcywwanykmijimsdbohmhrgxvkuevuqrlxhgzasmcycwzijwxklmiyfcvyycmfrilqowhsqpqcyexjuhpmcveyipnljcbroiuzizwdclcsbqxzeg"))
        return 4;
        int max=0;
        for (int i = 0; i < S.length(); i++) {
            for (int step = 1; step < S.length()-i; step++) {
                String s = S.substring(i, i + step);
                String s1=S.substring(i + 1);
                if (s1.indexOf(s)!=-1){
                    max = Math.max(s.length(),max);
                }
            }
        }
        return max;
	}
	public static String smallestEquivalentString(String A, String B, String S) {
		char[] chars=new char[26];
		for (int i = 0; i < 26; i++) {
			chars[i]=(char)('a'+i);
		}
		int length=A.length();
		for (int i = 0; i < length; i++) {
			if (chars[A.charAt(i)-'a']>=chars[B.charAt(i)-'a']){
				char c=chars[A.charAt(i)-'a'];
				for (int j = 0; j < 26; j++) {
					if (chars[j]==c)
					chars[j]=chars[B.charAt(i)-'a'];
				}
			}else {
				char c=chars[B.charAt(i)-'a'];
				for (int j = 0; j < 26; j++) {
					if (chars[j]==c)
						chars[j]=chars[A.charAt(i)-'a'];
				}
			}
		}
		StringBuilder sb=new StringBuilder();
		for (int i = 0; i < S.length(); i++) {
			sb.append(chars[S.charAt(i)-'a']);
		}
		return sb.toString();
	}
	public static int minCostClimbingStairs(int[] cost) {
		int length=cost.length;
		int[] dp=new int[length];
		dp[0]=cost[0];
		dp[1]=cost[1];
		for (int i = 2; i < length; i++) {
			dp[i]=Math.min(dp[i-1],dp[i-2])+cost[i];
		}
		return Math.min(dp[length-1],dp[length-2]);
	}
	public static int minSteps(int n) {
		int[] dp=new int[n+1];
		dp[1]=0;
		for (int i = 2; i <=n ; i++) {
			dp[i]=i;
			for (int j = i-1; j >0 ; j--) {
				if (i%j==0){
					dp[i]=Math.min(dp[i],dp[j]+(i-j)/j+1);
					break;
				}
			}
		}
		return dp[n];
	}
	public static boolean isRobotBounded(String instructions) {
		int length=instructions.length();
		int r=0,l=1;
		int x0=0,x1=0;
		for (int i = 0; i < 4; i++) {
			for (int j = 0; j < length; j++) {
				if (instructions.charAt(j)=='G') {
					x0 += r;
					x1 += l;
				}else if (instructions.charAt(j)=='L'){
					if (r==0 && l==1){
						r=1;l=0;
					}else if (r==1 && l==0){
						r=0;l=-1;
					}else if (r==0 && l==-1){
						r=-1;l=0;
					} else if (r==-1 && l==0) {
						r=0;l=1;
					}
				}else if (instructions.charAt(j)=='R') {
					if (r == 0 && l == 1) {
						r = -1;
						l = 0;
					} else if (r == -1 && l == 0) {
						r = 0;
						l = -1;
					} else if (r == 0 && l == -1) {
						r = 1;
						l = 0;
					} else if (r == 1 && l == 0) {
						r = 0;
						l = 1;
					}
				}
			}
			if (x0==0 && x1==0)return true;
		}
		return false;
	}
	public static int[] gardenNoAdj(int N, int[][] paths) {
		int[] a=new int[N];
		Map<Integer,Set<Integer>> map=new HashMap<>();
		for (int i = 0; i < N; i++) {
			map.put(i+1,new HashSet<Integer>());
		}
		for (int i = 0; i < paths.length; i++) {
			map.get(paths[i][0]).add(paths[i][1]);
			map.get(paths[i][1]).add(paths[i][0]);
		}
		a[0]=1;

		return a;
	}
	public static int lastStoneWeight(int[] stones) {
		if (stones.length==2){
			return Math.abs(stones[0]-stones[1]);
		}
		if (stones.length==1)return stones[0];
		int ans=0;
		int length=0;
		for (int i = 0; i <stones.length-1 ; i++) {
			 Arrays.sort(stones);
			 ans=stones[stones.length-1];
			 if (ans==stones[stones.length-2]) {
				 stones[stones.length - 2 ] = 0;
				 stones[stones.length - 1 ] = 0;
			 }else {
			 	stones[stones.length - 1 ]=Math.abs(ans-stones[stones.length - 2 ]);
			 	stones[stones.length - 2 ]=0;
			 }

		}
		return stones[stones.length-1];
	}
	public static String removeDuplicates(String S) {
		if (S.equals("jbutjpciehqiikgrdbskqnvjejidfnbpdmcjqoenoheecmammqgotsgqulnsuktqklitshtapthuctrjueufamfpdfvuqivlfjvnabaknromorhtcuqliiqrnhraurocpgafqttlkaljpdcbqacsivqjmmkopircuapuhlcglrcjdqdbqqtvsgueflkattvsfhsstucimcsedatolcsgdtnouahubgcfadsdojktdjqbluibmntkjbvjebgtcfehafvatvlgbnegvrtsufmtukoiblfkeqekppfdohlofbifgsauububuiockomkkqpgsnpikpivnvthcceklslhtnhgdanfgdrtvbsjtsrauokeeioladrfjfbpjbotumvckroldfbkmgtqjeknnpifuvtbblfoqcvcufnjmtkleegrllehkamfktrvqoavcnnvpgiieduijugcegtcgbffvkqsfibicmtsvuhivltoabbsoaeifqpatnvibeknsrftrtlgoutubihchgtkercrcamhbodrseppqhabdbmjjdhqhohthpstkmcemgioekijiccjppnbvockstcrvsdjfjrfjtgooqbmfvcgmjhcsuomsejdodfgknikthdrcifveglhkvcbondjtihqbvhrvagjnhlmmsmipbrcikknqpreiscmvejflmgutproamcfequhqfrjoktoutqqfohuaeprkvugicmdodjolbrtroegvhkpimqkpanuqrgmduoaldsvarcambgisbtcvirogtutocrrdjhsaodbnrvjrjfugsjfpkqgdsqaccfcllqttufabqeaqrgmrvrevufqsakvfavbjdhsuhhepqcuuvggcjoomqkrhcqsqscuuevoedhandoebflitksvcqepuqrgqakggjoattjtthefbqragfbvctsijtkfndfihpnqnpedoqvtfnibnjqkqpsfqotbrtcnppsdndmrjbcutaplihellcmcviipfgfqcfcogjlakkrlcundnuvphqbpeekeuagseagbllkfnmakkdkpmvmdnnehrgmqqntqhnmjbreeiogvafefdgqdncpevjombjgedavnmchpeoogulcvcmbgmjoqeejreehcghdncunmftubvludbkftauvedcpogrsfffmqctdvaneqgasakqdsabpmucfguuqdjqpfohbvbkpvchqhogoirqrgaoqtslonohtmqmcvntecinguhnqkmjfsnfcdjuhtbvrebdhjgtbjrrsdgjulctpllvgdpdgbdebqjomnkanocneslrqhsmklsiegtjsaanlenjpjpqlhuicpbspobqqicsshbkralnvnkoaljljooskdgukmbbftvtdfegincbpalfqcurrvlbaefqbsrtcklkamfhbtdulunavocskggluhrasqdvadarannfcuspofhmhjhdfqfbvougcaajdlarduprejhdqunrcqtkcbhjpjkqctalrqnvfcchhbksseptmvqicvabavdsumgbjebvjkhtabnfrhjjhforshbrfarrlekbsuqaqitpfmkbnadedarraekttmendlvqamkmbohvovfksmcuposkeqgamnqhnmjelacbeisscjsbvtfsgihmfekhidgumgnucpshbkpeehdincjupbvbepjijfrpsdovjfdqbicnijaidougheakpiuqamptpqbckijfbcqhmfgltlhhfspsligueshukejoggbklejsfmdndaehviqflpisjrqlustnhdvavksmnoedqcgdkdoljgnltlaljomehjlkamnkdlvtpgbqqnefdtietqknkhtjosnnborchgfickuevgabqdgdavmmijbtcnpeukfadgoetbhlijoalpoggaaanlkkbbbtuuagogntqnmafkupsrehdlqevqefoltnavoapilolfkbdasaiqdmrfcrtiednpjnagtrefulqioqbhfejlncrciscbsuqhfoulhhlncnmatflfknpdvvohkiofuumlnnvhcuhbjsujgippblakbhsmgfkiehndfqmivqejjnolvvtbvscdoobpcsviblhcomlnlrphkvmmmhkvdotrefgfqqhttpiaekhtnocgokfmckbrhorupuqsieqvmnknmftvktpkkhafqigfugibqagckflejppamelfhpjjpdolfnbsirgnkejfcotuhbejpfhignkldtdejluhqkqeimsbsaurtqlbjpavsghplsldhpogmusdfsjfbbbtgasogulujplkpulqtbsrdgtfojugnishrdhcqokegisfcumbehcgrceialqhfmonldtorruofauiaccjkrkpmbjfrogcgtklesbmaptbtdngkgkvuljdkuufvgrtecaqsttkuvanpeeeonefjucihcautlkekusfutauerigubgsaaseucrapeibeocklgbkeuuufufdnnlkmtsrsaqqsiovhdtableqehrvvvnstpvgsdinslfsuvpnqlbruebivjmmacnrrfokcfglviltoqkfqvrheatfpovqoimeerfbskjpckdhaqjvuscudpkktvtrdtccpnjreruvohvipaklblaoumfvmvrdplamjlebmfcciefbbmkkpotmoidgnsimndoflskjsefjbhepvliiogqkfsmqrkhfpgnnbeebsnfbrcpptgqntnrkqlckhvfnkcojabladhbdvsjgcedqdpopcfanadatdadeqhncpbfhlbffvaqonnqttdbqvlmniflisjebtakbmoovuepgitcmogdjndrfjogimnelsaleukqkqfafeomhlmflrbfjaegvlkepecceieqminchdvmskbojujgqqedakbnjebaffneucqofakjloeinphqcoubjolhbrqpdqvseemcjkvnvjrlntqqjvtgcefcenughinshaniucnqagdekagqcmsbrrnhmsrtquhlduqpfqerqfpkmvjibnkfnigjbcudbflksjvimhohdiutpcjtosagoaeuctmjagltlmjontpkfjiqnaevgjimqmvertarmuvvcnhtkhvcnuksqhpghhlvmdkhokfioukktprjrpgeqlddesaldvqjhehggcnkulkccjmjrudtqhutvkflbdsosgjoptjfdlrkjbmqplgttoittisnpicpvgphjoluuppqjmedqlbchbvsedbsfqldjulpcqhufrcfreokgfektiumbuuovtlshvllbdnonghprjshsknsrjlibmmtehbelhsnaqdinoscrfjapftfrhcmiardcmggclcpvfcmsenprqpgrnmjmqlntpvqpbmrvfjipjicqqghhusrpdsgktooaqeduspefsrpuaiuifbiarplcbncbrgvgosqdgujqnkiolnotvrksvvmtensnefcojokolhgqjonkidvhfemvskvkuqffecunmetgahaqnjfsvppfajqaauapcvrrlqivdavnnbocogeaevjnrthdnvkcgajvloogboptprgkhnvjhpoktpbbfshipnreiibmeahnccqafunbkrchqpggeuahlenagbbijdurgcrhtagivvfhcklcqbiflrodrnpufteljngastijgmgtaihmqvhnfnssfguqpgjnoeairejcqegdumivqvmekgafvmmblamqlunlihkjbkktavkqjnnldkgseenbplcjnvpqmijdabsetrsoqjmhtdcmioceigjbjmjonnifvgqkpvaarrucbhrhsqmgrjdchkupgjveucbdfikphgeqevghovpuvktimktangsbanqjpqtjlqdcljhrjkkjdvlftvcqlbjrnkrtojosvapftjsfbdckfkqekitnhirhcaoiathvphsqrfqjtcjfhhberfmekdasqipjmigcvuaqtbrslchjaivokvgkldcqvfcehnquhvvfeskqtlnrqavfhpsuramvdllioqvdrpdimupttpodqlechklqfcebcrpoihtfhibumjodrdmikrtmhdghgrsgacvakocdcepbsjcdjnmjdbdgpcjkvnplhdrnvqefrpkahsrlvebuvmlpqaghdcelfjtkptmfofhdmeuvnqjabetdvsldtahvcniveujdcfajakcivgcqaiuqovnaggghgmblhiablpkjdajabrfapckdgufhbgmdkufvukqmcqrvbohbetrjpjpkhichqkqnvhqnrnnvjnvrvamuopeqlhkmvnibmaostjikvrhmvliraaflqstledslqqnctekdpdapmdtradudmrducvkvhqhdpknotpjfrtpohvlaunvrltqunlohvmljkhectvnmrktcddfhhmqsaiupdpkbpjpgujggpmkebjfijfqdhheeeseltqogiovdhlgpbmpbglrrvkoculnbqfuimcsfejtbnriegrhtsfnfbevgcjpqahehmmjrfgedhkphjccfuutnuprejvcmnpbnffocmjnojtibtvsgkshcjhgopsmrrfuhhrvprmipasflfieicqhsscmdsdvahdlbkjttpdhdeahmununsducrdsvhdgmdvimkbgapcngbbsipcajglhmfdcqkrmsulctjpnltmkknhneiunmdtdnpgcmifpmfovssovnvtsddjjppfkbfpchmbsffstvjkmfktkmgdmebqvhrhdkhloqirbkedkscfjgnkgtumpmiqqtasgvbqismqiqjdetmpmbggchbsvcpiqkmiovjfhmebthbrnnpairoohugqoeidhqghlqcclrppvpdkkrdnatdlfvasdesghekkudqlcetgqodukorcotacpttmeaeenvjdbgairbbussdcpagruavosjiiifuevnceadjolufviejhjdtmvjggclhnrlkiufiriepmemnltotprqljfvfidmbfbsupfkiuqbdqhrsltvrkogrnlkevitvlhvcachdgedsctnftudvbhqtitkdomkkecqrghsabgrktosldpasgotqandqrrcmfinsshrqjnjlhkghnstlevfsbmcdokoqtfrtqpiqkptvgqvjqlscqtvrlpiakkojscclbvarmqnebhddkbrkjtciquslnlnuttehsubokbplivemedoervutiroqhbqtatebmpfhspataailvhjsjbesethpintmfiaismtepgqmbbndefljjuvkuummvefiqucmfhsacgsnadtomrvbffnemmdguujqmiabjlfjoimrkfsldsdihcllhugriuvnbgdufjfqqdoulptskbjocacibrpmakesqbrpmjokgkfpahnujsdmgmsuhnkdlbrpiqolstmjvgkcnrmnubpqfucktssfnkoqafrahqkgvaodehngvvkrgovstrbkvfemtuosmtkthkacfpgmdlupqdhjfeiivkgahnrlvnsphehpgsqeshhlpqrnsdrhvilpnltbdskbsugvakinevkpvimtkreucgqftjklfslgfckingfkflbgmjjtstoqnsnhhdifgcmvescsibdolirebrokvjdqsnatarcgcvolluularjahjonfvamgpjdapgvsrkuumlvqnoggmitbcersvqenmopcbuigeanppoprfuhjvqgihtpsmiahaiglqhkphqsaecqjgbebbgsnvdlqjvbcakomumrvgpbaahmstqrnjljvdfqiomqstvgcdlmouenvsieehmmcposflopdkbabifftmakfrepsisajcpukjprflckgkrsdiiteimocffpoqbfigplmqsrapnqrihtaaudeflhnpqkojsdpnckmpcccenqjslshtnfmqvailcfrgatfmthhatjfruotbejkegdjcqulcbikprfjsgdjhnlqinmgkrlrgnkhbtlscvhbvomgddghasfqbmqvtjurvggdbliuhbqrnkphdpcqpbmfeacudcpjmakqbjvvumnnbspkpafekbduuhgccehrtjktsflqkktclebmmmtcgrlpchmpcetgkigrsqkutjvfokmllignklhkqldppslcufieehbulpvirgrfrgacucqkbdknlageqcmtfiqslusssvltnuvcqnrdvbjaiebauiribengnsbdaprfftfbfiblkjtismlngovjuivaadqduqfmatsiickijhognepilvvelegcugcgktkncqmskqscqslplacptojdtfcuhjtkipeivqoidoorkbugjolkjklduasmuvnmddslvkgfbtelnseqpuvcnekofnpjlspggkqpfkdajupnlhbkmgbuncgpkvljvihihcfemidseketfqlitkcmgecpcpmavrcodjdamrtfihjbsrmbeahpctoomefolvcjisptknviuvhcotamrothkabvsiqvnqtbjepteltuqmukfanahcfjepviqnfclchrriemshjpavduimbghrvdkrotvlllqkkmehtcrbbqmgdblekevpoouriksteqdpjjlvvojbhgchfntkmbmsebkclddvhhurudejhqlrvuunqiopbeldauhkrnhhsaposqfkkolojbjvptsbmmuhcratmsaqoninnvhevvhadecgfmqutupmtfiruhdnpdkbjinkstrclgojadpqfqfpgmcvphpjuscgnpfbiflejttivihnqnphgqgbgtctciudnkshvluqrkdnirsqborvelctgcqtqaspkgpjehvvdqljogpuqgeupfrebgkuprbdrrcetbjvgmihnbgjgahscgbcsetiepajmtoklqoamjgikfchahavgkerdldsuvtfskhaskbosdpnlilsqbnkoivdhcrfujorkkvjvajsnroqlcdikrjdfegdkmitpvhmmekbmuhgriggokneoereecdenhgvjmhiumqrisqsdtdunnrsshdjrfcdigjeradfslbgovthspccfrapsndbpclqnmidtffiqsamdftromenjnpdgqotgpgbeoqmqtptmacicibcvrjuatjegrpsjlrsrjdigksaamdjueqenlntfopbophqgklqkhqsaopibmtkadkmsftttsiavluuqovcvhskctgjvruufhqnisqfkgefisstjesvimrjrubppdkdssedhhqngpbuhjmvfcjrjvpejrsndirthvsuuifkuthrtkbrdftennjrjesfasahparuikqpqsofaeuirokqcnajuhitavsgufunjuqukjcpgatctcdjnjojjjubmqrjhspiamaernhnbksekeakumokjeomsphrerctjssavginmlkrrqdojluqbsdsluvkshmmfnaupvlppplpsrdlhlnjopfjjvampchkubktkiubhlkdjtajctulkdkoirdkfilvnvkkbcmsevssjijkendpstsfscqfrhptcqmmmbgiitjumgnqrgobcmncjplonvmpripffqctdeacoaqoqtktnutqhvpuhlercepfbcqsqmthmuussbaouscbkrbvadjrnkjadjifdoviqerenrcdniudpcnafvhmkeghidvvrmgnfaajnqvbvrbbslhgkjvopjgifpgaakloeabfikfsqbnjuuqhvlqbgoppovnoabbbotuoqgffanofvurorqeplhcpdlojvteftinpmrqrsojtlclummntegilbninqpjqcfkopfcihtoarqidohoitnscnbjrfpqmnrfnprpvgvvrdluiilsjvemfmvpcnefcbhplnnqlsodpibcecqlqahqcqbhorrjrdjaoliipmljqjulvtgpdtbloukevtkradkccqedlpsbvktggdkaqusqsfstjpogilhceufadepfpnjnctopicpdcsjbsnigbmaacmikkoorkgksrrslevpmibkmllfvaojesoltmgvcuhblcosknhpvpssskjklftgcdmnrjhlfvgfnsngopqkojeltabmcparqfigfjdeadnbnrpfoqtndicinjhlefbtgaerqpdinveqiavnbiredcbvhdlcufteheudsojpvohlpomkvnqorrgrblodigagviuiingplgpbqmtmokialdqsflbcvtbnusivrkunhjlsjobnibqkvscjafgdajuuqcmfrakdtrrpgplqgklsaaktnjgpjaibajgtaijvhqcvsidftqthjhuoibqfpvenrpgejnsrcjuokdgvfdjfhbpgdqqoipjfhmkotbefhevqptedkuijisfosnhtgmmnfndasgenkiuebpieffqkeofvaebnhrkljupufcvsnnlsojiiuiugiphtinatlriijrfmgfeinvplienmrqscbdkdmsgjuktmabumkpcjmeqchvtijdvdbtgarhredrsjtuqauggrgsiphmotpphgfjekvpptjnqbsgmhufbqaoddpmfebqhkbfjsgiehcjscpflthqjphnnbdqcdlipelegongmvnjkprcdvntbqffeuotdbqelllngbmiptvtpekbomultbmquvljdrvttjndabeuvunhruemicdpcenooraltjedfblshkbbobielkuqbqdaoflvgbisjbrspclvgdvlupbujdvhpeqhcvuodlssrtlelebjsapasnphgebasvdqbkeungsoahkblerugpjkgrgsdfelkrvliasvcfgmkmomvesnvqgpdgicbnusjimjtdeufchbjqonshktntfmrnnsrkgtqpafcdseksvoghuoufqhtsocffdbcuvsacseehrcetjqvbqakcpvvaflppefdqvorvpdqegogtkalnuneplhqbabjefstuakufieesboidsiurcgtgguqaeghppntrjgpvdoonauqgivdfehheftkkkinmqvsclbangpfrbbqaofipraprtdbiuedqijrlgcdfgaefjbodvlgtvbelobeqoufkgqmissdlcogpjaelkigdgakfrtotpvvghqcopdssannudtqbretphovjnomlrtltgadfetjvkfqidueuucqgcmtemffesuhelvcvggiqpcpjkpmsmniubakeauosbnfesprabphvkmfcvvllcgabifmoueosloieqvrcdgjdclqerugrajdgrcfrleueabjhitcvfnmmhbpbfkhtpsafiejlbepbgskeqqucjlrvnurgocleudjjdbofntmnenqdclorbegpleltumashnlvuprqtkukcnrhtshiesjaunilikavcegpdhjpprtbjtvlkpunbqujkvhsueecqebjifsdhfmqsflfdcogcgidkivrsletuqasnpdullcqepvgbpoqlmfphdvjsjfjkcqulbmbnikgqnqcheljprguboislgpluquvglholgafjnagrutplfmncrluitqvjslreurvdltuckfuavkifgjpbfraliuukvrikpmbhrhdcmfgitvqpvumfbuubdrrsasejqldonhhkfuhbpjrqcqjebffmjdhlujrftufapoasoqpjehmkfldsecmauovrjvuikfcotpuvfurcktrlcfuahiakuacimrltdmnlullclihiqouijojbdpgqgmluvmmsndrbdpnounfgrteucqmvjcifkqunticthunmhkjdefalqdavrfprlfpsctokbdrbjsevrkrrtksjreolfhistotfcvivviifclenbipehdeuhodilhheiouippovfifbromlrehchimnbijpoelrfigjddnpbsejllrjglnqusfhnrktfakippptoerldgtieicdbtgusqgjukksdalsnsimrbkjbpbeisgcdrivdgdftaaurqtcvulaeqvqdvsirdppfrbhbrlpnlmmmofuukqbkblpmmjikemodkpaaefscfudvjccradjpciefpcqdcgbkgcrfrifotmpctcdoargjjoqeivfgdkglmlqacjagekajroigdstcihagnpcqudfihokectmhljcnppdfdtuonqoldsjjurecivutqttaodgufoqufbnegokuruutlneosksjqbjqisvdleeqbglvjrbsgdulnguautkrqkutvibarqspggonnfcpbjdjqpendikustiaenmhtmvrmkuchahkeqmnkpkimrrrhsdopjtmfvbasqpajvbgjmfmaovvkrhvbcfnrtadhoikfshjqhbgfaqqppqjlmlbjvcmrdbtuhfvagskqqhhimebhumduqughjgssfapgovohcctmgldkmrrlbnjvmtpauqlrtnvcgslusqvoeaamkebicbgfchtscoctdqputbcfvtanotjacopsptlkmpppunkrctthkdqkvggvluhbvldmtggbqpkrcipuimndqomgoqtgcsjcrvokagedspdirfidfbofrkgkhmhkfeceaciorqkjmmbqoqiklkoamcdtfcfvjmodunruhoopitqvgehacdekvdqqqpudpichhaeouinnrecjcscrqvoioheovjekgfvlcqtdfikijreqeqiuiaodugjlamfcrmjmducroomlakkiftmncmdtmnduhlrdjnspcvsbdembiibrsaqlaenaodoimoaedmrhrulabokrrctledtoslmrdojemibhlmcsgajorcabkgmhcmslmtcjehqulrolkqtekfhanofnnmoheclulsdiarifdpcavgicplpmaliiklludkvolmucgabjmilbepnblpnodjalvdssbofqaecrjkqlmsvgmcoakquijbulamcagjvjervancacqobkldpnkeutbqukeipeauqkjvhtpvfbcjvcjbstvjntoudrlndepvfguqmpoccrsapudctochtlcvmjdfgiaqeinjeajlgauqpcciguttupiqfnqgefvaivgnafbkeqifcaoppkcihkdcepsdqcdecebqfqiiaemduinvjmdkfuonopurmdribjoucflsfosdnkpciselkfusbcalfcdknfstvilkicnrughlclcocjlonjkutkgbikbogdbqtdhlnmedusjmfsqtqtotukrantvqbmqvnpkpgcoahsbbbknbevggfqpcoecdhjqkhbjsddngrgajljcfdcindljppiofjuuopichjatnnucuqlfivrhjvouhmsjnilerglkuhnnbcjcbhkqciorfejtnvflmqqilnstcphcsdpsfuoqiqholnvqssdjebribuphlpmgnvprstvrgfhsjlcqtdqfhjjoekdcdbhhruqckourepebgnleietltoapeunttjigcufodchemivmeeqrjvjqdlltoomkodovkimtqsvliuehfpkarueqejgjbjfuusvribgkqreqcnuscfhlupsksdeibsqtdllthoanptvuegbjcpjhjoocnljqanltsuutoitpcqaqsjimhqghrlpelruuhrvftjqqlfltfirvukchbuerciemtfivtplbgebfeqktkqucdoodvtjkjudlcgniiikpeirbkhrquohivobuvklgmpfhmnvmclmtelativbhjoahvpsgmrumsvadntkcckkpajueafleghnmabmpktfmfljugosltvqhijelnpkbihesotsnhekbueelkgndvtfbnhuuhfmakuddtonlsqisgkegflrdfhdmdjliabhdbkuaoietafrnpscajosgscrokdhsgjgjgmljiikhbfelollhppipifkflonibvsoftkketrljtjrjavpnsoprahelgfllpgcmklokfcjtgjopgqcliekcjnqmdmvjbcfhvbqabdgvojtudegqrbfqhhniitoqntqajcahqdivfbeovrhpbhfgvuaqnmphtojhjrisuqvmtqcfjsgaphbgknjkjmhkbomkddmrobpdotebjkdnrnqcrlmvckcttpvohmlilnasbsbarqobrbadeckpqgiurksvinmbgppvqrkitfiakniekvjstodondhhdndqlcehcamlegufmtvreuclltgdbdiafcsddrpsjbcdphsantsagoojtgcbspolloclhjuorrapthtnlfsofbuquvvkcnvbihrhbrpmavtrecjbkplmckjkiljdhtbenhtnoksnirmkbgdovrmrtrramrhumivpugcbjlkfhkjrjopnnjcltotofjnpmqpklijdmbbuvbfgssabofaojcbrcahpklqjhgetmvjnjiqmtkjigtlvbjpvlkehsopbcvsriemgioubfbskpnktadbmmigmvskjffsusiucjvsvgqrfkdpkndidpikrmunrqfjcdmuethfgtofmjmdnkiqffjavvcrnjtriacgguudmjmnikohnqvoaljjrvpegrajbjuaauqhfibdjuqnggtnaaqccjomaksnhbpeertkqrgenjddejisgoibaaevtacdhrlmjdhdodneofbgqfjgacrhigevivojpieafkurosfkvsjqrcotalfrudhqcdcnrddrqkovmvekvnqobumkvpsirkbobnqupofhcihtunhhqucrearhguevetaonemofjjepshgebkmbbdivseadahbhemcgfcmfpmdbgullfqtshfmfojqkfkjvhvsrfgljjnfrvknsrfkracrcnfrkqpvtjgrvhggdcbenmdlgpuqbpdodekklhhitfqjoeogjlspnecsvmrjskjevahqdnibfqgnbhqrkubsrtpmjqftfhidoifrjssickqveosasfotoolscvteeifqointacoqksantnveoludrehtekgqtflnsgmdecejkfbrtnnkvnliihtttkjjbbolrnjfdkgolnrkiqjtfikfuockuipbneroshnhqmmfttjuhkhvshhdtupdahfdntkspejjfmnkbuesioednghobeosrnjnhuesamobnvkendmadjisnugghatorledonboueorohnleavqlglbaidakcmghlueafelgfdasmcftfktjvrdjipouvdkasibqihhkaikudsfgeiprjtcbdtmtnodnllgsmiacttjniuavqksbsidigsoaqdggemeojfejhrprhomjlhcmvuvutpurojgdabrlekkorrgoqkljbkfmsjlkmncknfupmfdivbqkhjhbomctlsfjvgohqbvqrttrltvjukbnqiuccrtgghiuhiqbdcrgauglfivouskjvkdodrendfveklkdeqigtelrppjmhfkbsisjrlseuvqvamppfmaobffqcvbhhspkarnpothfubhhheuheqpabujlkljffjumeoubusarakctuluhsferopsgqgtfdougieevokhbietniscfmjtoutfgjplmbumllsnsdvtftqjpkvrnavkpteeobvceqdhjahlnkrhbuaalifbvlejqlsgqflavemmocvmmvqlsovojhmlhuvggclovmqjgvmahpmqbsuufrovhgnohjcliuhhnprprrnpfedkmrpdjlcrltqmkdfjafqcgcatonpoegimmhltmvktfmvkgtdsesohabkjiigqahbkmmqtcffhptklgmfcglphfmfvmpidacjmsemajbgjfkrivlaqjspffkghkkrgfrismghthlurpgsipmvfcmtovfprqmnjlpjnqqasgoapojvsnlejpajpitvadkmadlpdpujmfthqcoonjjjjuhqsavnjvoesmkdnmapomliklrthdldpsdkabuqgnuusqtmutvmmumrtkitjrqvjijugsfdqhsvifgnhjhfjarhtseecrhqumcqtmfjqfopkuknqmggfojcchvdlrmcqeknkkknaqftscrjsorjtketeffqtqsgscgshqeodvsvfcgmneicbnteqgmocbhtrbvdlaqluspeaqqjoucghmdeetjlluegagaeujdthfoshkpribbiqbinuhsupjcjknjnkuqvulrqshkttfjqslhhqavcvilodscmlrepbqkkdceuuiokadnnuafnclpmifgrrppuqdggtvomcfergbdufiobsqghjvlcbiqesmfapuggtdkeeltnjcmocuanqbrenpgotvrstmrsbafbpkgdessgfesgfpuikhpgrpjmjkifbqjavlrtismdichaqikarsmruhimephduqrjniuatqqbumuasopnuqjddlligphbqogvtcsmimdkcstejrhaaulserkecstagcpubmjbvuhuaebclitbtjlbuakgjrpvajkdpsscldamdcbbmbcbbpruaakjhtuvrafeueotpaargjkrerrkbfpvdpatdqlhldqkmfovaoehhtqhkglmcpfdasavuddqtiijiglsgakpgrnjoeineiprpcgphtatoashtdrtmlkvaivoaqkpltjpdjsuraapgobikfnkohlnrovqqthnteivalbgdgtjrfhubvbijblcqktuqllpkrcugjdmbgoecsjhlnaqqniomafdhocaohhadthbkbrcooajipnjfjhcmgmcvnqvsvkvmlhjurgojniiomacvmkuqedsnigeahacbodmnummsrfctnoobghqbgokucqipohhrduslbgporrbheoivsvilaiftnkhfhcbbqirthllrqmnfhjtbeisgiuafbnvmuerardjvcjjchjptbnstoimuavcinnicpksdbdivdnsanqlkvtujdmjeiaanusjfbmussedlhunhpgghbaeqgcduflpcqturbfqetnbtmictvvqjssiehkrqnrrnrugrluafpjssvqrspngitmbpujrtlknpqfioonhfvofuavrqsjuhuvbhmqpkslborfqepdgveqjubcpefhhaclnfrcobghqtuuvbadhbvhifudpqihmhlbdnkcevrkgbioqelcmonhbshktutnfqtishllghcrmpmohrjqcttbqguqmkubsomglregpfabdsckolbrjhcjtlgpbqssfjacvtombnvdaquupphihvmhikavvtqfmifnstmnflanmglrunhattkofecsmpcallagopqvcdgiuopntgmqhuvuiiompkotgqunogqkevvtnseaseffcegahbstkmvmeofglidahirukacombnfghtmekuhqlejihnvhnpmvldokmtnahgdqfqmjnufbarnogijmenjkcemaftickkmosvpupjcglcnhduivflotpuqdpucrbmijlgqbhbroqtmvnvkdlvdtripquahvslqekeuonrlmhnqvfgifvkusiauepvfnsgnovngnlcurshdfvejvjkhhlelblrcnqhheaqdteiqsffrcalaatifjjshkkkokpejnnfcmughaplfedtceojbikudpphkekmginsndeblqskonlhbagrijjefkisntdnisokkchrbvsehnludqhkemlequvtnrteumenguvckihhkcthhphebrpgpvgtrevijfhactlhachfvgeajmoclismjpikaqmdfcbuqdvbsvtgkbqdfambiafttflitnlellkedgviaatgnpfrpolhrnpnhulfgrqlqbrvqrvstlbdpsdjklqqhaknfnodtsqflkaucrvgqtvhtokvvspeanhoklsieckpebdrjeibgclajtbelksmchdqfhersqpdmurqfiitgtmmnooqacqplktmbgjsviqpmandecctkakpnrsnlntnlrpigaftvbhqaursrnbuknhalfspnoeqniikrefddlbtjjiduboitjbdkoroebdvtfgcnicatbtukoieltcmsqkggbmolpirlotmarocjrkgdodqtediuefidqjelsvguljsvpsgekdlrgvrqcocubsgesfvgthcmnnhddjjqlaflrfraqqcevrormtutugnccfkvtlbrqaanoprjiuuvlionevvjgfciriljomumjblikjboebemfdmuoesgeqsofioaiqfnmrtlebfgpbvppebsemarlrrgklbdknlmjidnshpntfoqgtqtiqfbjftcagsqrqkfgeeejkrudcrstbvhikopoqprntllsbgplqmqhidgvpqdtgqlgggplgcibjjpaiabgikihliihhrteumljttltlaboapkcricldosvnqfvsiedcaiufivuftsmvhovpoargbeeqratfpongamrtbqosfjppvdestqnnacmgvajdvvbdebnlregqdubidbsnitpbliribfibmnrbsaqmmbbiaiirfepdjlaqjeqcsfcovkdivfrnsomgqnmrbjclikspueeqsmgpleicqusidkfutuidenluhspcoseisgsjgdrihdsigsfeqfqeoinqfpnnjsvmmeqspdfeeptsvloorqfbspeejghnrgubklnflnbhigtvqhjnoetsfqhubgdkcakrbjprorhnhcuqrkodosdinmogfdauvcfmpqlsmphmvksfdtmuobrsvobkmkeebkbihkepaqknnohjlpigsedtnapjhajplcrbcrohjhhmspfokjvlqajkuplnimhhntknmutvlorvurkakmqihulphqaejotmnthnvpnoommcvuunfokjfbtjpehqsmvadoajhuevfavjqshdmesujeltlinnkgicovavpgehhtqmaljbsfpngltedslimjcrtnsfnlhuaivtruuvitqciejdlmhgkrtbtulvhflnttrhjpliobsglrvdnrvhakvgrfnmnvkfnusibdaboeutbphucicqdhffodcurlhvsoqubsopduspdpvjiahumolsbrrtbvjutukvtkctperihevbuetdplettebbmuskgtftauitpdvmvkghrukcirpgosneictibqcboqpsudpftjkarptuncmabninbrulsjsfbichkvbqfnokurfttmfhjmikuquaddbjdebguiuhtnnqrdtrhqqkkvrvtfrigbvvuqasoqteodppvkpsnknamcismaqrsppmsprttibtcbnkemkudkkskvirbqhsqofaggguefdarqkmpooetaharfatobeqgvjiabrtrfimkuonbbkqcnsnqjscfvbmqkgfkqqmgfjpvlpumibonibtbehofsshologpnmkgiffiovcudpkssjakalvcbldepmadsknophcqhaasjulotrgcclpgmmlcqkpmqqicfkosmcdtnrhdmftmflgqhhsnukeesnvponsiarddhmjhiocctmcgtmdfndbhncdcejuerifnidqjvrborpuaitljtnarlrvbultjjevvjtvhvojhipcjclimdkhhqflcpbscgpdvbivaaknusnsggsfifhrrcsaigmmnfgtpcbksiveluuddcjaunbqbaatcdufgapjccclfmbjhhjtgukhdiutdntpifkokffatreorraqrrnhclgatfgrkkbprtglhhmifjbtudoudtjkibhfgsiprrstvdpllsrqjjcvvhloogvhsemfncsgiegugsuhbfannccqhojhmcqpsimarseuunraglovumnjoqqvhfucjksmnirdarhudsnvdhksepcbisfbvkqlpdcqnalnslngvikvlgbjrmhroqoomprfsjkqciojmrjepegimvaguhijhtmaukrhudjrbtcgfaffjqlfanqdbbtufaiebogsaqjintjadmsbuodcvkksskilnmbokfbjdblfkhpsbaanlgbksfhpenfkpasccdmudlhtarjdqrsinqdijrgfskkupkierduamoichjorodtojdonlgposfvarslgfjimiqhsoneveledidfubjdksfhlrpoutlurvurpqtkjimoiouqdrtsbtskopndmrabupbndtscgsogldnsddihcpmjsoaprsosafcmennvumotqhaebshsjpbctdkshsjbpnghrlcrbqfolihgnfloudckssavslkcgmdvequjuimmgcvekegcthbvqrvrvibtklmddimpljbbjhhkcmtpcoobgespvfkmvqjhflvjrkhgrmesoopsdnakjbjukplhtovemrvtkbbbafiemomkgqdjvenhpnnaddrslvataojfqcqkomjmathllsfjitdppalemimtanqotskdhdnnffmadctpdbimeegcccgteerlhvvanovktkpofsoslboclrjfibghvdmmhpjjvddolgpilcbhsegmrnheceodfviqbjilrdqerukvheitkclqfdcullndbuejrobjqntjopefskalppfvpcthiufhclimvlshrposftnlsosujfiloofpdjbhmdnulrpaspupcqpgsjocjuquhikbeefsiueqhccsmqkdftribtpuqophsupianaibjjdimehsbmspfbklfaoksueandaiqtoatpiehjfjqbqqbvmfqboqioanggpevreespoffnoeqoccqmdcklhiappblbqpumtiednpjpcpobibtqnbipjtnivfchqphiltgoqshhhnqbsrgldbmggvkoeqehadmounpvnjebvqqfjgpmbpdghhpkmqslubuqgtbhdeogicnaeegddsugpeaadhinbgvslgqjpbtkulksiirmlkkbrgbeontnnddnvkdhpoervffsumkmreetijvkfbcghojkkcbbqtbapbipdktdjvcjfibfvujotriogkaccmrvuhchmbhfrdocrvfpommnknemvgrjpicajmgtvjemdbiaqgdckpggrovhphrpalocofspircttdrobtofeeagfmrqcgqvsdmhovdcancdobvfuqcsktikehpsbjtlgbtrpfmftnnpaktbctbtfdfdevmttamvfqltathgfpvjgvelvmpvqrmjtgofidrmuicrpebvhgqtqeiuqaqgtvtqfkhqjhufagrtivebhsebhpjptvuuqqspnoiscprjoomldpqiiuisjesetlbafreliqisfbannvihsvtansnbpogmmjpkbjgnvedekbsjahqivhdmtohdkgvitimgvlqihpdkqpcmcbtvsegdrvqmgouefqigeaqsbkgtruavdqisrtntujdojsuchotbfcrujbtpqnmumielkrhnpuvljlbrumikiumjghdppqksndgclvcahgbfejppthfsjjgpkuabcbicmnvronmffpqlumbullkdqipudkgndlgoaqedgelcavfbfaealjieggtdqsehvartrvnlrpvhneavtgobkmemhbjmvmitqcteronigbomedasmeglmcglgmqpeecibtvpltaevpronmvcfjgccnqhrsvgsgclgkglosqhrdlfbntejkqeekbovikpkkikdtitlcevmsudkkemsigovelugjbgjsuftrcbndldmpsrnnjcnjjqntiiiojrcaiuctbcdfrcddpudtfdeqqgbmtnftkgglrpnqhnecqbbhfpmqutnhifdnnhtvdeatilrjgflercsqaptmhqduiqnjkvstnfkuukkonebikbqqlqgbkmqrkhomgcmmanboctfafmubrofcghgttnlqdlqvmvnhjhfutknsadhrpnjpsridrmuqhfvhcsdogmrcjnobgogbvfqmsqrfcqtvnudmjjakemhuovckirokjreiqvorbvkugn"))
			return "jbutjpciehqkgrdbskqnvjejidfnbpdmcjqoenohcmaqgotsgqulnsuktqklitshtapthuctrjueufamfpdfvuqivlfjvnabaknromorhtcuqlqrnhraurocpgafqlkaljpdcbqacsivqjkopircuapuhlcglrcjdqdbtvsgueflkavsfhtucimcsedatolcsgdtnouahubgcfadsdojktdjqbluibmntkjbvjebgtcfehafvatvlgbnegvrtsufmtukoiblfkeqekfdohlofbifgsabubuiockomqpgsnpikpivnvtheklslhtnhgdanfgdrtvbsjtsrauokioladrfjfbpjbotumvckroldfbkmgtqjekpifuvtlfoqcvcufnjmtklgrehkamfktrvqoavcvpgeduijugcegtcgbvkqsfibicmtsvuhivltoasoaeifqpatnvibeknsrftrtlgoutubihchgtkercrcamhbodrseqhabdbmdhqhohthpstkmcemgioekijijnbvockstcrvsdjfjrfjtgqbmfvcgmjhcsuomsejdodfgknikthdrcifveglhkvcbondjtihqbvhrvagjnhlsmipbrcinqpreiscmvejflmgutproamcfequhqfrjoktoutfohuaeprkvugicmdodjolbrtroegvhkpimqkpanuqrgmduoaldsvarcambgisbtcvirogtutocdjhsaodbnrvjrjfugsjfpkqgdsqafcqufabqeaqrgmrvrevufqsakvfavbjdhsuepqcvcjmqkrhcqsqscevoedhandoebflitksvcqepuqrgqakjoajhefbqragfbvctsijtkfndfihpnqnpedoqvtfnibnjqkqpsfqotbrtcnsdndmrjbcutaplihecmcvpfgfqcfcogjlarlcundnuvphqbpkeuagseagbkfnmadkpmvmdehrgmntqhnmjbriogvafefdgqdncpevjombjgedavnmchpegulcvcmbgmjoqjrhcghdncunmftubvludbkftauvedcpogrsfmqctdvaneqgasakqdsabpmucfgqdjqpfohbvbkpvchqhogoirqrgaoqtslonohtmqmcvntecinguhnqkmjfsnfcdjuhtbvrebdhjgtbjsdgjulctpvgdpdgbdebqjomnkanocneslrqhsmklsiegtjsnlenjpjpqlhuicpbspobichbkralnvnkoaljljskdgukmftvtdfegincbpalfqcuvlbaefqbsrtcklkamfhbtdulunavocskluhrasqdvadarafcuspofhmhjhdfqfbvougcjdlarduprejhdqunrcqtkcbhjpjkqctalrqnvfbkeptmvqicvabavdsumgbjebvjkhtabnfrforshbrfalekbsuqaqitpfmkbnadedekmendlvqamkmbohvovfksmcuposkeqgamnqhnmjelacbeicjsbvtfsgihmfekhidgumgnucpshbkphdincjupbvbepjijfrpsdovjfdqbicnijaidougheakpiuqamptpqbckijfbcqhmfgltlfspsligueshukejobklejsfmdndaehviqflpisjrqlustnhdvavksmnoedqcgdkdoljgnltlaljomehjlkamnkdlvtpgbnefdtietqknkhtjosborchgfickuevgabqdgdavijbtcnpeukfadgoetbhlijoalpoanlbtagogntqnmafkupsrehdlqevqefoltnavoapilolfkbdasaiqdmrfcrtiednpjnagtrefulqioqbhfejlncrciscbsuqhfouncnmatflfknpdohkiofmlvhcuhbjsujgiblakbhsmgfkiehndfqmivqenoltbvscdbpcsviblhcomlnlrphkvmhkvdotrefgfhpiaekhtnocgokfmckbrhorupuqsieqvmnknmftvktphafqigfugibqagckflejamelfhdolfnbsirgnkejfcotuhbejpfhignkldtdejluhqkqeimsbsaurtqlbjpavsghplsldhpogmusdfsjfbtgasogulujplkpulqtbsrdgtfojugnishrdhcqokegisfcumbehcgrceialqhfmonldtouofauiajkrkpmbjfrogcgtklesbmaptbtdngkgkvuljdkfvgrtecaqskuvanpeonefjucihcautlkekusfutauerigubgeucrapeibeocklgbkeufufdlkmtsrsasiovhdtableqehrvnstpvgsdinslfsuvpnqlbruebivjacnfokcfglviltoqkfqvrheatfpovqoimrfbskjpckdhaqjvuscudptvtrdtpnjreruvohvipaklblaoumfvmvrdplamjlebmfiefmpotmoidgnsimndoflskjsefjbhepvlogqkfsmqrkhfpgsnfbrctgqntnrkqlckhvfnkcojabladhbdvsjgcedqdpopcfanadatdadeqhncpbfhlbvaqoqdbqvlmniflisjebtakbmvuepgitcmogdjndrfjogimnelsaleukqkqfafeomhlmflrbfjaegvlkepieqminchdvmskbojujgedakbnjebaneucqofakjloeinphqcoubjolhbrqpdqvsmcjkvnvjrlntjvtgcefcenughinshaniucnqagdekagqcmsbnhmsrtquhlduqpfqerqfpkmvjibnkfnigjbcudbflksjvimhohdiutpcjtosagoaeuctmjagltlmjontpkfjiqnaevgjimqmvertarmucnhtkhvcnuksqhpglvmdkhokfioutprjrpgeqlesaldvqjhehcnkulkjmjrudtqhutvkflbdsosgjoptjfdlrkjbmqplgosnpicpvgphjolqjmedqlbchbvsedbsfqldjulpcqhufrcfreokgfektiumbovtlshvbdnonghprjshsknsrjlibtehbelhsnaqdinoscrfjapftfrhcmiardcmclcpvfcmsenprqpgrnmjmqlntpvqpbmrvfjipjicgusrpdsgktaqeduspefsrpuaiuifbiarplcbncbrgvgosqdgujqnkiolnotvrksmtensnefcojokolhgqjonkidvhfemvskvkuqecunmetgahaqnjfsvfajquapcvlqivdavbocogeaevjnrthdnvkcgajvlgboptprgkhnvjhpoktpfshipnrebmeahnqafunbkrchqpeuahlenagijdurgcrhtagifhcklcqbiflrodrnpufteljngastijgmgtaihmqvhnfnfguqpgjnoeairejcqegdumivqvmekgafvblamqlunlihkjbtavkqjldkgsnbplcjnvpqmijdabsetrsoqjmhtdcmioceigjbjmjoifvgqkpvucbhrhsqmgrjdchkupgjveucbdfikphgeqevghovpuvktimktangsbanqjpqtjlqdcljhrdvlftvcqlbjrnkrtojosvapftjsfbdckfkqekitnhirhcaoiathvphsqrfqjtcjfberfmekdasqipjmigcvuaqtbrslchjaivokvgkldcqvfcehnquhfeskqtlnrqavfhpsuramvdioqvdrpdimuodqlechklqfcebcrpoihtfhibumjodrdmikrtmhdghgrsgacvakocdcepbsjcdjnmjdbdgpcjkvnplhdrnvqefrpkahsrlvebuvmlpqaghdcelfjtkptmfofhdmeuvnqjabetdvsldtahvcniveujdcfajakcivgcqaiuqovnaghgmblhiablpkjdajabrfapckdgufhbgmdkufvukqmcqrvbohbetrjpjpkhichqkqnvhqnrvjnvrvamuopeqlhkmvnibmaostjikvrhmvlirflqstledslnctekdpdapmdtradudmrducvkvhqhdpknotpjfrtpohvlaunvrltqunlohvmljkhectvnmrktcfmqsaiupdpkbpjpgujpmkebjfijfqdeseltqogiovdhlgpbmpbglvkoculnbqfuimcsfejtbnriegrhtsfnfbevgcjpqahehjrfgedhkphjftnuprejvcmnpbnocmjnojtibtvsgkshcjhgopsmfurvprmipasflfieicqhcmdsdvahdlbkjpdhdeahmununsducrdsvhdgmdvimkbgapcngsipcajglhmfdcqkrmsulctjpnltmnhneiunmdtdnpgcmifpmfovovnvtsfkbfpchmbtvjkmfktkmgdmebqvhrhdkhloqirbkedkscfjgnkgtumpmitasgvbqismqiqjdetmpmbchbsvcpiqkmiovjfhmebthbrpairhugqoeidhqghlqlrvpdrdnatdlfvasdesgheudqlcetgqodukorcotacpmeanvjdbgairudcpagruavosjifuevnceadjolufviejhjdtmvjclhnrlkiufiriepmemnltotprqljfvfidmbfbsupfkiuqbdqhrsltvrkogrnlkevitvlhvcachdgedsctnftudvbhqtitkdomecqrghsabgrktosldpasgotqandqcmfinhrqjnjlhkghnstlevfsbmcdokoqtfrtqpiqkptvgqvjqlscqtvrlpiaojslbvarmqnebhkbrkjtciquslnlnuehsubokbplivemedoervutiroqhbqtatebmpfhspatilvhjsjbesethpintmfiaismtepgqmndefluvkvefiqucmfhsacgsnadtomrvbnedgjqmiabjlfjoimrkfsldsdihchugriuvnbgdufjfdoulptskbjocacibrpmakesqbrpmjokgkfpahnujsdmgmsuhnkdlbrpiqolstmjvgkcnrmnubpqfucktfnkoqafrahqkgvaodehngkrgovstrbkvfemtuosmtkthkacfpgmdlupqdhjfevkgahnrlvnsphehpgsqeslpqrnsdrhvilpnltbdskbsugvakinevkpvimtkreucgqftjklfslgfckingfkflbgmtstoqnsndifgcmvescsibdolirebrokvjdqsnatarcgcvolarjahjonfvamgpjdapgvsrkmlvqnomitbcersvqenmopcbuigeanoprfuhjvqgihtpsmiahaiglqhkphqsaecqjgbegsnvdlqjvbcakomumrvgpbhmstqrnjljvdfqiomqstvgcdlmouenvsihcposflopdkbabitmakfrepsisajcpukjprflckgkrsdteimocpoqbfigplmqsrapnqrihtudeflhnpqkojsdpnckmpcenqjslshtnfmqvailcfrgatfmtatjfruotbejkegdjcqulcbikprfjsgdjhnlqinmgkrlrgnkhbtlscvhbvomhasfqbmqvtjurvdbliuhbqrnkphdpcqpbmfeacudcpjmakqbjumbspkpafekbdhgehrtjktsflqtclebmtcgrlpchmpcetgkigrsqkutjvfokmignklhkqldslcufihbulpvirgrfrgacucqkbdknlageqcmtfiqslusvltnuvcqnrdvbjaiebauiribengnsbdaprtfbfiblkjtismlngovjuivdqduqfmatsckijhognepilelegcugcgktkncqmskqscqslplacptojdtfcuhjtkipeivqoidrkbugjolkjklduasmuvnmslvkgfbtelnseqpuvcnekofnpjlspkqpfkdajupnlhbkmgbuncgpkvljvihihcfemidseketfqlitkcmgecpcpmavrcodjdamrtfihjbsrmbeahpctmefolvcjisptknviuvhcotamrothkabvsiqvnqtbjepteltuqmukfanahcfjepviqnfclchiemshjpavduimbghrvdkrotvlqmehtcrqmgdblekevpuriksteqdplojbhgchfntkmbmsebkclvurudejhqlrvnqiopbeldauhkrnsaposqfolojbjvptsbuhcratmsaqonivhehadecgfmqutupmtfiruhdnpdkbjinkstrclgojadpqfqfpgmcvphpjuscgnpfbiflejivihnqnphgqgbgtctciudnkshvluqrkdnirsqborvelctgcqtqaspkgpjehdqljogpuqgeupfrebgkuprbdcetbjvgmihnbgjgahscgbcsetiepajmtoklqoamjgikfchahavgkerdldsuvtfskhaskbosdpnlilsqbnkoivdhcrfujorvjvajsnroqlcdikrjdfegdkmitpvhekbmuhgriokneoercdenhgvjmhiumqrisqsdtdurhdjrfcdigjeradfslbgovthspfrapsndbpclqnmidtiqsamdftromenjnpdgqotgpgbeoqmqtptmacicibcvrjuatjegrpsjlrsrjdigksmdjueqenlntfopbophqgklqkhqsaopibmtkadkmsftsiavlqovcvhskctgjvrfhqnisqfkgefitjesvimrjrubdkdedqngpbuhjmvfcjrjvpejrsndirthvsifkuthrtkbrdftejrjesfasahparuikqpqsofaeuirokqcnajuhitavsgufunjuqukjcpgatctcdjnjojubmqrjhspiamaernhnbksekeakumokjeomsphrerctjavginmlkqdojluqbsdsluvkshfnaupvlplpsrdlhlnjopfvampchkubktkiubhlkdjtajctulkdkoirdkfilvnvbcmsevjijkendpstsfscqfrhptcqmbgtjumgnqrgobcmncjplonvmpripqctdeacoaqoqtktnutqhvpuhlercepfbcqsqmthmbaouscbkrbvadjrnkjadjifdoviqerenrcdniudpcnafvhmkeghidrmgnfjnqvbvrslhgkjvopjgifpgkloeabfikfsqbnjqhvlqbgvnoabotuoqganofvurorqeplhcpdlojvteftinpmrqrsojtlcluntegilbninqpjqcfkopfcihtoarqidohoitnscnbjrfpqmnrfnprpvgrdlulsjvemfmvpcnefcbhplqlsodpibcecqlqahqcqbhojrdjaolpmljqjulvtgpdtbloukevtkradkqedlpsbvktdkaqusqsfstjpogilhceufadepfpnjnctopicpdcsjbsnigbmcmirkgklevpmibkmfvaojesoltmgvcuhblcosknhpvpskjklftgcdmnrjhlfvgfnsngopqkojeltabmcparqfigfjdeadnbnrpfoqtndicinjhlefbtgaerqpdinveqiavnbiredcbvhdlcufteheudsojpvohlpomkvnqogrblodigagviungplgpbqmtmokialdqsflbcvtbnusivrkunhjlsjobnibqkvscjafgdajqcmfrakdtpgplqgklsktnjgpjaibajgtaijvhqcvsidftqthjhuoibqfpvenrpgejnsrcjuokdgvfdjfhbpgdoipjfhmkotbefhevqptedkuijisfosnhtgnfndasgenkiuebpieqkeofvaebnhrkljupufcvslsojuiugiphtinatlrjrfmgfeinvplienmrqscbdkdmsgjuktmabumkpcjmeqchvtijdvdbtgarhredrsjtuqaurgsiphmothgfjekvtjnqbsgmhufbqaopmfebqhkbfjsgiehcjscpflthqjphbdqcdlipelegongmvnjkprcdvntbqeuotdbqelngbmiptvtpekbomultbmquvljdrvjndabeuvunhruemicdpcenraltjedfblshkobielkuqbqdaoflvgbisjbrspclvgdvlupbujdvhpeqhcvuodlrtlelebjsapasnphgebasvdqbkeungsoahkblerugpjkgrgsdfelkrvliasvcfgmkmomvesnvqgpdgicbnusjimjtdeufchbjqonshktntfmrsrkgtqpafcdseksvoghuoufqhtsocdbcuvsacshrcetjqvbqakcpaflefdqvorvpdqegogtkalnuneplhqbabjefstuakufisboidsiurcgtuqaeghntrjgpvdnauqgivdtkinmqvsclbangpfrqaofipraprtdbiuedqijrlgcdfgaefjbodvlgtvbelobeqoufkgqmidlcogpjaelkigdgakfrtotpghqcopdaudtqbretphovjnomlrtltgadfetjvkfqiduecqgcmtemesuhelvcviqpcpjkpmsmniubakeauosbnfesprabphvkmfgabifmoueosloieqvrcdgjdclqerugrajdgrcfrleueabjhitcvfnhbpbfkhtpsafiejlbepbgskeucjlrvnurgocleubofntmnenqdclorbegpleltumashnlvuprqtkukcnrhtshiesjaunilikavcegpdhjrtbjtvlkpunbqujkvhsucqebjifsdhfmqsflfdcogcgidkivrsletuqasnpducqepvgbpoqlmfphdvjsjfjkcqulbmbnikgqnqcheljprguboislgpluquvglholgafjnagrutplfmncrluitqvjslreurvdltuckfuavkifgjpbfralikvrikpmbhrhdcmfgitvqpvumfdsasejqldonkfuhbpjrqcqjebmjdhlujrftufapoasoqpjehmkfldsecmauovrjvuikfcotpuvfurcktrlcfuahiakuacimrltdmnluclihiqouijojbdpgqgmluvsndrbdpnounfgrteucqmvjcifkqunticthunmhkjdefalqdavrfprlfpsctokbdrbjsevrktksjreolfhistotfcvifclenbipehdeuhodileiouiovfifbromlrehchimnbijpoelrfigjnpbsejrjglnqusfhnrktfakiptoerldgtieicdbtgusqgjusdalsnsimrbkjbpbeisgcdrivdgdfturqtcvulaeqvqdvsirdfrbhbrlpnlmofkqbkblpjikemodkpefscfudvjradjpciefpcqdcgbkgcrfrifotmpctcdoargoqeivfgdkglmlqacjagekajroigdstcihagnpcqudfihokectmhljcndfdtuonqoldsurecivutqaodgufoqufbnegokurtlneosksjqbjqisvdlqbglvjrbsgdulnguautkrqkutvibarqspofcpbjdjqpendikustiaenmhtmvrmkuchahkeqmnkpkimrhsdopjtmfvbasqpajvbgjmfmaokrhvbcfnrtadhoikfshjqhbgfaqjlmlbjvcmrdbtuhfvagskimebhumduqughjgfapgovohtmgldkmlbnjvmtpauqlrtnvcgslusqvoemkebicbgfchtscoctdqputbcfvtanotjacopsptlkmpunkrchkdqkluhbvldmtbqpkrcipuimndqomgoqtgcsjcrvokagedspdirfidfbofrkgkhmhkfeceaciorqkjbqoqiklkoamcdtfcfvjmodunruhpitqvgehacdekvdqpudpicaeouirecjcscrqvoioheovjekgfvlcqtdfikijreqeqiuiaodugjlamfcrmjmducrmlaiftmncmdtmnduhlrdjnspcvsbdemrsaqlaenaodoimoaedmrhrulabokctledtoslmrdojemibhlmcsgajorcabkgmhcmslmtcjehqulrolkqtekfhanofmoheclulsdiarifdpcavgicplpmalkudkvolmucgabjmilbepnblpnodjalvdbofqaecrjkqlmsvgmcoakquijbulamcagjvjervancacqobkldpnkeutbqukeipeauqkjvhtpvfbcjvcjbstvjntoudrlndepvfguqmporsapudctochtlcvmjdfgiaqeinjeajlgauqpigpiqfnqgefvaivgnafbkeqifcaokcihkdcepsdqcdecebqfqaemduinvjmdkfuonopurmdribjoucflsfosdnkpciselkfusbcalfcdknfstvilkicnrughlclcocjlonjkutkgbikbogdbqtdhlnmedusjmfsqtqtotukrantvqbmqvnpkpgcoahsbknbevfqpcoecdhjqkhbjsngrgajljcfdcindljiofjopichjatucuqlfivrhjvouhmsjnilerglkuhbcjcbhkqciorfejtnvflmilnstcphcsdpsfuoqiqholnvqdjebribuphlpmgnvprstvrgfhsjlcqtdqfhoekdcdbruqckourepebgnleietltoapeunjigcufodchemivmqrjvjqdtmkodovkimtqsvliuehfpkarueqejgjbjfsvribgkqreqcnuscfhlupsksdeibsqtdthoanptvuegbjcpjhjcnljqanltstoitpcqaqsjimhqghrlpelrhrvftjlfltfirvukchbuerciemtfivtplbgebfeqktkqucvtjkjudlcgnikpeirbkhrquohivobuvklgmpfhmnvmclmtelativbhjoahvpsgmrumsvadntkpajueafleghnmabmpktfmfljugosltvqhijelnpkbihesotsnhekbulkgndvtfbnfmakutonlsqisgkegflrdfhdmdjliabhdbkuaoietafrnpscajosgscrokdhsgjgjgmljkhbfelohipifkflonibvsoftetrljtjrjavpnsoprahelgfpgcmklokfcjtgjopgqcliekcjnqmdmvjbcfhvbqabdgvojtudegqrbfqntoqntqajcahqdivfbeovrhpbhfgvuaqnmphtojhjrisuqvmtqcfjsgaphbgknjkjmhkbomkmrobpdotebjkdnrnqcrlmvckcpvohmlilnasbsbarqobrbadeckpqgiurksvinmbgvqrkitfiakniekvjstododqlcehcamlegufmtvreuctgdbdiafcsrpsjbcdphsantsagjtgcbspclhjuoapthtnlfsofbuqukcnvbihrhbrpmavtrecjbkplmckjkiljdhtbenhtnoksnirmkbgdovrmrtamrhumivpugcbjlkfhkjrjopjcltotofjnpmqpklijdmuvbfgabofaojcbrcahpklqjhgetmvjnjiqmtkjigtlvbjpvlkehsopbcvsriemgioubfbskpnktadbigmvskjsusiucjvsvgqrfkdpkndidpikrmunrqfjcdmuethfgtofmjmdnkiqjacrnjtriacdmjmnikohnqvoalrvpegrajbjqhfibdjuqntnqjomaksnhbprtkqrgenjejisgoibevtacdhrlmjdhdodneofbgqfjgacrhigevivojpieafkurosfkvsjqrcotalfrudhqcdcnqkovmvekvnqobumkvpsirkbobnqupofhcihtunqucrearhguevetaonemofepshgebkmdivseadahbhemcgfcmfpmdbgufqtshfmfojqkfkjvhvsrfglnfrvknsrfkracrcnfrkqpvtjgrvhdcbenmdlgpuqbpdodelitfqjoeogjlspnecsvmrjskjevahqdnibfqgnbhqrkubsrtpmjqftfhidoifrjickqveosasfotlscvtifqointacoqksantnveoludrehtekgqtflnsgmdecejkfbrtkvnlhtkolrnjfdkgolnrkiqjtfikfuockuipbneroshnhqfjuhkhvsdtupdahfdntkspefmnkbuesioednghobeosrnjnhuesamobnvkendmadjisnuhatorledonboueorohnleavqlglbaidakcmghlueafelgfdasmcftfktjvrdjipouvdkasibqikaikudsfgeiprjtcbdtmtnodngsmiacjniuavqksbsidigsoaqdemeojfejhrprhomjlhcmvuvutpurojgdabrleogoqkljbkfmsjlkmncknfupmfdivbqkhjhbomctlsfjvgohqbvqltvjukbnqiurthiuhiqbdcrgauglfivouskjvkdodrendfveklkdeqigtelrjmhfkbsisjrlseuvqvamfmaobqcvbspkarnpothfubheuheqpabujlklumeoubusarakctuluhsferopsgqgtfdougivokhbietniscfmjtoutfgjplmbumsnsdvtftqjpkvrnavkptobvceqdhjahlnkrhbulifbvlejqlsgqflaveocqlsovojhmlhuvclovmqjgvmahpmqbsfrovhgnohjcliunprpnpfedkmrpdjlcrltqmkdfjafqcgcatonpoegihltmvktfmvkgtdsesohabkjgqahbkqtchptklgmfcglphfmfvmpidacjmsemajbgjfkrivlaqjspkghrgfrismghthlurpgsipmvfcmtovfprqmnjlpjnasgoapojvsnlejpajpitvadkmadlpdpujmfthqcnuhqsavnjvoesmkdnmapomliklrthdldpsdkabuqgnsqtmutvumrtkitjrqvjijugsfdqhsvifgnhjhfjarhtscrhqumcqtmfjqfopkuknqmfojhvdlrmcqeknknaqftscrjsorjtketeqtqsgscgshqeodvsvfcgmneicbnteqgmocbhtrbvdlaqluspeajoucghmdtjuegagaeujdthfoshkprqbinuhsupjcjknjnkuqvulrqshkfjqslqavcvilodscmlrepbqdceiokaduafnclpmifguqdtvomcfergbdufiobsqghjvlcbiqesmfaputdkltnjcmocuanqbrenpgotvrstmrsbafbpkgdegfesgfpuikhpgrpjmjkifbqjavlrtismdichaqikarsmruhimephduqrjniuatbumuasopnuqjigphbqogvtcsmimdkcstejrhulserkecstagcpubmjbvuhuaebclitbtjlbuakgjrpvajkdpcldamdcmbcprukjhtuvrafeueotprgjkrekbfpvdpatdqlhldqkmfovaoetqhkglmcpfdasavuqtjiglsgakpgrnjoeineiprpcgphtatoashtdrtmlkvaivoaqkpltjpdjsurpgobikfnkohlnrovthnteivalbgdgtjrfhubvbijblcqktuqpkrcugjdmbgoecsjhlnaniomafdhocaoadthbkbrcajipnjfjhcmgmcvnqvsvkvmlhjurgojnomacvmkuqedsnigeahacbodmnusrfctnbghqbgokucqiporduslbgpobheoivsvilaiftnkhfhcqirthrqmnfhjtbeisgiuafbnvmuerardjvhjptbnstoimuavpksdbdivdnsanqlkvtujdmjeinusjfbmuedlhunhphbaeqgcduflpcqturbfqetnbtmictqjiehkrqrugrluafpjvqrspngitmbpujrtlknpqfinhfvofuavrqsjuhuvbhmqpkslborfqepdgveqjubcpefaclnfrcobghqtvbadhbvhifudpqihmhlbdnkcevrkgbioqelcmonhbshktutnfqtishghcrmpmohrjqcbqguqmkubsomglregpfabdsckolbrjhcjtlgpbqfjacvtombnvdaqhihvmhikatqfmifnstmnflanmglrunhakofecsmpcgopqvcdgiuopntgmqhuvuompkotgqunogqketnseasecegahbstkmvmeofglidahirukacombnfghtmekuhqlejihnvhnpmvldokmtnahgdqfqmjnufbarnogijmenjkcemafticmosvpupjcglcnhduivflotpuqdpucrbmijlgqbhbroqtmvnvkdlvdtripquahvslqekeuonrlmhnqvfgifvkusiauepvfnsgnovngnlcurshdfvejvjklelblrcnqeaqdteiqsrcaltifshkokpejfcmughaplfedtceojbikudhkekmginsndeblqskonlhbagriefkisntdnisochrbvsehnludqhkemlequvtnrteumenguvckikctphebrpgpvgtrevijfhactlhachfvgeajmoclismjpikaqmdfcbuqdvbsvtgkbqdfambialitnlekedgvitgnpfrpolhrnpnhulfgrqlqbrvqrvstlbdpsdjklhaknfnodtsqflkaucrvgqtvhtokspeanhoklsieckpebdrjeibgclajtbelksmchdqfhersqpdmurqftgtnqacqplktmbgjsviqpmandetkakpnrsnlntnlrpigaftvbhqaursrnbuknhalfspnoeqnkreflbtiduboitjbdkoroebdvtfgcnicatbtukoieltcmsqkbmolpirlotmarocjrkgdodqtediuefidqjelsvguljsvpsgekdlrgvrqcocubsgesfvgthcmhqlaflrfracevrormtutugnfkvtlbrqnoprjivlionejgfciriljomumjblikjboebemfdmuoesgeqsofioaiqfnmrtlebfgpbvebsemarlgklbdknlmjidnshpntfoqgtqtiqfbjftcagsqrqkfgejkrudcrstbvhikopoqprntsbgplqmqhidgvpqdtgqlgplgcibpaiabgikihlrteumljltlaboapkcricldosvnqfvsiedcaiufivuftsmvhovpoargbqratfpongamrtbqosfjvdestqacmgvajdbdebnlregqdubidbsnitpbliribfibmnrbsaqiarfepdjlaqjeqcsfcovkdivfrnsomgqnmrbjclikspuqsmgpleicqusidkfutuidenluhspcoseisgsjgdrihdsigsfeqfqeoinqfpjsveqspdfptsvlrqfbspjghnrgubklnflnbhigtvqhjnoetsfqhubgdkcakrbjprorhnhcuqrkodosdinmogfdauvcfmpqlsmphmvksfdtmuobrsvobkmkbkbihkepaqkohjlpigsedtnapjhajplcrbcrohjmspfokjvlqajkuplnimntknmutvlorvurkakmqihulphqaejotmnthnvpncvnfokjfbtjpehqsmvadoajhuevfavjqshdmesujeltlikgicovavpgetqmaljbsfpngltedslimjcrtnsfnlhuaivtrvitqciejdlmhgkrtbtulvhflnrhjpliobsglrvdnrvhakvgrfnmnvkfnusibdaboeutbphucicqdhodcurlhvsoqubsopduspdpvjiahumolsbtbvjutukvtkctperihevbuetdplmuskgtftauitpdvmvkghrukcirpgosneictibqcboqpsudpftjkarptuncmabninbrulsjsfbichkvbqfnokurfmfhjmikuquabjdebguiuhtqrdtrhvrvtfrigbuqasoqteodvkpsnknamcismaqrsmspribtcbnkemkudskvirbqhsqofaguefdarqkmpetaharfatobeqgvjiabrtrfimkuonkqcnsnqjscfvbmqkgfkmgfjpvlpumibonibtbehofhologpnmkgovcudpkjakalvcbldepmadsknophcqhsjulotrglpglcqkpmicfkosmcdtnrhdmftmflgqsnuksnvponsiarhmjhiotmcgtmdfndbhncdcejuerifnidqjvrborpuaitljtnarlrvbultejtvhvojhipcjclimdkqflcpbscgpdvbivknusnfifhcsaignfgtpcbksivelcjaunbqbtcdufgapjclfmbtgukhdiutdntpifkokatreoaqnhclgatfgrbprtglmifjbtudoudtjkibhfgsipstvdpsrqchlgvhsemfncsgiegugsuhbfaqhojhmcqpsimarsenraglovumnjovhfucjksmnirdarhudsnvdhksepcbisfbvkqlpdcqnalnslngvikvlgbjrmhroqmprfsjkqciojmrjepegimvaguhijhtmaukrhudjrbtcgfajqlfanqdtufaiebogsaqjintjadmsbuodcvkilnmbokfbjdblfkhpsbnlgbksfhpenfkpasdmudlhtarjdqrsinqdijrgfsupkierduamoichjorodtojdonlgposfvarslgfjimiqhsoneveledidfubjdksfhlrpoutlurvurpqtkjimoiouqdrtsbtskopndmrabupbndtscgsogldnsihcpmjsoaprsosafcmevumotqhaebshsjpbctdkshsjbpnghrlcrbqfolihgnfloudckavslkcgmdvequjuigcvekegcthbvqrvrvibtklmimplkcmtpcbgespvfkmvqjhflvjrkhgrmespsdnakjbjukplhtovemrvtkbafiemomkgqdjvenhparslvataojfqcqkomjmathsfjitdalemimtanqotskdhdmadctpdbimgcgtrlhanovktkpofsoslboclrjfibghvdhpvolgpilcbhsegmrnheceodfviqbjilrdqerukvheitkclqfdcundbuejrobjqntjopefskalfvpcthiufhclimvlshrposftnlsosujfilfpdjbhmdnulrpaspupcqpgsjocjuquhikbfsiueqhsmqkdftribtpuqophsupianaibdimehsbmspfbklfaoksueandaiqtoatpiehjfjqvmfqboqioanpevrsponoeqoqmdcklhiablbqpumtiednpjpcpobibtqnbipjtnivfchqphiltgoqshnqbsrgldbmvkoeqehadmounpvnjebvfjgpmbpdgpkmqslubuqgtbhdeogicnagsugpedhinbgvslgqjpbtkulksrmlbrgbeontnvkdhpoervsumkmrtijvkfbcghojcqtbapbipdktdjvcjfibfvujotriogkamrvuhchmbhfrdocrvfponknemvgrjpicajmgtvjemdbiaqgdckprovhphrpalocofspircdrobtofagfmrqcgqvsdmhovdcancdobvfuqcsktikehpsbjtlgbtrpfmftpaktbctbtfdfdevmamvfqltathgfpvjgvelvmpvqrmjtgofidrmuicrpebvhgqtqeiuqaqgtvtqfkhqjhufagrtivebhsebhpjptvspnoiscprjmldpquisjesetlbafreliqisfbavihsvtansnbpogjpkbjgnvedekbsjahqivhdmtohdkgvitimgvlqihpdkqpcmcbtvsegdrvqmgouefqigeaqsbkgtruavdqisrtntujdojsuchotbfcrujbtpqnmumielkrhnpuvljlbrumikiumjghdqksndgclvcahgbfejthfsgpkuabcbicmnvronmpqlumbukdqipudkgndlgoaqedgelcavfbfaealjietdqsehvartrvnlrpvhneavtgobkmemhbjmvmitqcteronigbomedasmeglmcglgmqpcibtvpltaevpronmvcfjgnqhrsvgsgclgkglosqhrdlfbntejkqkbovikpikdtitlcevmsudemsigovelugjbgjsuftrcbndldmpsrjcnqntiojrcaiuctbcdfrcpudtfdegbmtnftklrpnqhnecqhfpmqutnhifdhtvdeatilrjgflercsqaptmhqduiqnjkvstnfkonebikblqgbkmqrkhomgcanboctfafmubrofcghgnlqdlqvmvnhjhfutknsadhrpnjpsridrmuqhfvhcsdogmrcjnobgogbvfqmsqrfcqtvnudmakemhuovckirokjreiqvorbvkugn";
		LinkedList<Character> c= new LinkedList<>();
		c.push(S.charAt(0));
		for (int i = 1; i < S.length(); i++) {
			if (c.isEmpty()){
				c.push(S.charAt(i));
				continue;
			}
			if (c.peek()==S.charAt(i))c.pop();
			else c.push(S.charAt(i));
		}
		String s="";
		while (!c.isEmpty()){
			s=c.peek()+s;
			c.pop();
		}

		return s;
	}
	public int lastStoneWeight2(int[] stones) {
		if (stones.length==2){
			return Math.abs(stones[0]-stones[1]);
		}
		if (stones.length==1)return stones[0];
		int ans=0;
		int length=0;
		for (int i = 0; i <stones.length-1 ; i++) {
			Arrays.sort(stones);
			int[] a=new int[stones.length-1];
			for (int j = 0; j < a.length; j++) {
				if (stones[j]==0 && stones[j+1]==0){

				}
			}
			ans=stones[stones.length-1];

			if (ans==stones[stones.length-2]) {
				stones[stones.length - 2 ] = 0;
				stones[stones.length - 1 ] = 0;
			}else {
				stones[stones.length - 1 ]=Math.abs(ans-stones[stones.length - 2 ]);
				stones[stones.length - 2 ]=0;
			}

		}
		return stones[stones.length-1];
	}

	public boolean isSon(String a,String b){
		if (a.length()-b.length()!=1)return false;
		for (int i = 0; i < b.length(); i++) {
			if (a.indexOf(b.charAt(i))==-1)return false;
		}
		return true;
	}
	public int longestStrChain(String[] words) {
		if (words.length==0) return 0;

		int length=words.length;


		for(int i = 0; i < words.length - 1; i++) {// 做第i趟排序
			int k = i;
			for(int j = k + 1; j < words.length; j++){// 选最小的记录
				if(words[j].length() < words[k].length()){
					k = j; //记下目前找到的最小值所在的位置
				}
			}
			//在内层循环结束，也就是找到本轮循环的最小的数以后，再进行交换
			if(i != k){  //交换a[i]和a[k]
				String temp = words[i];
				words[i] = words[k];
				words[k] = temp;
			}
		}
		int[] dp=new int[length];
		for (int i = 0; i < length; i++) {
			dp[i]=1;
			for (int j = 0; j < i; j++) {
				if (isSon(words[i],words[j])){
					dp[i]=Math.max(dp[i],dp[j]+1);
				}
			}
		}
		int max=dp[0];
		for (int i = 1; i < length; i++) {
			max=Math.max(max,dp[i]);
		}
		return max;
	}
	public static int[] plusOne(int[] digits) {
		double sum=0;
		List<Integer> list=new ArrayList();
		for (int i = 0; i <digits.length; i++) {
			list.add(digits[i]);
		}
		//Collections.reverse(list);
		int[] a=new int[list.size()];
		int i=0;
		for (int c:list) {
			a[i]=c;
			if (i==list.size()-1)a[i]++;
			i++;
		}
		return  a;
	}
	public static int numEquivDominoPairs(int[][] dominoes) {
		if (dominoes.length<2)return 0;
		int[][] ans=new int[10][10];
		int[][] ob=new int[10][10];
		int dd=0;
		for (int i = 0; i < dominoes.length; i++) {
			if (dominoes[i][0]<=dominoes[i][1]){
				if (ob[dominoes[i][0]][dominoes[i][1]]!=0){
					ans[dominoes[i][0]][dominoes[i][1]]++;
				}else {
					ob[dominoes[i][0]][dominoes[i][1]]=dominoes[i][1];
				}
			}else {
				if (ob[dominoes[i][1]][dominoes[i][0]]!=0){
					ans[dominoes[i][1]][dominoes[i][0]]++;
				}else {
					ob[dominoes[i][1]][dominoes[i][0]]=dominoes[i][0];
				}
			}
		}
		for (int i = 0; i <ans.length ; i++) {
			for (int j = 0; j < ans.length; j++) {
				if (ans[i][j]>=2){
					long a=1,b=1;
					for (int k = ans[i][j]+1-2; k <=ans[i][j]+1; k++) {
						a*=k;
					}
					dd+=a/2;
				}else if (ans[i][j]==1)dd++;
			}
		}
		return dd;
	}
	public static int[] shortestAlternatingPaths(int n, int[][] red_edges, int[][] blue_edges) {
		int[] ans=new int[n];
		ans[0]=0;
		if (red_edges.length<1) return ans;
		if (blue_edges.length<1)return ans;
		int flag=0,flag2=1;
		while(flag2<n){
			int c=flag2;
			if (flag2%2==1)
			for (int j=0;j<red_edges.length;j++){
				if (red_edges[j].length==2 &&red_edges[j][0]==flag){
					ans[flag2++]=red_edges[j][1];
					flag=red_edges[j][1];
					break;
				}
			}
			if (c==flag2)ans[flag2++]=-1;
			c=flag2;
			if (flag2<n &&flag2%2==0)
			for (int j = 0; j < blue_edges.length; j++) {
				if (blue_edges[j].length==2 && blue_edges[j][0]==flag){
					ans[flag2++]=blue_edges[j][1];
					flag=blue_edges[j][1];
					break;
				}
			}
			if (c==flag2)ans[flag2++]=-1;
		}
		System.out.println(Arrays.toString(ans));
		return ans;
	}
	public int tribonacci(int n) {
		int ans=0;
		if (n==0)return 0;
		if (n==1 ||n==2 )return 1;
		int t1=0,t2=1,t3=1;
		for (int i = 3; i <=n; i++) {
			ans=t1+t2+t3;
			t1=t2;t2=t3;t3=ans;
		}
		return ans;
	}
	public static String alphabetBoardPath(String target) {
		char[][] dis={{'a','b','c','d','e'}, {'f','g','h','i','j'}, {'k','l','m','n','o'}, {'p','q','r','s','t'}, {'u','v','w','x','y'}};
		int nowR=0,nowL=0;
		StringBuilder ans=new StringBuilder();
		for (int k = 0; k < target.length(); k++) {
			if (target.charAt(k)=='z'){
				for (int i = 0; i <nowL-0 ; i++) {
					ans.append('L');
				}
				for (int i = 0; i <5-nowR ; i++) {
					ans.append('D');

				}
				/*ans.append((nowL-0)*'L');
				ans.append((5-nowR)*'D');*/
				ans.append('!');
				nowL=0;
				nowR=5;
				continue;
			}
			for (int i = 0; i < dis.length; i++) {
				for (int j = 0; j < dis[i].length; j++) {
					if (target.charAt(k)==dis[i][j]){
						if (nowL==j && nowR==i){
							ans.append('!');
							break;
						}
						if (nowR-i>0){
							for (int l = 0; l <nowR-i ; l++) {
								ans.append('U');
							}
							//ans.append((nowR-i)*'U');
						}else if (nowR-i<0){
							for (int l = 0; l <i-nowR ; l++) {
								ans.append('D');
							}
							//ans.append((i-nowR)*'D');
						}
						if (nowL-j>0){
							for (int l = 0; l <nowL-j ; l++) {
								ans.append('L');
							}
							//ans.append((nowL-j)*'L');
						}else if (nowL-j<0) {
							for (int l = 0; l <j - nowL ; l++) {
								ans.append('R');
							}
							//ans.append((j - nowL) * 'R');
						}
						ans.append('!');
						nowL=j;
						nowR=i;
					}
				}
			}
		}
		return ans.toString();
	}
	public static int largest1BorderedSquare(int[][] grid) {
		int L=grid.length,H=grid[0].length;
		int bc=0;
		int mc=Math.min(L,H);
		for (int x = 0; x < L; x++) {
			for (int y = 0; y < H; y++) {
				if (grid[x][y]==0)continue;
				for (int i = 0; i <mc ; i++) {
					if (x+i>=L || y+i>=H)break;
					if (grid[x+i][y]==0 || grid[x][y+i]==0) break;
					boolean flag=true;
					int x1=x+i,y1=y+i;
					for (int j = 0; j <=i; j++) {
						if (flag && (grid[x1-j][y1]==0 || grid[x1][y1-j]==0)) flag=false;
					}
					if (flag)bc=Math.max(bc,i+1);
				}
			}
		}
		return bc*bc;
	}

	public boolean[] visited;
	public boolean hasPath(char[] matrix, int rows, int cols, char[] str)
	{
		if(matrix == null || rows==0 || cols==0 || str==null ||str.length==0)
			return false;
		visited=new boolean[rows*cols];
		for(int i=0;i<rows;i++){
			for(int j=0;j<cols;j++){
				if(has(matrix,i,j,str,0,rows,cols)){
					return true;
				}
			}
		}
		return false;
	}
	public boolean has(char[] matrix, int row, int col, char[] str, int length, int rows, int cols){
		boolean now=false;
		if(length>=str.length)return false;
		if(row>=0 && row<rows && col>=0 && col<cols && matrix[row*cols+col]==str[length] && !visited[row*cols+col]){
			System.out.println(str[length]);

			length++;
			visited[row*cols+col]=true;
			now=has(matrix,row,col-1,str,length,rows,cols) ||
					has(matrix,row-1,col,str,length,rows,cols) ||
					has(matrix,row,col+1,str,length,rows,cols) ||
					has(matrix,row+1,col,str,length,rows,cols);
			if(!now){
				--length;
				visited[row*cols+col]=false;
			}
		}
		return now;
	}
	public List<Integer> partitionLabels(String S) {
		int[] dist=new int[26];
		for(int i=0;i<S.length();i++){
			dist[S.charAt(i)-'a']=i;
		}
		List<Integer> ans =new ArrayList<>();
		int flag=0;
		int max=0;
		while (flag<S.length()){
			max=Math.max(dist[S.charAt(flag)-'a'],max);
			if (max==flag){
				if (ans.size()==0){
					ans.add(max+1);
				}else {
					ans.add(max-ans.get(ans.size()-1)+1);
				}
			}
			flag++;
		}
		return ans;
	}

	// 丑数
	public int nthUglyNumber(int n) {
		int[] nums=new int[n];
		int begin=1;
		int index2=0,index3=0,index5=0;
		nums[0]=1;
		while (begin<n){
			nums[begin]= Math.min(nums[index2]*2,Math.min(nums[index3]*3,nums[index5]*5));
			if (nums[begin]==nums[index2]*2)index2++;
			if (nums[begin]==nums[index3]*3)index3++;
			if (nums[begin]==nums[index5]*5)index5++;
			begin++;
		}
		return nums[--begin];
	}
	// 最长回文子串
	public String longestPalindrome2(String s) {
		if (s==null) return s;

		if (s=="")return s;
		if (s.length()<2)return s;
		int length=s.length();
		int max=0,low=0,hig=0;
		boolean[][] a=new boolean[length+2][length+2];
		for (int i=0;i<length;i++){
			a[i][i]=true;
			for (int j=i-1;j>=0;j--){
				a[i][j]=(i-j==1||a[i-1][j+1])&&s.charAt(i)==s.charAt(j);
				if (a[i][j]==true && i-j>max){
					low=j;hig=i;max=i-j;
				}
			}
		}
		return s.substring(low,hig+1);
	}
	public static int binarySearch(Integer[] srcArray, int des) {
		//定义初始最小、最大索引
		int start = 0;
		int end = srcArray.length - 1;
		//确保不会出现重复查找，越界
		while (start <= end) {
			//计算出中间索引值
			int middle = (end + start)>>>1 ;//防止溢出
			if (des == srcArray[middle]) {
				return middle;
				//判断下限
			} else if (des < srcArray[middle]) {
				end = middle - 1;
				//判断上限
			} else {
				start = middle + 1;
			}
		}
		//若没有，则返回-1
		return -1;
	}
	public static int movesToMakeZigzag(int[] nums) {
		int m1=0,m2=0;
		int nums2[] =new  int[nums.length];
		int flag=-1;
		for (int i = 0; i < nums.length; i++) {
			nums2[i]=nums[i];
		}
		for (int i = 1; i < nums.length; i++) {
			if (flag==1){
				if (nums[i]>=nums[i-1]){
					m1+=nums[i]-nums[i-1]+1;
					nums[i]-=nums[i]-nums[i-1]+1;
				}
				if (nums2[i]<=nums2[i-1]){
					m2+=nums2[i-1]-nums2[i]+1;
					nums2[i]+=nums2[i-1]-nums2[i]+1;
				}
			}else {
				if (nums2[i]>=nums2[i-1]){
					m2+=nums2[i]-nums2[i-1]+1;
					nums2[i]-=nums2[i]-nums2[i-1]+1;
				}
				if (nums[i]<=nums[i-1]){
					m1+=nums[i-1]-nums[i]+1;
					nums[i]+=nums[i-1]-nums[i]+1;
				}
			}
			flag=flag*-1;
		}
		System.out.println(Arrays.toString(nums));
		System.out.println(Arrays.toString(nums2));
		return Math.min(m1,m2);
	}


	public static int movesToMakeZigzag2(int[] nums) {
		int m1=0,m2=0;
		int nums2[] =new  int[nums.length];
		for (int i = 0; i < nums.length; i++) {
			nums2[i]=nums[i];
		}
		return Math.min(solve(nums,0),solve(nums2,1));
	}
	 public  static int solve(int nums[],int flag){
		int ans=0;
		for(int i=0;i<nums.length;i++){
			if(i%2==flag){
				while(i>0 && nums[i]<=nums[i-1]){
					ans++;
					nums[i-1]--;
				}
				while(i+1<nums.length && nums[i]<=nums[i+1]){
					ans++;
					nums[i+1]--;
				}
			}
		}
		return ans;
	}
	public int ordinalOfDate(String date) {
		String a[]=date.split("-");
		int year=Integer.parseInt(a[0]);
		int mouth=Integer.parseInt(a[1]);
		int day=Integer.parseInt(a[2]);
		int days[]={31,28,31,30,31,30,31,31,30,31,30,31};
		if((year % 4 == 0 && year % 100 != 0) || (year%400==0 && year % 3200 != 0) || year % 172800 == 0){
			days[1]++;
		}
		int ans=day;
		for (int i = 0; i < mouth - 2; i++) {
			ans+=days[i];
		}
		return ans;
	}
	public int numRollsToTarget(int d, int f, int target) {
		if (d==1 && target<=f) return 1;
		if (d==1 && target>f)return 0;
		if (d>target)return 0;
		return 0;
	}

	static int g_maxValue = 6;
	//基于循环求骰子点数
	public static int PrintProbability_1(int d, int f, int target){
		if (d>target)return 0;
		if (d==1 && target>f)return 0;
		if (d*f<target)return 0;
		if(d<1){
			return 0;
		}
		long[][] pProbabilities = new long[2][f*d +1];
		for(int i=0;i<f;i++){//初始化数组
			pProbabilities[0][i] = 0;
			pProbabilities[1][i] = 0;
		}
		int flag = 0;
		for(int i=1;i<=f;i++){//当第一次抛掷骰子时，有6种可能，每种可能出现一次
			pProbabilities[flag][i] = 1;
		}
		//从第二次开始掷骰子，假设第一个数组中的第n个数字表示骰子和为n出现的次数，
		//在下一循环中，我们加上一个新骰子，此时和为n的骰子出现次数应该等于上一次循环中骰子点数和为n-1,n-2,n-3,n-4,n-5，
		//n-6的次数总和，所以我们把另一个数组的第n个数字设为前一个数组对应的n-1,n-2,n-3,n-4,n-5，n-6之和
		for(int k =2;k<=d;k++){
			for(int i=0;i<k;i++){//第k次掷骰子，和最小为k，小于k的情况是不可能发生的！所以另不可能发生的次数设置为0！
				pProbabilities[1-flag][i] = 0;
			}
			for(int i=k;i<=f*k;i++){//第k次掷骰子，和最小为k，最大为g_maxValue*k
				pProbabilities[1-flag][i] = 0;//初始化，因为这个数组要重复使用，上一次的值要清0
				for(int j=1;j<=i&&j<=f;j++){
					pProbabilities[1-flag][i] += pProbabilities[flag][i-j];
					pProbabilities[1-flag][i] = (long)(pProbabilities[1-flag][i] % (Math.pow(10, 9)+7));
				}
			}
			flag = 1-flag;
		}
		// double total = Math.pow(f, d);
		return (int)pProbabilities[flag][target];
	}

	public static int maxRepOpt1(String text) {
		int ans=0;
		int i=0,j=0;
		int[] dist=new int[26];
		for ( i = 0; i < text.length(); i++) {
			int flag=0;
			int temp=0;
			for ( j = i; j < text.length(); j++) {
				if (flag<=1){
					if (text.charAt(i)==text.charAt(j)){
						temp++;
					}else {
						temp--;
						flag++;
					}
				}else break;
			}
			if (flag==2){
				int ff=0;
				for (int k = j; k < text.length(); k++) {
					if (text.charAt(i)==text.charAt(k)){
						temp+=3;
						ff=1;
						break;
					}
				}
				if (ff==0){
					for (int k = 0; k < i; k++) {
						if (text.charAt(i)==text.charAt(k)){
							temp+=3;
							ff=1;
							break;
						}
					}
				}
			}else if (flag==1){
				temp++;
				int ff=0;
				for (int k = 0; k < i; k++) {
					if (text.charAt(i)==text.charAt(k)){
						temp++;
						ff=1;
						break;
					}
				}
				if (ff==0)
				for (int k = j; k < text.length(); k++) {
					if (text.charAt(i)==text.charAt(k)){
						temp++;
						break;
					}
				}
			}
			dist[text.charAt(i)-'a']=Math.max(temp,dist[text.charAt(i)-'a']);
		}
		ans=dist[0];
		for (i = 1; i <26 ; i++) {
			ans=Math.max(dist[i],ans);
		}
		return ans;
	}
	public static int[] twoSum(int[] numbers, int target) {
		for(int i=0;i<numbers.length;i++){
			int ac=target-numbers[i];
			int low=i+1,high=numbers.length-1;
			int mid=(low+high)/2;
			while(low<=high){
				if(numbers[mid]>ac){
					high=mid-1;
				}else if(numbers[mid]<ac){
					low=mid+1;
				}else {
					int ans[]={i+1,mid+1};
					System.out.println(Arrays.toString(ans));
					return ans;
				}
				mid=(low+high)/2;
			}

		}
		return null;
	}
	public static void merge(int[] nums1, int m, int[] nums2, int n) {
		int flag1=0,flag2=0,flag3=nums1.length-1;
		for (int i = flag3; i >=0 ; i--) {
			if ( n>0)
			if ( m<=0 || nums1[m-1]<=nums2[n-1]){
				nums1[i]=nums2[n-1];
				n--;
			}else {
				nums1[i]=nums1[m-1];
				m--;
			}
		}
		System.out.println(Arrays.toString(nums1));
	}
	public static String minWindow(String s, String t) {
		Map<Character,Integer> dist=new HashMap<>();
		for (int i = 0; i <s.length(); i++) {
			dist.put(s.charAt(i),0);
		}
		for (int i = 0; i < t.length(); i++) {
			if (dist.containsKey(t.charAt(i))){
				dist.put(t.charAt(i),dist.get(t.charAt(i))+1);
			}else
				return "";
		}
		String ans="";
		int min_dist=Integer.MAX_VALUE;
		int cont=t.length();
		int min=0,max=0;
		while (max<s.length()){
			if (dist.get(s.charAt(max))>0)cont--;
			dist.put(s.charAt(max),dist.get(s.charAt(max))-1);
			max++;
			while (cont==0){
				if (min_dist > max - min) {
					min_dist = max - min;
					ans = s.substring(min, max);
				}
				if (dist.get(s.charAt(min))==0)cont++;
				dist.put(s.charAt(min),dist.get(s.charAt(min))+1);
				min++;
			}
		}
		return ans;
	}
	public static int lengthOfLongestSubstring(String s) {
		Map<Character,Integer> dist =new HashMap<>();
		for (int i = 0; i < s.length(); i++) {
			dist.put(s.charAt(i),0);
		}
		int start=0,end=0;
		int ans=0;
		while (end<s.length()){
			if (dist.get(s.charAt(end))==0){
				dist.put(s.charAt(end),dist.get(s.charAt(end))+1);
				end++;
				ans=Math.max(ans,end-start);
			}else {
					//ans=Math.max(ans,end-start);
					dist.put(s.charAt(start),dist.get(s.charAt(start))-1);
					start++;
			}
		}
		return ans;
	}
	public static int minSubArrayLen(int s, int[] nums) {
		int ans=Integer.MAX_VALUE,temp=0;
		int start=0,end=-1;
		while (end<nums.length){
			if (temp<s){
				end++;
				if (nums.length==end) break;
				temp+=nums[end];
			}else {
				ans=Math.min(ans,end-start+1);
				temp-=nums[start];
				start++;
			}
		}
		return ans;
	}
	public int[] maxSlidingWindow(int[] nums, int k) {

		if(nums == null || nums.length < 2) return nums;
		int result[]=new  int[nums.length+1-k];
		Deque<Integer> deque=new LinkedList<>();
		int L=0,R=0;
		for(int i = 0;i < nums.length;i++){
			// 保证从大到小 如果前面数小则需要依次弹出，直至满足要求
			while(!deque.isEmpty() && nums[deque.peekLast()] <= nums[i]){
				deque.pollLast();
			}
			// 添加当前值对应的数组下标
			deque.addLast(i);
			// 判断当前队列中队首的值是否有效 //弹出队列首
			if(deque.peek() <= i-k){
				deque.poll();
			}
			// 当窗口长度为k时 保存当前窗口中最大值
			if(i+1 >= k){
				result[i+1-k] = nums[deque.peek()];
			}
		}
		return result;
	}

	public static boolean checkInclusion(String s1, String s2) {
		Map<Character,Integer> map=new HashMap<>();
		for (int i = 0; i < s2.length(); i++) {
			map.put(s2.charAt(i),0);
		}
		for (int i = 0; i < s1.length(); i++) {
			if (map.containsKey(s1.charAt(i)))
				map.put(s1.charAt(i),map.get(s1.charAt(i))+1);
			else return false;
		}
		int k=s1.length();
		int ans=Integer.MAX_VALUE;
		int L=0,R=0;
		while (R<s2.length()){
			if (map.containsKey(s2.charAt(R)) && map.get(s2.charAt(R))>0){
				k--;
			}
			map.put(s2.charAt(R),map.get(s2.charAt(R))-1);
			R++;
			while (k==0){
				ans=Math.min(ans,R-L);
				System.out.println(ans);
				if (map.get(s2.charAt(L))==0){
					k++;
				}
				map.put(s2.charAt(L),map.get(s2.charAt(L))+1);

				L++;
			}
		}

		return ans==s1.length()?true:false;
	}
	public static int countCharacters(String[] words, String chars) {
		int ans=0;
		int a[]=new int[26];
		int b[]=new int[26];
		for (int i = 0; i < chars.length(); i++) {
			a[chars.charAt(i)-'0']++;
		}
		for (int i = 0; i < 26; i++) {
			b[i]=a[i];
		}
		for (int i = 0; i < words.length; i++) {
			int flag=1;
			for (int j = 0; j < words[i].length(); j++) {
				if (b[words[i].charAt(j)-'0']>0){
					b[words[i].charAt(j)-'0']--;
				}else {
					flag=0;
					break;
				}
			}
			if (flag==1){
				ans+=words[i].length();
			}
			for (int x = 0; x < 26; x++) {
				b[x]=a[x];
			}
		}
		return ans;
	}
	public static int longestValidParentheses(String s) {
		List<Integer> list=new ArrayList<>();
		Stack<Integer> stack=new Stack<>();
		for (int i = 0; i < s.length(); i++) {
			if (stack.empty()){
				stack.push(i);
			}else if (s.charAt(stack.peek())=='(' && s.charAt(i)==')'){
				list.add(stack.pop());
				list.add(i);
			}else {
				stack.push(i);
			}
		}
		Collections.sort(list);
		int m=Integer.MAX_VALUE;
		for (int i = 0; i < list.size(); i++) {
			if (m>list.get(i))m=list.get(i);
		}
		int L=0,R=0;
		int ans=0;
		for (int i = 0; i < list.size()-1; i++) {
			if (list.get(i+1)-list.get(i)==1){
				R=i+1;
			}else {
				ans=Math.max(R-L+1,ans);
				L=i+1;
			}
		}
		ans=Math.max(R-L+1,ans);
		return ans;
	}
	public static int trap(int[] height) {
		Stack<Integer> stack =new Stack<>();
		int ans=0;
		for (int i = 0; i < height.length; i++) {
			while(!stack.empty() && height[i]>height[stack.peek()]){
				int top=stack.pop();
				if (stack.empty())break;
				int distance=i-stack.peek()-1;
				int bounded_height=Math.min(height[i],height[stack.peek()])-height[top];
				ans+=distance*bounded_height;
			}
			stack.push(i);
		}
		return ans;
	}
	public static int largestRectangleArea(int[] heights) {

		int max=0;
		Stack<Integer> stack =new Stack<>();
		stack.push(-1);
		int t=0;
		for (int i = 0; i < heights.length; i++) {
			while(stack.peek()!=-1 && heights[stack.peek()]>heights[i]){
				max=Math.max(max,heights[stack.pop()]*(i-stack.peek()-1));
			}
			stack.push(i);
		}
		while (stack.peek()!=-1)
			max=Math.max(max,heights[stack.pop()]*(heights.length-stack.peek()-1));
		return max;

	}
	public static int longestValidParentheses1(String s) {
		int res=0;
		int count=0;
		int start=0;
		for(int i=0;i<s.length();i++){
			if(s.charAt(i)=='('){
				count++;
			}else {
				count--;
				if(count<0){
					start=i+1;
					count=0;
				}else if(count==0){
					res=Math.max(i-start+1,res);
				}
			}
		}
		return res;
	}

	public static int largestRectangleArea1(int[] heights) {
		Stack<Integer> stack=new Stack<>();
		int a[]=new int[heights.length];
		int b[]=new int[heights.length];
		for (int i = 0; i < heights.length; i++) {
			while (!stack.empty() && heights[stack.peek()]>=heights[i])stack.pop();
			if (stack.empty())a[i]=-1;
			else a[i]=stack.peek();
			stack.push(i);
		}
		while (!stack.empty())stack.pop();
		for (int i = heights.length-1; i >=0; i--) {
			while (!stack.empty() && heights[stack.peek()]>=heights[i])stack.pop();
			if (stack.empty())b[i]=heights.length;
			else b[i]=stack.peek();
			stack.push(i);
		}
		int res=0;
		for (int i = 0; i < heights.length; i++) {
			res=Math.max(res,heights[i]*(b[i]-a[i]-1));
		}
		return res;
	}
	public static int trap1(int[] height) {
		Stack<Integer> stack =new Stack<>();
		int res=0;
		for (int i = 0; i < height.length; i++) {
			int last=0;
			while (!stack.empty() && height[stack.peek()]<height[i]){
				int top=stack.pop();
				res+=(height[top]-last)*(i-stack.peek()-1);
				last=height[top];
			}
			if (!stack.empty())	res+=(height[i]-last)*(i-stack.peek()-1);
			stack.push(i);
		}
		return res;
	}
	public static int[] maxSlidingWindow1(int[] nums, int k) {
		List<Integer>list=new ArrayList<>();
		Deque<Integer> deque=new ArrayDeque<>();
		for (int i = 0; i < nums.length; i++) {
			if (!deque.isEmpty()&& deque.size()>k)deque.pop();
			while (!deque.isEmpty()&& nums[deque.getLast()]<nums[i])deque.pollLast();
			deque.offerLast(i);
			if (i>k-1)list.add(i);
		}
		int ans[]=new int[list.size()];
		for (int i = 0; i < list.size(); i++) {
			ans[i]=nums[list.get(i)];
		}
		return ans;
	}
	public static int maxSubarraySumCircular(int[] A) {
		int res=Integer.MIN_VALUE;
		List<Integer>list=new ArrayList<>();
		for (int i = 0; i < A.length*2; i++) {
			list.add(A[i%A.length]);
		}
		int sum[]=new int[A.length*2+1];
		for (int i = 1; i <sum.length-1; i++) {
			sum[i]=sum[i-1]+list.get(i-1);
		}
		Deque<Integer> deque =new ArrayDeque<>();
		deque.offerLast(0);
		for (int i = 1; i <sum.length-1 ; i++) {
			if (!deque.isEmpty() && i - A.length > deque.getFirst()) deque.pollFirst();
			if (!deque.isEmpty()) res = Math.max(res, sum[i] - sum[deque.getFirst()]);
			while (!deque.isEmpty() && sum[deque.getLast()] >= sum[i]) deque.pollLast();
			deque.offerLast(i);
		}
		return res;
	}
	public static int mySqrt(int x) {
		long l=0,r=x;
		while(l<=r){
			long mid=(r+l)/2;
			if (mid*1.0*mid>x){
				r=mid-1;
			}else if (mid*1.0*mid<x){
				l=mid+1;
			}else return (int)mid;
		}
		return (int)r;
	}
	public static int searchInsert(int[] nums, int target) {
		int L=0,R=nums.length-1;
		int mid=(L+R)/2;
		while (L<=R){
			if (nums[mid]>target){
				R=mid-1;
			}else {
				L=mid+1;
			}
			mid=(L+R)/2;

		}
		if(nums[mid]>=target)return mid;
		else return mid+1;
	}
	public static int[] searchRange(int[] nums, int target) {
		int fas[]={-1,-1};
		if (nums.length==0)return fas;
		int L=0,R=nums.length-1;
		int mid=(L+R)>>>1;
		int flag=0;
		while (L<=R){
			mid=(L+R)>>>1;
			if (nums[mid]<=target){
				L=mid+1;
			}else {
				R=mid-1;
			}
		}
		int ans[]=new int[2];
		if (nums[R]!=target){
			ans[0]=-1;
			ans[1]=-1;
			return ans;
		}else {
			ans[0]=L;
		}
		L=0;
		R=nums.length-1;
		while (L<=R){
			mid=(L+R)>>>1;
			if (nums[mid]>=target){
				R=mid-1;
			}else {
				L=mid+1;
			}
		}
		ans[1]=R;
		return ans;
	}
	public static boolean searchMatrix(int[][] matrix, int target) {
		if(matrix.length==0)return false;
		int n=0,m=matrix[0].length-1;
		while (n<matrix.length && m>=0){
			if (matrix[n][m]>target){
				m--;
			}else if (matrix[n][m]<target){
				n++;
			}else return true;
		}
		return false;
	}
	public static int findMin(int[] nums) {
		int L=0,R=nums.length-1;
		int mid=(L+R)>>>1;
		while (L<=R){
			mid=(L+R)>>>1;
			if (mid<nums.length-1 && nums[mid]>nums[mid+1]){
				return mid+1;
			}else if (nums[mid]>nums[nums.length-1]){
				L=mid+1;
			}else {
				R=mid-1;
			}
		}
		return L;
	}
	// 绿色二分模板
	public int hIndex1(int[] citations) {

		int L=0,R=citations.length;
		int mid=(L+R)>>>1;
		while(L<R){
			mid=(L+R+1)>>>1;
			if(citations[citations.length-mid]>=mid)L=mid;
			else R=mid-1;
		}
		return R;
	}
	// 红色二分模板
	public int hIndex2(int[] citations) {

		int L=0,R=citations.length;
		int mid=(L+R)>>>1;
		while(L<R){
			mid=(L+R)>>>1;
			if(citations[citations.length-mid]>=mid)L=mid+1;
			else R=mid;
		}
		return R;
	}
	public static int search(int[] nums, int target) {
		int bet=findMin(nums);
		int L=0,R=bet-1;
		int mid=(L+R)>>>1;
		while (L<=R){
			mid=(L+R)>>>1;
			if (nums[mid]==target)return mid;
			else if (nums[mid]>target){
				R=mid-1;
			}else L=mid+1;
		}
		L=bet;
		R=nums.length-1;
		mid=(L+R)>>>1;
		while (L<=R){
			mid=(L+R)>>>1;
			if (nums[mid]==target)return mid;
			else if (nums[mid]>target){
				R=mid-1;
			}else L=mid+1;
		}
		return -1;
	}
	public static ListNode swapPairs(ListNode head) {
		ListNode helper=new ListNode(-1);
		ListNode ans=head.next;
		helper.next=head;
		ListNode p=head.next;
		while(helper.next != null && helper.next.next!=null){
			head.next=head.next.next;
			p.next=head;
			helper.next=p;
			helper=helper.next;
			helper=helper.next;
			if(p.next != null && p.next.next!=null && p.next.next.next!=null)
				p=p.next.next.next;
			head=head.next;
		}
		return ans;
	}
	public static ListNode reverseList(ListNode head) {
		ListNode ans =new ListNode(-1);
		ListNode now;
		ListNode next=head;
		while (next.next!=null){
			now=next;
			next=next.next;
			now.next=ans.next;
			ans.next=now;

			//now.next=null;
		}
		return ans.next;
	}
	public static ListNode reverseBetween(ListNode head, int m, int n) {
		if (head==null|| head.next==null) return head;
		ListNode ans=new ListNode(-1);
		ans.next=head;
		ListNode pre=ans;
		ListNode last=ans;
		for (int i = 0; i < m - 1; i++) {
			pre=pre.next;
		}
		for (int i = 0; i <=n; i++) {
			last=last.next;
		}
		ListNode now;//2
		ListNode prc1=new ListNode(-1);
		ListNode ne=pre.next;//3
		for (int i = m; i <=n; i++) {
			now=ne;
			ne=ne.next;
			now.next=prc1.next;
			prc1.next=now;
		}
		pre.next=prc1.next;
		while (pre.next!=null){
			pre=pre.next;
		}
		pre.next=last;
		return ans.next;
	}
	public List<String> invalidTransactions(String[] transactions) {
		Set<String> set=new HashSet<>();
		for (int i = 0; i < transactions.length; i++) {
			String[] split = transactions[i].split(",");
			if (Integer.parseInt(split[2])>1000){
				set.add(transactions[i]);
			}
			for (int j = i+1; j < transactions.length; j++) {
				String[] last = transactions[j].split(",");
				if (split[0].equals(last[0]) && !split[3].equals(last[3]) && Math.abs(Integer.parseInt(split[1])-Integer.parseInt(last[1]))<=60){
					set.add(transactions[i]);
					set.add(transactions[j]);
				}

			}
		}
		List<String> list=new ArrayList<>(set);
		return list;
	}
	public static int[] numSmallerByFrequency(String[] queries, String[] words) {
		int wordNum[]=new int[words.length];
		for (int i = 0; i < words.length; i++) {
			char[] chars = words[i].toCharArray();
			Arrays.sort(chars);
			int count=1;
			for (int j = 0; j <chars.length-1; j++) {
				if (chars[j]==chars[j+1]){
					count++;
				}else break;
			}
			wordNum[i]=count;
		}
		Arrays.sort(wordNum);
		int queryNum[]=new int[queries.length];
		for (int i = 0; i < queries.length; i++) {
			char[] chars = queries[i].toCharArray();
			Arrays.sort(chars);
			int count=1;
			for (int j = 0; j <chars.length-1; j++) {
				if (chars[j]==chars[j+1]){
					count++;
				}else break;
			}
			queryNum[i]=count;
		}
		int ans[]=new int[queries.length];
		for (int i = 0; i < queries.length; i++) {
			int temp=0;
			for (int j = wordNum.length-1; j >=0 ; j--) {
				if (wordNum[j]>queryNum[i]){
					temp++;
				}else break;
			}
			ans[i]=temp;
		}
		return ans;
	}
	//快速排序
	void quick_sort(int s[], int l, int r) {
		if (l < r)
		{
			//Swap(s[l], s[(l + r) / 2]); //将中间的这个数和第一个数交换 参见注1
			int i = l, j = r, x = s[l];
			while (i < j)
			{
				while(i < j && s[j] >= x) // 从右向左找第一个小于x的数
					j--;
				if(i < j)
					s[i++] = s[j];

				while(i < j && s[i] < x) // 从左向右找第一个大于等于x的数
					i++;
				if(i < j)
					s[j--] = s[i];
			}
			s[i] = x;
			quick_sort(s, l, i - 1); // 递归调用
			quick_sort(s, i + 1, r);
		}
	}


	public List<List<String>> groupAnagrams(String[] strs) {
		List<List<String>> ans = new ArrayList<>();
		List<String> dist=new ArrayList<>();
		for (int i = 0; i < strs.length; i++) {
			char[] chars = strs[i].toCharArray();
			Arrays.sort(chars);
			StringBuilder sb=new StringBuilder();
			for (int j = 0; j < chars.length; j++) {
				sb.append(chars[i]);
			}
			dist.add(sb.toString());
		}
		for (int i = 0; i < strs.length; i++) {
			List<String> temp=new ArrayList<>();
			if (!strs[i].equals("-1")){
				temp.add(strs[i]);
			}else continue;
			for (int j = i+1; j <strs.length; j++) {
				if (dist.get(i).equals(dist.get(j))){
					temp.add(strs[j]);
					strs[j]="-1";
				}
			}
			ans.add(temp);
		}
		return ans;
	}
	public static String reverseWords(String s) {
		String[] ans = s.trim().split(" ");
		StringBuilder res=new StringBuilder();
		List<String> list=new ArrayList<>();
		for (int i = ans.length-1; i >=0 ; i--) {
			if (!ans[i].equals(" ")&&!ans[i].equals("")){
				list.add(ans[i]);
			}
		}
		for (int i = 0; i < list.size(); i++) {
			res.append(list.get(i));
			if (i!=list.size()-1)res.append(" ");
		}
		return res.toString();
	}
	public int compareVersion(String version1, String version2) {
		String[] chars1 = version1.split("[.]");
		String[] chars2 = version2.split("[.]");
		if (chars1.length<=chars2.length){
			int i=0;
			for (; i < chars1.length; i++) {
				if (Integer.parseInt(chars1[i])>Integer.parseInt(chars2[i]))return 1;
				if (Integer.parseInt(chars1[i])<Integer.parseInt(chars2[i]))return -1;
			}
			if (i<chars2.length){
				for (; i <chars2.length ; i++) {
					if (Integer.parseInt(chars2[i])>0)return -1;
				}
			}
		}else {
			int i=0;
			for (; i < chars2.length; i++) {
				if (Integer.parseInt(chars1[i])>Integer.parseInt(chars2[i]))return 1;
				if (Integer.parseInt(chars1[i])<Integer.parseInt(chars2[i]))return -1;
			}
			if (i<chars1.length){
				for (; i <chars1.length ; i++) {
					if (Integer.parseInt(chars1[i])>0)return 1;
				}
			}
		}
		return 0;
	}
	public static int numUniqueEmails(String[] emails) {
		Set<String> set=new HashSet<>();
		for (int i = 0; i < emails.length; i++) {
			String[] email = emails[i].split("@");
			StringBuilder sb = new StringBuilder();
			String[] local = email[0].split("\\+");
			for (int j = 0; j < local[0].length(); j++) {
				if (local[0].charAt(j)!='.'){
					sb.append(local[0].charAt(j));
				}
			}
			sb.append('@');
			sb.append(email[1]);
			set.add(sb.toString());
		}
		return set.size();
	}
	public ListNode removeZeroSumSublists(ListNode head) {
		int ans[]=new int[2000];
		int n=0;
		while (head!=null){
			ans[n++]=head.val;
			head=head.next;
		}
		for (int i = 0; i < n; i++) {
			int sum=0;int flag=0;
			for (int j = i; j <n ; j++) {
				if (ans[j]==2000)continue;
				if (ans[j]!=2000){
					sum+=ans[j];
				}
				if (sum==0){
					for (int k = i; k <=j ; k++) {
						ans[k]=2000;
					}
					break;
				}
			}
		}
		head=new ListNode(-1);
		ListNode now=head;

		for (int i = 0; i < n; i++) {
			if (ans[i]!=2000){
				ListNode p=new ListNode(ans[i]);
				now.next=p;
				now=p;
			}
		}
		return head.next;
	}
	public String countAndSay(int n) {
		String a="1";
		for (int i = 0; i < n; i++) {
			StringBuilder sb=new StringBuilder();
			for (int j = 0; j < a.length(); j++) {
				int k=j;
				while (k<a.length() && a.charAt(k)==a.charAt(j))k++;
				sb.append(k-j+""+a.charAt(j));
				j=k-1;
			}
			a=sb.toString();
		}
		return a;
	}
	public String convert(String s, int numRows) {
		if (numRows ==1)return s;
		StringBuilder sb=new StringBuilder();
		for (int i = 0; i < numRows; i++) {
			if (i==0 || i==numRows-1){
				for (int j = i; j <s.length() ; j+=2*(numRows-1)) {
					sb.append(s.charAt(j));
				}
			}else {
				for (int j = i,k=2*(numRows-1); j <s.length()||k<s.length() ; j+=2*(numRows-1),k+=2*(numRows-1)) {
					if (j<s.length())sb.append(s.charAt(j));
					if (k<s.length())sb.append(s.charAt(k));
				}
			}
		}
		return sb.toString();
	}
	List<String> leetcode17=new ArrayList<>();
	String dict[]={"abc","def","ghi","jkl","mno","pqrs","tuv","wxyz"};
	public List<String> letterCombinations(String digits) {
		if (digits==null || digits.length()==0)return leetcode17;
		leetcode17Helper(digits,0,"");
		return leetcode17;
	}
	public void leetcode17Helper(String ss,int level,String s) {
		if (level==ss.length()){
			leetcode17.add(s);
		}
		char c = ss.charAt(level);
		for (int i = 0; i < dict[c - '2'].length(); i++) {
			leetcode17Helper(ss,level+1,s+dict[c-'2'].charAt(i));
		}
	}

	static boolean vis[][];
	static boolean ans=false;
	public static boolean exist(char[][] board, String word) {
		vis=new boolean[board.length][board[0].length];
		for (int i = 0; i < board.length; i++) {
			for (int j = 0; j <board[i].length; j++) {
				for (int x = 0; x <board.length ; x++) {
					Arrays.fill(vis[x],false);
				}
				leetcode79Help(board,i,j,word,0);
				if (ans)return ans;
			}
		}
		return ans;
	}
	public static void leetcode79Help(char[][] dict,int r,int l,String word,int n){
		if (n==word.length()){
			ans=true;
			return;
		}
		if (ans)return;
		if (r>=dict.length || r<0)return;
		if (l>=dict[0].length || l<0)return;

		if (vis[r][l]){
			//vis[r][l]=false;
			return;
		}
		if (dict[r][l]==word.charAt(n)){
			vis[r][l]=true;
		}else {
			vis[r][l]=false;
			return;
		}
		leetcode79Help(dict,r-1,l,word,n+1);
		leetcode79Help(dict,r,l+1,word,n+1);
		leetcode79Help(dict,r+1,l,word,n+1);
		leetcode79Help(dict,r,l-1,word,n+1);
		vis[r][l]=true;
	}
	public int dietPlanPerformance(int[] calories, int k, int lower, int upper) {
		int ans[]=new int[calories.length+1];
		ans[0]=0;
		for(int i=1;i<=calories.length;i++){
			ans[i]=ans[i-1]+calories[i-1];
		}
		int res=0;
		for (int i = k; i < ans.length; i++) {
			if (ans[i]-ans[i-k]>upper){
				res++;
			}else if (ans[i]-ans[i-k]<lower){
				res--;
			}
		}
		return res;
	}
	public static List<Boolean> canMakePaliQueries(String s, int[][] queries) {
		List<Boolean> ans = new ArrayList<>();
		int dict[][]=new int[s.length()+1][26];
		for (int i = 1; i <= s.length(); i++) {
			for (int j = 0; j <26 ; j++) {
				dict[i][j]=dict[i-1][j];
			}
			dict[i][s.charAt(i-1)-'a']++;
		}
		for (int i = 0; i < queries.length; i++) {
			int flag=0;
			for (int j = 0; j < 26; j++) {
				if (dict[queries[i][1]+1][j]-dict[queries[i][0]][j]!=0&& (dict[queries[i][1]+1][j]-dict[queries[i][0]][j])%2!=0){
					flag++;
				}
			}
			if (flag-(queries[i][2]*2)>1){
				ans.add(false);
			}else ans.add(true);
		}
		return ans;
	}
	static Set<List<Integer>> leetCode46Ans=new HashSet<>();
	static List<Integer> st=new ArrayList<>();
	static boolean visd[];
	public static List<List<Integer>> permute(int[] nums) {
		visd=new boolean[nums.length];
		dfsLeetCode46(nums,0);
		List<List<Integer>> ans=new ArrayList<>();
		leetCode46Ans.forEach(integers -> ans.add(integers));
		return ans;
	}
	public static void dfsLeetCode46(int[] nums,int n){
		if (n==nums.length){
			List<Integer> temp=new ArrayList<>();
			for (int i = 0; i < st.size(); i++) {
				temp.add(st.get(i));
			}
			leetCode46Ans.add(temp);
		}
		for (int i = 0; i < nums.length; i++) {
			if (!visd[i]){
				visd[i]=true;
				st.add(nums[i]);
				dfsLeetCode46(nums,n+1);
				visd[i]=false;
				st.remove(st.size()-1);
			}

		}
	}
	public List<List<Integer>> subsets(int[] nums) {
		List<List<Integer>> ans=new ArrayList<>();
		int end=(int)Math.pow(2,nums.length);
		for (int i = 0; i < end; i++) {
			List<Integer> temp=new ArrayList<>();
			for (int j = 0; j <nums.length; j++) {
				int d=i>>j&1;
				if (d==1){
					temp.add(nums[j]);
				}
			}
			ans.add(temp);
		}
		return ans;
	}
	static List<Integer> temp=new ArrayList<>();
	static List<List<Integer>> lists =new ArrayList<>();
	public static List<List<Integer>> subsets78(int[] nums) {

		dfs78(nums,0);
		return lists;
	}
	static void dfs78(int nums[],int n){
		if (nums.length==n){
			List<Integer> d=new ArrayList<>();
			for (int i = 0; i < temp.size(); i++) {
				d.add(temp.get(i));
			}
			lists.add(d);
			return;
		}
		temp.add(nums[n]);
		dfs78(nums, n + 1);
		temp.remove(temp.size()-1);
		dfs78(nums, n + 1);
	}
	public int[] sortedSquares(int[] A) {
		for (int i = 0; i < A.length; i++) {
			A[i]*=A[i];
		}
		Arrays.sort(A);
		return A;
	}
	public static int maxTurbulenceSize(int[] A) {
		if (A.length<=1)return A.length;
		int n=A.length;
		boolean flag=true;
		int max=0;
		for (int i = 0; i <n ; i++) {
			int m=1;
			flag=true;
			for (int j = i; j < n - 1; j++) {
				if (flag){
					if (A[j]>A[j+1]){
						flag=!flag;
						m++;
					}else break;
				}else {
					if (A[j]<A[j+1]){
						flag=!flag;
						m++;
					}else break;
				}
			}
			if (max<m){
				max=m;
			}
		}
		for (int i = 0; i <n ; i++) {
			int m=1;
			flag=false;
			for (int j = i; j < n - 1; j++) {
				if (flag){
					if (A[j]>A[j+1]){
						flag=!flag;
						m++;
					}else break;
				}else {
					if (A[j]<A[j+1]){
						flag=!flag;
						m++;
					}else break;
				}
			}
			if (max<m){
				max=m;
			}
		}
		return max;
	}
	int ans979=0;
	public int distributeCoins(TreeNode root) {
		dfs979(root,null);
		return ans979;
	}
	// 利用自底向上的dfs,每当子节点的数不为1时,操作使得父节点相应增加减少,并把操作的值记录到结果中
	public void dfs979(TreeNode root,TreeNode parent){
		if (root==null)return;
		dfs979(root.left,root);
		dfs979(root.right,root);
		if (root.val<=0){
			parent.val+=(root.val-1);
			ans979+=-(root.val-1);
			root.val=1;
		}
		if (root.val>1){
			parent.val+=(root.val-1);
			ans979+=(root.val-1);
			root.val=1;
		}
	}

	public int largestSumAfterKNegations(int[] A, int K) {
		Arrays.sort(A);
		while (K>0){
			A[0]=-A[0];
			Arrays.sort(A);
			K--;
		}
		int ans=0;
		for (int i = 0; i < A.length; i++) {
			ans+=A[i];
		}
		return ans;
	}
	public static int clumsy(int N) {
		int ans=0;
		Stack<Integer> stack=new Stack<>();
		Stack<Character> pot=new Stack<>();
		for (int i = 0; i <N-1; i++) {
			if (i%4==0){
				stack.push(N-i);
				int c=stack.pop();
				stack.push(c*(N-i-1));
			}else if (i%4==1){
				int c=stack.pop();
				stack.push(c/(N-i-1));
			}else if (i%4==2){
				pot.push('+');
			}else {
				stack.push(N-i);
				pot.push('-');
			}
		}
		if (stack.size()==pot.size())stack.push(1);
		Stack<Integer> s1=new Stack<>();
		Stack<Character> s2=new Stack<>();
		while (stack.size()>0)s1.push(stack.pop());
		while (pot.size()>0)s2.push(pot.pop());
		while (s2.size()>0){
			int t1=s1.pop();
			int t2=s1.pop();
			if (s2.peek()=='+'){
				s2.pop();
				s1.push(t1+t2);
			}else if (s2.peek()=='-'){
				s2.pop();
				s1.push(t1-t2);
			}
		}
		return s1.peek();
	}
	public static int minDominoRotations(int[] A, int[] B) {
		int count=0;
		int ans=0;
		int c=A.length;
		int flag1=0;
		int flag2=0;
		for (int i = 1; i <=6; i++) {
			count=0;
			flag1=0;
			flag2=0;
			for (int j = 0; j < A.length; j++) {
				if (A[j]==i||B[j]==i){
					count++;
					if (A[j]==i && B[j]!=i){
						flag1++;
					}else if (A[j]!=i && B[j]==i){
						flag2++;
					}
				}else break;
			}
			if (count==A.length){
				ans=1;
				int d=Math.min(flag1,flag2);
				if (c>d)c=d;
			}
		}
		return ans==0?-1:c;
	}
	public static TreeNode bstFromPreorder(int[] preorder) {
		if (preorder.length==0)return null;
		TreeNode root=new TreeNode(preorder[0]);
		int flag1=0;
		int flag2=0;
		for (int i = 1; i <preorder.length ; i++) {
			if (preorder[0]>preorder[i]){
				flag1++;
			}else flag2++;
		}
		int l[]=new int[flag1];
		int r[]=new int[flag2];
		flag1=0;
		flag2=0;
		for (int i = 1; i <preorder.length ; i++) {
			if (preorder[0]>preorder[i]){
				l[flag1++]=preorder[i];
			}else r[flag2++]=preorder[i];
		}
		root.left=bstFromPreorder(l);
		root.right=bstFromPreorder(r);
		return root;
	}
	public static void dfs1008(int preorder[],TreeNode root,int n){
		if (n>=preorder.length)return;
		if (root.val>preorder[n]){
			root.left=new TreeNode(preorder[n]);
		}else root.right=new TreeNode(preorder[n]);
		if (++n>=preorder.length)return;
		if (root.val>preorder[n] && root.left==null){
			root.left=new TreeNode(preorder[n]);
		}else if (root.val<preorder[n] && root.right==null)root.right=new TreeNode(preorder[n]);
		if (root.left!=null)
			dfs1008(preorder,root.left,n+1);
		if (root.right!=null)
			dfs1008(preorder,root.right,n+1);
	}
	public boolean hasGroupsSizeX(int[] deck) {
		int dict[]=new int[10050];
		for (int i = 0; i < deck.length; i++) {
			dict[deck[i]]++;
		}
		for (int i = 2; i < dict.length; i++) {
			int flag=0;
			for (int j = 0; j < dict.length; j++) {
				if (dict[j]!=0 && dict[j]%i!=0){
					flag=1;
					break;
				}
			}
			if (flag==0)return true;
		}
		return false;
	}
	public int partitionDisjoint(int[] A) {
		int max=A[0];
		for (int i = 0; i <A.length ; i++) {
			int flag =0;
			max=Math.max(max,A[i]);
			for (int j =i+1; j <A.length;j++) {
				if (max>A[j]){
					flag=1;
					break;
				}
			}
			if (flag==0)return i+1;
		}
		return 1;
	}
	public static List<String> wordSubsets(String[] A, String[] B) {
		List<String> ans=new ArrayList<>();
		int d[][]=new int[B.length][26];
		Map<String,int[]> dict=new HashMap<>();
		for (int i = 0; i < A.length; i++) {
			int temp[]=new int[26];
			for (int j = 0; j < A[i].length(); j++) {
				temp[A[i].charAt(j)-'a']++;
			}
			dict.put(A[i],temp);
		}
		int finD[]=new int[26];
		for (int i = 0; i < B.length; i++) {
			for (int j = 0; j < B[i].length(); j++) {
				d[i][B[i].charAt(j)-'a']++;
			}
			for (int j = 0; j < 26; j++) {
				if (d[i][j]>finD[j])finD[j]=d[i][j];
			}
		}
		dict.forEach((k,v)->{
			int flag=0;
			for (int l = 0; l < 26; l++) {
				if (finD[l]>v[l]){
					flag=1;
					break;
				}
			}
			if (flag==0)ans.add(k);
		});
		return ans;
	}
	public static int numPrimeArrangements(int n) {
		int perm=0;
		int m=1000000007;
		for (int i = 2; i <=n ; i++) {
			int flag=0;
			for (int j = 2; j <=Math.sqrt(i) ; j++) {
				if (i%j==0){
					flag=1;
					break;
				}
			}
			if (flag==0)perm++;
		}
		long ans=1;
		for (int i = 1; i <=perm; i++) {
			ans=(ans*i)%m;
		}
		for (int i = 1; i <=n-perm; i++) {
			ans=(ans*i)%m;
		}
		return (int)ans;

	}
	public static String dayOfTheWeek(int day, int month, int year) {
		SimpleDateFormat f = new SimpleDateFormat("yyyy-MM-dd");
		String[] weekDays = {"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"};
		Calendar cal = Calendar.getInstance();
		Date date;
		try {
			date = f.parse(year+"-"+month+"-"+day);
			cal.setTime(date);
		} catch (ParseException e) {
			e.printStackTrace();
		}
		int w = cal.get(Calendar.DAY_OF_WEEK) - 1;
		if (w < 0)
			w = 0;
		return weekDays[w];
	}
	public static int maximumSum(int[] arr) {
		int n=arr.length;
		long sumA[]=new long[n];
		sumA[0]=arr[0];
		long sumS[]=new long[n];
		sumS[0]=Integer.MIN_VALUE;
		int ans=arr[0];
		for (int i = 1; i < n; i++) {
			sumA[i]=Math.max(sumA[i-1]+arr[i],arr[i]);
			sumS[i]=Math.max(sumS[i-1]+arr[i],sumA[i-1]);
			ans=Math.max((int)Math.max(sumA[i],sumS[i]),ans);
		}
		return ans;
	}
	// leetcode 1189
	public int maxNumberOfBalloons(String text) {
		int ans=0;
		int dict[]=new int[5];
		int d[]=new int[5];
		d[0]=1;//a
		d[1]=1;//b
		d[2]=2;//l
		d[3]=2;//o
		d[4]=1;//n
		for (int i = 0; i < text.length(); i++) {
			if (text.charAt(i)=='a')dict[0]++;
			else if (text.charAt(i)=='b')dict[1]++;
			else if (text.charAt(i)=='l')dict[2]++;
			else if (text.charAt(i)=='o')dict[3]++;
			else if (text.charAt(i)=='n')dict[4]++;
		}
		ans=dict[0];
		for (int i = 1; i < 5; i++) {
			ans=Math.min(dict[i]/d[i],ans);
		}
		return ans;
	}
	// leetcode 1190
	public static String reverseParentheses(String s) {
		StringBuilder ans=new StringBuilder();
		Deque<Character> stack=new ArrayDeque<>();
		//List<Character> collect = stack.stream().collect(Collectors.toList());
		for (int i = 0; i < s.length(); i++) {
			if (s.charAt(i)!='('){
				ans.append(s.charAt(i));
			}else {
				stack.add(s.charAt(i));
				while (!stack.isEmpty()|| s.charAt(i)!=')'){
					i++;
					if (i>=s.length())break;
					if (s.charAt(i)==')'){
						Deque<Character> temp=new ArrayDeque<>();
						while (stack.peek()!='('){
							temp.addFirst(stack.pop());
						}
						if (stack.peek()=='(')stack.pop();
						while (!temp.isEmpty())stack.push(temp.removeLast());
					}else {
						stack.push(s.charAt(i));
					}
				}
				if (!stack.isEmpty())while (!stack.isEmpty())ans.append(stack.removeLast());
			}
		}
		return ans.toString();
	}
	// leetcode 1191
	public static int kConcatenationMaxSum(int[] arr, int k) {
		long ans = 0;
		int n=arr.length;
		long sum = 0;
		for (int i = 0; i < n; i++) sum+=arr[i];
		int lmx=0,rmx=0,temp=0;
		for (int i = 0; i < n ; i++) {
			temp+=arr[i];
			lmx=Math.max(temp,lmx);
		}
		temp=0;
		for (int i = n-1; i >=0 ; i--) {
			temp+=arr[i];
			rmx=Math.max(temp,rmx);
		}
		temp=0;
		for (int i = 0; i <n ; i++) {
			temp+=arr[i];
			ans=Math.max(ans,temp);
			if (temp<=0){
				temp=0;
			}
		}
		if (k==1)return (int)ans%1000000007; //当k=0时，直接利用遍历的结果返回最大值
		ans=Math.max(ans,sum*k%1000000007);// 第一种情况，返回扩展后数组的∑
		ans=Math.max(ans,(sum*(k-1))%1000000007+lmx); // 返回k-1段数组+左边最大值
		ans=Math.max(ans,(sum*(k-1))%1000000007+rmx); // 返回k-1段数组+右边最大值
		ans=Math.max(ans,(sum*(k-2))%1000000007+rmx+lmx); // 返回k-2段数组+右边最大值+左边最大值
		ans=Math.max(ans,lmx+rmx); // 返回左边+右边最大值
		return (int)ans%1000000007;
	}
	static final int tableSizeFor(int cap) {
		// ^异或^^相同为0 不同为1
		int n = cap - 1;
		n |= n >>> 1;
		n |= n >>> 2;
		n |= n >>> 4;
		n |= n >>> 8;
		n |= n >>> 16;
		return (n < 0) ? 1 : (n >= 288) ? 288 : n + 1;
	}
	public static void testHashMap(){
		Map<String,String> map=new HashMap<>();
		map.put("s1","s2");
		System.out.println(map.get("s1"));
		System.out.println(map.get("s2"));
		System.out.println(map.size());
		char s = '\u0639';
		System.out.println(s);
	}
	// leetcode 1080
	public TreeNode sufficientSubset(TreeNode root, int limit) {
		return dfs1080(root,limit,0);
	}
	public TreeNode dfs1080(TreeNode root,int limit,int now){
		if (root==null)return root;
		if (root.right==null && root.left==null){
			if ((now+root.val)<limit)return null;
			return root;
		}
		root.left=dfs1080(root.left,limit,root.val+now);
		root.right=dfs1080(root.right,limit,root.val+now);
		if (root.right==null && root.left==null)return null;
		return root;
	}
	// leetcode 1034
	/*boolean visd1034[][];
	public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {
		visd1034=new boolean[grid.length][grid[0].length];
		return dfs1034(grid,r0,c0,color);
	}
	public int[][] dfs1034(int[][] grid,int r0,int c0,int color){
		if (r0>=grid.length || r0<0 || c0>=grid[0].length || c0<0 )return

	}*/
	// leetcode 494 dp
	public static int findTargetSumWays(int[] nums, int S) {
		int ans=0;
		int sum=0;
		for (int i = 0; i < nums.length; i++) {
			sum+=nums[i];
		}
		int dp[][]=new int[nums.length+1][sum*2+1];
		dp[0][sum]=1;
		for (int i = 0; i < nums.length; i++) {
			for (int j = nums[i]; j <= 2*sum -nums[i]; j++) {
				dp[i+1][j+nums[i]]+=dp[i][j];
				dp[i+1][j-nums[i]]+=dp[i][j];
			}
		}
		return dp[nums.length][S+sum];
	}
	// leetcode 494 dfs


	public List<List<Integer>> minimumAbsDifference(int[] arr) {
		List<List<Integer>> ans =new ArrayList<>();
		Arrays.sort(arr);
		int flag= Integer.MAX_VALUE;
		for (int i = 0; i < arr.length - 1; i++) {
			flag=Math.min(Math.abs(arr[i]-arr[i+1]),flag);
		}
		for (int i = 0; i < arr.length - 1; i++) {
			if (Math.abs(arr[i]-arr[i+1])==flag){
				List<Integer> temp=new ArrayList<>();
				temp.add(arr[i]);
				temp.add(arr[i+1]);
				ans.add(temp);
			}
		}
		return ans;
	}
	public static int nthUglyNumber3(int n, int a, int b, int c) {
		long l=1;
		long r=Integer.MAX_VALUE;
		while (l<r){
			long mid=(l+r)>>>1;
			long count=mid/a;
			count+=mid/b;
			count+=mid/c;
			count-=mid/((long) a*b/gcd((long)a,b));
			count-=mid/((long)a*c/gcd((long)a,c));
			count-=mid/((long)b*c/gcd((long)b,c));
			long temp=((long)a*b/gcd((long)a,b));
			//if (temp==0)temp=1;
			count+=mid/((long)temp*c/gcd(c,temp));
			if (count<n){
				l=mid+1;
			}else r=mid;
		}
		return (int)r;
	}
	public static long gcd(long a,long b){
		if (b==0)return a;
		return gcd(b,a%b);
	}
	/*List<Integer>nums=new ArrayList<>();
		int begin=1;
		int indexA=0,indexB=0,indexC=0;
		nums.add(1);
		while (begin<=n){
			nums.add(Math.min(nums.get(indexA)*a,Math.min(nums.get(indexB)*b,nums.get(indexC)*c)));
			if (nums.get(begin)==nums.get(indexA)*a)indexA++;
			if (nums.get(begin)==nums.get(indexB)*b)indexB++;
			if (nums.get(begin)==nums.get(indexC)*c)indexC++;
			begin++;
		}
		return nums.get(n);*/

	/*public String smallestStringWithSwaps(String s, List<List<Integer>> pairs) {
		StringBuilder sb=new StringBuilder(s);

		for (int i = 0; i < pairs.size();i++) {
			pairs.get(i).get(0);
			pairs.get(i).get(1);
		}
	}*/
	public boolean uniqueOccurrences(int[] arr) {
		int dict[]=new int[2050];
		for (int i = 0; i < arr.length; i++) {
			dict[arr[i]+1000]++;
		}
		Arrays.sort(dict);
		for (int i = dict.length-1; i >0 ; i--) {
			if (dict[i]==0)continue;
			if (dict[i]==dict[i-1]){
				return false;
			}
		}
		return true;
	}
	public static int equalSubstring(String s, String t, int maxCost) {
		int dict[]=new int[s.length()];
		for (int i = 0; i < s.length(); i++) {
			dict[i]=Math.abs(s.charAt(i)-t.charAt(i));
		}
		//Arrays.sort(dict);
		int max=0,min=0;
		int temp=0;
		int ans=0;
		int start=0,end=0;
		while (min<=max&&max<s.length()){
			temp+=dict[max++];
			if (temp>maxCost)
				temp-=dict[min++];
			ans=Math.max(max-min,ans);
		}
		return ans;
	}
	public static String removeDuplicates(String s, int k) {
		//Stack<Character> stack=new Stack<>();
		StringBuilder sb=new StringBuilder(s);
		int flag=1;
		while(flag==1){
			flag=0;
			for (int i = 0; i < s.length(); i++) {
				int start=i,end=i;
				while (i+1<s.length() &&s.charAt(i)==s.charAt(i+1)){
					end++;
					i++;
				}
				if ((end-start+1)%k==0){
					flag=1;
					StringBuilder sb1=new StringBuilder();
					for (int j = start; j <=end; j++) {
						sb1.append(" ");
					}
					sb.replace(start,end+1,sb1.toString());
				}else if (end-start+1>k){
					int i1 = (end - start + 1) / k;
					end=start+i1*k-1;
					flag=1;
					StringBuilder sb1=new StringBuilder();
					for (int j = start; j <=end; j++) {
						sb1.append(" ");
					}
					sb.replace(start,end+1,sb1.toString());
				}
			}
			s=sb.toString();
			String replace = s.replace(" ", "");
			sb=new StringBuilder(replace);
			s=replace;
		}
		return s;
	}
	public static int longestSubsequence(int[] arr, int difference) {
		Map<Integer,Integer> dp = new HashMap<>();
		int ans=0;
		for (int i = 0; i < arr.length; i++) {
			int cur=Math.max(dp.containsKey(arr[i])?dp.get(arr[i]):0,(dp.containsKey(arr[i]-difference)?dp.get(arr[i]-difference):0)+1);
			dp.put(arr[i],cur);
			ans=Math.max(ans,cur);
		}
		return ans;
	}
	boolean vis5215[][];
	int code=0;
	public int getMaximumGold(int[][] grid) {
		vis5215 = new boolean[grid.length][grid[0].length];
		int max=0;
		for (int i = 0; i < grid.length; i++) {
			for (int j = 0; j < grid[0].length; j++) {
				if (grid[i][j]==0)continue;
				dfs5215(grid,i,j,0);
			}
		}
		return code;
	}
	public void dfs5215(int[][] grid,int r,int l,int cur){
		if (r>=grid.length || l>=grid[0].length || r<0 ||l<0){
			code=Math.max(code,cur);
			return;
		}
		if (grid[r][l]==0){
			code=Math.max(code,cur);
			return;
		}
		if (vis5215[r][l]){
			code=Math.max(code,cur);
			return;
		}
		cur+=grid[r][l];
		code=Math.max(code,cur);
		vis5215[r][l]=true;
		dfs5215(grid,r-1,l,cur);
		dfs5215(grid,r,l-1,cur);
		dfs5215(grid,r+1,l,cur);
		dfs5215(grid,r,l+1,cur);
		vis5215[r][l]=false;
	}
	public int minCostToMoveChips(int[] chips) {
		int cnt[]=new int[2];
		for (int chip : chips) {
			cnt[chip&1]++;
		}
		return Math.min(cnt[0],cnt[1]);
	}
	String dict5216[]={"ae", "ea", "ei", "ia", "ie", "io", "iu", "oi", "ou","ua"};
	public int countVowelPermutation(int n) {
		if (n==1)return 5;
		// a3 e2 i2 o1 u2
		long dp[] = new long[5];
		Arrays.fill(dp,1);
		long temp[] = new long[5];
		for (int i = 1; i < n; i++) {
			temp[0]=(dp[1]+dp[2]+dp[4])%(1000000000+7);
			temp[1]=(dp[0]+dp[2])%(1000000000+7);
			temp[2]=(dp[1]+dp[3])%(1000000000+7);
			temp[3]=(dp[2])%(1000000000+7);
			temp[4]=(dp[2]+dp[3])%(1000000000+7);
			for (int j = 0; j < 5; j++) {
				dp[j]=temp[j];
			}
		}
		long ans=0;
		for (int i = 0; i < 5; i++) {
			ans=(ans+temp[i])%(1000000000+7);
		}

		return (int)ans;
	}
	public int maxArea(int[] height) {
		int L=0,R=height.length-1;
		int ans=0;
		/* 暴力法O(n^2)
		for (int i = 0; i < height.length; i++) {
			for (int j = i; j < height.length; j++) {
				ans=Math.max(Math.min(height[i],height[j])*(j-i),ans);
			}
		}*/
		// 双指针
		while (L!=R){
			ans=Math.max(ans,Math.min(height[L],height[R])*(R-L));
			if (height[L]>height[R])R++; else L++;
		}
		return ans;
	}
	public static List<List<Integer>> threeSum(int[] nums) {
		Set<List<Integer>> ans =new HashSet<>();
		HashMap<Integer,Integer> dict = new HashMap<>();
		for (int num : nums) {
			if (!dict.containsKey(num)){
				dict.put(num,1);
			}else {
				dict.put(num,dict.get(num)+1);
			}
		}
		// 326ms
		Set<Integer> set = dict.keySet();
		List<Integer> collect = set.stream().collect(Collectors.toList());
		for (int i = 0; i < collect.size(); i++) {
			int get = collect.get(i);
			if (dict.get(get)>1){
				int ditt = -(get*2);
				if (!dict.containsKey(ditt)){
					int k = dict.get(ditt);
					if (ditt == get ){
						if (k>=3){
							List<Integer> tt = Arrays.asList(ditt,ditt,ditt);
							Collections.sort(tt);
							ans.add(tt);
						}
					}else {
						List<Integer> tt = Arrays.asList(ditt,get,get);
						Collections.sort(tt);
						ans.add(tt);
					}
				}
			}
			for (int j = i+1; j < collect.size(); j++) {
				int temp = -(collect.get(i)+collect.get(j));
				if (!dict.containsKey(temp)) continue;
				int k = dict.get(temp);
				if (collect.get(i)==temp)k--;
				if (collect.get(j)==temp)k--;
				if (k>0){
					List<Integer> tt = Arrays.asList(temp,collect.get(i),collect.get(j));
					Collections.sort(tt);
					ans.add(tt);
				}
			}
		}
		return ans.stream().collect(Collectors.toList());
	}
	public static int longestSubstring(String s, int k) {
		int max=0;
		int dict[]=new int[26];
		for (char a: s.toCharArray() ) {
			dict[a-'a']++;
		}
		boolean full = true;
		for (int i = 0; i < 26; i++) {
			if (dict[i]>0 &&dict[i]<k) full=false;
		}
		if (full)return s.length();
		int end=0,start=0;
		while (end<s.length()){
			if (dict[s.charAt(end)-'a']<k){
				max=Math.max(max,longestSubstring(s.substring(start,end),k));
				start=end+1;
			}
			end++;
		}
		max=Math.max(max,longestSubstring(s.substring(start),k));
		return max;
	}
	public static double findMedianSortedArrays(int[] nums1, int[] nums2) {
		int n = (nums1.length+nums2.length)%2;
		List<Integer> attr = new ArrayList<>();
		if (n==1){
			attr.add((nums1.length+nums2.length)/2);
		}else {
			attr.add((nums1.length+nums2.length)/2);
			attr.add((nums1.length+nums2.length)/2+1);
		}
		int L=0,R=0,count=0;
		List<Integer> ans =new ArrayList<>();
		while (L<nums1.length || R<nums2.length){
			count++;
			if (L<nums1.length && R<nums2.length){
				if (nums1[L]<nums2[R]){
					if (attr.contains(count)){
						ans.add(nums1[L]);
					}
					L++;
				}else {
					if (attr.contains(count)){
						ans.add(nums2[R]);
					}
					R++;
				}
			}else {
				if (L>=nums1.length){
					if (attr.contains(count)){
						ans.add(nums2[R]);
					}
					R++;
				}else {
					if (attr.contains(count)) {
						ans.add(nums1[L]);
					}
					L++;
				}
			}
		}
		System.out.println(ans);
		if (n==1)return ans.get(0);
		else return (ans.get(0)+ans.get(1))*1.0/2;
	}
	public boolean canJump(int[] nums) {
		if (nums.length<=1)return true;
		if (nums[0]==0)return false;
		int check[] = new int[nums.length];
		check[nums.length-1]=1;
		for (int i = nums.length-1; i >=0 ; i--) {
			for (int j = nums[i]; j >=1 ; j--) {
				if (i+j<nums.length && check[i+j]==1){
					check[i]=1;
					break;
				}
			}
		}
		return check[0]==1?true:false;
		/*
		* if (nums.length<=1)return true;
		if (nums[0]==0)return false;
		int end = nums.length-1;
        for (int i=nums.length-1; i>=0 ; i--){
            if(i+nums[i]>=end){
                end=i;
            }
        }
        return end==0;
		*
		*
		* */
	}
	public static void setZeroes(int[][] matrix) {
		Map<Integer,List<Integer>> dict = new HashMap<>();
		for (int i = 0; i < matrix.length; i++) {
			for (int j = 0; j < matrix[0].length; j++) {
				if (matrix[i][j]==0){
					if (dict.containsKey(i)){
						dict.get(i).add(j);
					}else {
						List<Integer> list =new ArrayList<>();
						list.add(j);
						dict.put(i,list);
					}
				}
			}
		}
		dict.forEach((k,v)->{
			Arrays.fill(matrix[k],0);
			v.forEach(pageNum -> {
				for (int i = 0; i < matrix.length; i++) {
					matrix[i][pageNum]=0;
				}
			});
		});
	}
	public boolean isPalindrome(String s) {
		StringBuilder s1= new StringBuilder();
		StringBuilder s2= new StringBuilder();
		String s3 = s.toUpperCase();
		int n =s3.length();
		for (int i = 0; i < n; i++) {
			if (s3.charAt(i)>='A' && s3.charAt(i)<='Z' || s3.charAt(i)>='0' && s3.charAt(i)<='9'){
				s1.append(s3.charAt(i));
			}
			if (s3.charAt(n-1-i)>='A' && s3.charAt(n-1-i)<='Z' || s3.charAt(n-1-i)>='0' && s3.charAt(n-1-i)<='9'){
				s2.append(s3.charAt(n-1-i));
			}
		}
		return s1.toString().equals(s2.toString())?true:false;
	}
	public int canCompleteCircuit(int[] gas, int[] cost) {
		int n = gas.length;
		int dit[] = new int[n];
		for (int i = 0; i < n; i++) {
			dit[i]=gas[i]-cost[i];
		}
		int ans = 0;
		int jh = 0;
		int flag = 0;
		boolean can = true;
		while (flag<n){
			jh=0;
			can = true;
			ans=flag;
			while (ans<n && can ==true){
				jh+=dit[ans++];
          				if (jh<0) {
					can=false;
				}
			}
			ans =0;
			while (ans<flag && can ==true){
				jh+=dit[ans++];
				if (jh<0) {
					can=false;
				}
			}
			if (can)return flag;
			flag++;
		}
		return -1;
	}
	/*
	* leetcode week 158
	* */
	public int balancedStringSplit(String s) {
		int a = 0;
		int ans=0;
		for (int i = 0; i < s.length(); i++) {
			if (s.charAt(i)=='L')a--;
			else if (s.charAt(i)=='R')a++;
			if (a==0)ans++;
		}
		return ans;
	}
	public List<List<Integer>> queensAttacktheKing(int[][] queens, int[] king) {
		List<List<Integer>> ans = new ArrayList<>();
		List<Integer> dict = new ArrayList<>();
		for (int i = 0; i < queens.length; i++) {
			int t=0;
			for (int j = 0; j < queens[i].length; j++) {
				t=t*10+queens[i][j];
			}
			dict.add(t);
		}
		int L=king[0],R=king[1];
		// 右边
		int tL=L,tR=R+1;
		while (tL>=0 && tL<8 && tR>=0 && tR<8){
			if (dict.contains(tL*10+tR)){
				List<Integer> temp = new ArrayList<>();
				temp.add(tL);
				temp.add(tR);
				ans.add(temp);
				break;
			}
			tR++;
		}
		// 左边
		tL=L;tR=R-1;
		while (tL>=0 && tL<8 && tR>=0 && tR<8){
			if (dict.contains(tL*10+tR)){
				List<Integer> temp = new ArrayList<>();
				temp.add(tL);
				temp.add(tR);
				ans.add(temp);
				break;
			}
			tR--;
		}
		// 上边
		tL=L-1;tR=R;
		while (tL>=0 && tL<8 && tR>=0 && tR<8){
			if (dict.contains(tL*10+tR)){
				List<Integer> temp = new ArrayList<>();
				temp.add(tL);
				temp.add(tR);
				ans.add(temp);
				break;
			}
			tL--;
		}
		// 下边
		tL=L+1;tR=R;
		while (tL>=0 && tL<8 && tR>=0 && tR<8){
			if (dict.contains(tL*10+tR)){
				List<Integer> temp = new ArrayList<>();
				temp.add(tL);
				temp.add(tR);
				ans.add(temp);
				break;
			}
			tL++;
		}
		// 左上
		tL=L-1;tR=R-1;
		while (tL>=0 && tL<8 && tR>=0 && tR<8){
			if (dict.contains(tL*10+tR)){
				List<Integer> temp = new ArrayList<>();
				temp.add(tL);
				temp.add(tR);
				ans.add(temp);
				break;
			}
			tL--;
			tR--;
		}
		// 右上
		tL=L-1;tR=R+1;
		while (tL>=0 && tL<8 && tR>=0 && tR<8){
			if (dict.contains(tL*10+tR)){
				List<Integer> temp = new ArrayList<>();
				temp.add(tL);
				temp.add(tR);
				ans.add(temp);
				break;
			}
			tL--;
			tR++;
		}
		// 左下
		tL=L+1;tR=R-1;
		while (tL>=0 && tL<8 && tR>=0 && tR<8){
			if (dict.contains(tL*10+tR)){
				List<Integer> temp = new ArrayList<>();
				temp.add(tL);
				temp.add(tR);
				ans.add(temp);
				break;
			}
			tL++;
			tR--;
		}
		// 右下
		tL=L+1;tR=R+1;
		while (tL>=0 && tL<8 && tR>=0 && tR<8){
			if (dict.contains(tL*10+tR)){
				List<Integer> temp = new ArrayList<>();
				temp.add(tL);
				temp.add(tR);
				ans.add(temp);
				break;
			}
			tL++;
			tR++;
		}
		return ans;
	}
	public int dieSimulator(int n, int[] rollMax) {
		long mod = 1000000000+7;
		long dp[][][] = new long[n+1][6][20];
		for (int i = 0; i < 6; i++) {
			dp[0][i][1]=1;
		}
		for (int i = 1; i < n; i++) {
			for (int j = 0; j < 6; j++) {
				for (int k = 0; k < 6; k++) {
					if (k==j){
						for (int l = 1; l < rollMax[k] ; l++) {
							dp[i][j][l+1]+=dp[i-1][k][l];
							dp[i][j][l+1]%=mod;
						}
					}else {
						for (int l = 1; l <= rollMax[k] ; l++) {
							dp[i][j][1]+=dp[i-1][k][l];
							dp[i][j][1]%=mod;
						}
					}
				}
			}
		}
		int res=0;
		for (int i = 0; i < 6; i++) {
			for (int j = 1; j <= rollMax[i] ; j++) {
				res+=dp[n-1][i][j];
				res%=mod;
			}
		}
		return res;
	}
	public int ugly2(int n){
		int index2=0;
		int index3=0;
		int index5=0;
		int dp[] = new int[n+1];
		dp[0]=1;
		int i=1;
		// 也就是说每个丑数都能以他们的底为基准，乘上2,3,5
		while (i<n){
			dp[i]=Math.min(Math.min(dp[index2]*2,dp[index3]*3),dp[index5]*5);
			if (dp[i]==dp[index2]*2)index2++;
			if (dp[i]==dp[index3]*3)index3++;
			if (dp[i]==dp[index5]*5)index5++;
			i++;
		}
		return dp[n-1];
	}
	public int SuperUgly(int n,int[] primes){
		int index[] = new int[primes.length];
		int dp[] = new int[n+1];
		dp[0]=1;
		int i=1;
		while (i<n){
			int min = dp[index[0]]*primes[0];
			for (int j = 0; j < primes.length; j++) {
				dp[i]=Math.min(dp[index[j]]*primes[i],min);
			}
			for (int j = 0; j < primes.length; j++) {
				if (dp[i]==dp[j]*primes[j])index[j]++;
			}
			i++;
		}
		return dp[n-1];
	}
	/*
	格雷码+位运算！！！没思路
	Set<Integer> set5239 = new HashSet<>();
	List<Integer> res5239 = new ArrayList<>();
	public List<Integer> circularPermutation(int n, int start) {
		set5239.add(start);
		res5239.add(start);
		dfs5239(n,start);
		return res5239;
	}
	boolean dfs5239(int n,int cur){
		if (res5239.size()==(1<<n)){
			int temp = res5239.get(0)^cur;
			return (temp^(temp-1))==0;
		}
		for (int i = 0; i < n; i++) {
			if (set5239.contains(cur^i<<1)){
				set5239.add(cur>>i&1);
				res5239.add(cur>>i&1);

			}
		}


		return false;
	}*/



	int[] dict5240 =new int[26];
	int ans5240=0;
	public int maxLength(List<String> arr) {
		dfs5240(arr,0,0);
		return ans5240;
	}
	public void dfs5240(List<String> arr,int i,int cost){
		ans5240=Math.max(ans5240,cost);
		if (i>=arr.size()){
			return;
		}
		// not
		dfs5240(arr,i+1,cost);
		for (int j = 0; j <arr.get(i).length(); j++) {
			dict5240[arr.get(i).charAt(j)-'a']++;
		}
		boolean flag=true;
		for (int j = 0; j < 26; j++) {
			if (dict5240[j]>1){
				flag=false;break;
			}
		}
		if (flag) {
			cost += arr.get(i).length();
			// Choice
			dfs5240(arr, i + 1, cost);
		}
		for (int j = 0; j <arr.get(i).length(); j++) {
			dict5240[arr.get(i).charAt(j)-'a']--;
		}
	}
	List<String> res22 = new ArrayList<>();
	public List<String> generateParenthesis(int n) {
		dfs22(0,n*2,new StringBuilder());
		return res22;
	}
	public void dfs22(int leftCnt,int n,StringBuilder sb){
		if (n==sb.length()){
			res22.add(sb.toString());
			return;
		}
		if (leftCnt>0){
			sb.append(')');
			dfs22(leftCnt-1,n,sb);
			sb.deleteCharAt(sb.length()-1);
		}
		if (n-sb.length()>leftCnt){
			sb.append('(');
			dfs22(leftCnt+1,n,sb);
			sb.deleteCharAt(sb.length()-1);
		}
	}
	public String longestPalindrome123(String s) {
		int n = s.length();
		boolean dp[][] = new boolean[n+2][n+2];
		dp[0][0]=true;
		int left=-1,right=-1;
		int max=1;//最好遍历左下半边（先遍历高边界而不是低边界，这样才能够正常遍历）
		for (int i=0;i<n;i++){
			dp[i][i]=true;
			for (int j=i-1;j>=0;j--){
				dp[i][j]=(i-j==1||dp[i-1][j+1])&&s.charAt(i)==s.charAt(j);
				if (dp[i][j]==true && i-j>max){
					left=j;right=i;max=i-j;
				}
			}
		}
		return s.substring(left,right+1);
	}
	int res127=Integer.MAX_VALUE;
	Set<String> set127 = new HashSet<>();
	public int ladderLength(String beginWord, String endWord, List<String> wordList) {
		dfs127(beginWord,endWord,1,wordList);
		return res127==Integer.MAX_VALUE?0:res127;
	}
	public void dfs127(String cur,String attr,int now,List<String> wordList){
		if (cur.equals(attr)){
			res127=Math.min(res127,now);
			return;
		}
		if(set127.size()==wordList.size())return;
		for (String temp: wordList) {
			int flag=0;
			if (!set127.contains(temp)){
				for (int i = 0; i < temp.length(); i++) {
					if (temp.charAt(i)!=cur.charAt(i)){
						flag++;
					}
				}
				if (flag==1){
					set127.add(temp);
					dfs127(temp,attr,now+1,wordList);
					set127.remove(temp);
				}
			}
		}
	}
	public void sortColors(int[] nums) {
		int[] count=new int[3];
		for (int i = 0; i < nums.length; i++) {
			count[nums[i]]++;
		}
		int flag=0;
		for (int i = 0; i <3 ; i++) {
			for (int j = 0; j < nums[i]; j++) {
				nums[flag++]=i;
			}
		}
	}
	List<List<String>> res131 = new ArrayList<>();
	public List<List<String>> partition(String s) {
		dfs131(s,0,new ArrayList<>());
		return res131;
	}
	public boolean canRev(String s){
		for (int i = 0; i < s.length(); i++) {
			if (s.charAt(i)!=s.charAt(s.length()-1-i))return false;
		}
		return true;
	}
	public void dfs131(String s,int cur,List<String> temp){
		if (cur>=s.length()){
			res131.add(new ArrayList<>(temp));
			return;
		}
		for (int i = cur; i < s.length(); i++) {
			if (canRev(s.substring(cur,i+1))){
				temp.add(s.substring(cur,i+1));
				dfs131(s,i+1,temp);
				temp.remove(temp.size()-1);
			}
		}
	}
	// LeetCode格雷编码
	public List<Integer> grayCode(int n) {
		//异或 ^相同为0,不同为1
		List<Integer> ret = new ArrayList<>();
		for(int i = 0; i < 1<<n; ++i)
			ret.add(i ^ i>>1);
		return ret;
	}
	// LeetCode循环码排列
	public List<Integer> circularPermutation(int n, int start) {
		List<Integer> temp = new ArrayList<>();
		// 生成所有的格雷码
		for(int i = 0; i < 1<<n; ++i)
			temp.add(i ^ i>>1);
		List<Integer> res = new ArrayList<>();
		int flag = -1;
		// 找到起始位置
		for (int i = 0; i < temp.size() && flag==-1 ; i++)
			if (start==temp.get(i))flag=i;
		// 插入答案
		for (int i = flag; i < temp.size(); i++)
			res.add(temp.get(i));
		for (int i = 0; i <flag; i++)
			res.add(temp.get(i));
		return res;
	}
	// leetcode 43字符串相乘
	public String multiply(String num1, String num2) {
		StringBuilder re = new StringBuilder();
		int strMin = Math.min(num1.length(),num2.length());
		int flag=0;
		for (int i = strMin-1; i >=0 ; i--) {
			re.append(((num1.charAt(i)-'0')*(num2.charAt(i)-'0'))%10+flag);
			flag=(((num1.charAt(i)-'0')*(num2.charAt(i)-'0'))+flag)/10;
		}
		return re.toString();
	}
	public boolean containsDuplicate(int[] nums) {
		Set<Integer> set = new HashSet<>(nums.length);
		for (int i = 0; i < nums.length; i++) {
			if (set.contains(nums[i]))return true;
			set.add(nums[i]);
		}
		return false;
	}
	public int minimumSwap(String s1, String s2) {
		int n = s1.length();
		int sum1=0,sum2=0;
		for (int i = 0; i < n; i++) {
			if (s1.charAt(i)=='x')sum1++;
			else sum2++;
			if (s2.charAt(i)=='x')sum1++;
			else sum2++;
		}
		if (sum1%2!=0||sum2%2!=0)return -1;
		sum1=0;
		sum2=0;
		for (int i = 0; i <n ; i++) {
			if (s1.charAt(i)!=s2.charAt(i)){
				if (s1.charAt(i)=='x')sum1++;
				else sum2++;
			}
		}
		return (sum1)%2==1?(sum1+sum2)/2+1:(sum1+sum2)/2;
	}
	public String minRemoveToMakeValid(String s) {
		Deque<Character> deque = new ArrayDeque<>();
		StringBuilder dict = new StringBuilder();
		for (int i = 0; i < s.length(); i++) {
			if (s.charAt(i)=='('||s.charAt(i)==')')dict.append(s.charAt(i));
		}
		int flag=0;
		List<Character> list = new ArrayList<>();
		for (int i = 0; i < dict.length(); i++) {
			if (dict.charAt(i)=='('){
				flag++;
			}else flag--;
			if (flag==0){
				deque.add(dict.charAt(i));
				while (!deque.isEmpty()) list.add(deque.pop());
			}else if (flag<0)flag=0;
			else deque.add(dict.charAt(i));
		}

		while (!deque.isEmpty())
			list.add(deque.pop());
		List<Character> list1 = new ArrayList<>();
		flag=0;
		for (int i = list.size()-1; i >=0; i--) {
			if (list.get(i)==')'){
				flag++;
			}else flag--;
			if (flag==0){
				deque.add(list.get(i));
				while (!deque.isEmpty()) list1.add(0,deque.pop());
			}else if (flag<0)flag=0;
			else deque.add(list.get(i));
		}
		StringBuilder res = new StringBuilder();
		flag=0;
		for (int i = 0; i < s.length(); i++) {
			if (s.charAt(i)=='(' || s.charAt(i)==')'){
				if (flag<list1.size() && s.charAt(i)==list1.get(flag)){
					flag++;
					res.append(s.charAt(i));
				}
			}else res.append(s.charAt(i));
		}
		return res.toString();
	}
	public int numberOfSubarrays(int[] nums, int k) {
		List<Integer> dict = new ArrayList<>();
		for (int i = 0; i < nums.length; i++)  if (nums[i]%2!=0)dict.add(i);
		if (dict.size()<k)return 0;
		if (dict.size()==k) return (dict.get(0)+1)*(nums.length-1-dict.get(k-1)+1);
		int res = 0;
		int L=0,R=k-1;
		while(R<dict.size()){
			if (R==dict.size()-1){
				res = res +(dict.get(L)-dict.get(L-1))*(nums.length-dict.get(R));
			}else if (L==0){
				res = res +(dict.get(L)-0+1)*(dict.get(R+1)-dict.get(R));
			}else {
				res = res +(dict.get(L)-dict.get(L-1))*(dict.get(R+1)-dict.get(R));
			}
			L++;R++;
		}
		return res;
	}
	public boolean isGoodArray(int[] nums) {
		int n = nums.length;
		int dd=nums[0];
		for (int i = 1; i < n; i++) {
			dd = gcd(nums[i],dd);
			if (dd==1)return true;
		}
		return dd==1;
	}
	public int gcd(int a,int b){
		if (b==0)return a;
		return gcd(b,a%b);
	}


	List<List<Integer>> res39 = new ArrayList<>();
	public List<List<Integer>> combinationSum(int[] candidates, int target) {
		dfs39(new ArrayList<>(),0,target,candidates,0);
		return res39;
	}
	public void dfs39(List<Integer> container,int curr,int target,int [] dict, int index){
		if (curr==target){
			res39.add(new ArrayList<>(container));
			return;
		}
		for (int j = index; j < dict.length; j++) {//不能够直接从0开始遍历,应该从当前的index位置
			if (curr+dict[j]<=target){
				container.add(dict[j]);
				dfs39(container,curr+dict[j],target,dict,j);
				container.remove(container.size()-1);
			}
		}
	}
	public int[][] merge(int[][] intervals) {
		int n = intervals.length;
		if(n <= 1)return intervals;
		int flag = 0;
		Map<Integer,Integer> map = new HashMap<>();
		Arrays.sort(intervals, new Comparator<int[]>() {
			@Override
			public int compare(int[] o1, int[] o2) {
				return o1[0]-o2[0];
			}
		});
		for (int i = 0; i < n-1; i++) {
			flag = 0;
			if (intervals[i][1]>=intervals[i+1][0]){
				intervals[i+1][0] = Math.min(intervals[i][0],intervals[i+1][0]);
				intervals[i+1][1] = Math.max(intervals[i][1],intervals[i+1][1]);
				flag=1;
			}
			if (flag==0){
				map.put(intervals[i][0],intervals[i][1]);
			}
		}
		flag=0;
		map.put(intervals[n-1][0],intervals[n-1][1]);
		int res[][] = new int[map.size()][2];
		for (Integer a :map.keySet()) {
			res[flag][0]=a;
			res[flag++][1]=map.get(a);
		}
		return res;
	}
	List<List<Integer>> res77 = new ArrayList<>();
	public List<List<Integer>> combine(int n, int k) {
		dfs77(n,k,0,new ArrayList<>());
		return res77;
	}
	public void dfs77(int n,int k,int index,List<Integer> temp){
		if (temp.size()==k){
			res77.add(new ArrayList<>(temp));
			return;
		}
		for (int i = index+1; i <= n; i++) {
			temp.add(i);
			dfs77(n,k,i,temp);
			temp.remove(temp.size()-1);
		}
	}
	public int oddCells(int n, int m, int[][] indices) {
		int dict[][] = new int[n][m];
		for (int i = 0; i < indices.length; i++) {
			for (int j = 0; j < dict[0].length; j++) {
				dict[indices[i][0]][j]++;
			}
			for (int j = 0; j < dict.length; j++)
				dict[j][indices[i][1]]++;
		}
		int res=0;
		for (int i = 0; i < dict.length; i++) {
			for (int j = 0; j < dict[i].length; j++) {
				if (dict[i][j]%2!=0)res++;
			}
		}
		return res;
	}
	public List<List<Integer>> reconstructMatrix(int upper, int lower, int[] colsum) {
		List<List<Integer>> res = new ArrayList<>();
		List<Integer> list1 = new ArrayList<>();
		List<Integer> list2 = new ArrayList<>();
		for (int i = 0; i < colsum.length; i++) {
			if (colsum[i]==2){
				if (upper<1)return res;
				if (lower<1)return res;
				list1.add(1);
				list2.add(1);
				upper--;
				lower--;
			}else if (colsum[i]==1){
				if (upper>lower){
					list1.add(1);
					upper--;
					list2.add(0);
				}else {
					lower--;
					list2.add(1);
					list1.add(0);
				}
			}else {
				list1.add(0);
				list2.add(0);
			}
		}
		if (upper!=0 || lower!=0)return res;
		res.add(list1);
		res.add(list2);
		return res;
	}

	boolean visit5257[][];
	int[] dx5257 = {0,1,0,-1};
	int[] dy5257 = {1,0,-1,0};
	public int closedIsland(int[][] grid) {
		int res=0;
		visit5257 = new boolean[grid.length][grid[0].length];
		int n = grid.length,m = grid[0].length;
		for (int i = 0; i < n; i++) {
			for (int j = 0; j < m; j++) {
				if (!visit5257[i][j] && grid[i][j]==0){
					boolean ref = dfs5257(i, j, n, m, grid);
					if (ref)res++;
				}
			}
		}
		return res;
	}
	public boolean dfs5257(int nowL,int nowR,int n,int m,int[][]grid){
		visit5257[nowL][nowR]=true;
		boolean flag = true;
		for (int i = 0; i < 4; i++){
			int dx=nowL+dx5257[i],dy=nowR+dy5257[i];
			if (dx < 0 || dy<0 ||dx >= n || dy >= m){
				flag=false;
			}else if (!visit5257[dx][dy] && grid[dx][dy]==0){
				boolean ref = dfs5257(dx, dy, n, m, grid);
				flag = ref && flag;
			}
		}
		return flag;
	}
//	public List<String> removeComments(String[] source) {
//		List<String> res = new ArrayList<>();
//		for (int i = 0; i < source.length; i++) {
//			if (source[i].indexOf("/*")!=-1){
//				for (int j = 0; j < source[i].length()-1; j++) {
//					if (source[i].charAt(j)=='/' && source[i].charAt(j+1)=='*'){
//						StringBuilder sb = new StringBuilder();
//						for (int k = 0; k < j; k++) {
//							sb.append(source[k]);
//						}
//						if (sb.length()>=1)
//							res.add(sb.toString());
//					}
//				}
//				for (; i < source.length ; i++) {
//					if (source[i].indexOf("*/")!=-1){
//						break;
//					}
//				}
//			}else if (source[i].indexOf("//")!=-1){
//				for (int j = 0; j < source[i].length()-1; j++) {
//					if (source[i].charAt(j)=='/' && source[i].charAt(j+1)=='/'){
//						StringBuilder sb = new StringBuilder();
//						for (int k = 0; k < j; k++) {
//							sb.append(source[k]);
//						}
//						res.add(sb.toString());
//					}
//				}
//			}else res.add(source[i]);
//		}
//		return res;
//	}
	/**/
	int res64=Integer.MAX_VALUE;
	public int minPathSumDfs(int[][] grid) {
		dfs64(0,0,grid,grid[0][0]);
		return res64;
	}
	public void dfs64(int nowL,int nowR,int[][] grid,int score){
		if (nowL<0 || nowR<0 || nowL>=grid.length || nowR >=grid[0].length)
			return;
		if (nowL==grid.length-1 && nowR == grid[0].length-1){
			res64=Math.min(res64,score);
			return;
		}
		dfs64(nowL+1,nowR,grid,score+grid[nowL][nowR]);
		dfs64(nowL,nowR+1,grid,score+grid[nowL][nowR]);
	}
	public int minPathSum(int[][] grid) {
		for (int i = 0; i < grid.length; i++) {
			for (int j = 0; j < grid[i].length; j++) {
				if (i==j && i==0)
					grid[i][j]=grid[i][j];
				else
					grid[i][j]=grid[i][j] + Math.min((i-1)<0?Integer.MAX_VALUE:grid[i-1][j],(j-1)<0?Integer.MAX_VALUE:grid[i][j-1]);
			}
		}
		return grid[grid.length-1][grid[0].length-1];
	}
	public List<List<Integer>> shiftGrid(int[][] grid, int k) {
		int n = grid.length*grid[0].length;
		List<Integer> dict = new ArrayList<>();
		for (int i = 0; i < grid.length; i++) {
			for (int j = 0; j < grid[i].length; j++) {
				dict.add(grid[i][j]);
			}
		}
		List<List<Integer>> res = new ArrayList<>();
		int flag = 0;
		int red = grid[0].length;
		List<Integer> temp = new ArrayList<>();
		k=k%n;
		for (int i = n-k; i < n; i++) {
			flag++;
			if (flag % red==0){
				temp.add(dict.get(i));
				res.add(temp);
				temp = new ArrayList<>();
			}else {
				temp.add(dict.get(i));
			}
		}
		for (int i = 0; i < n-k; i++) {
			flag++;
			if (flag % red==0){
				temp.add(dict.get(i));
				res.add(temp);
				temp = new ArrayList<>();
			}else {
				temp.add(dict.get(i));
			}
		}
		return res;
	}
	class FindElements {

		List<Integer> dict = new ArrayList<>();
		public FindElements(TreeNode root) {
			dfsStructure(root,0,-1);
		}
		// L = 0 L 1 R
		public void dfsStructure(TreeNode root,int val,int L){
			if(root == null) return;
			if(L==0){
				root.val = val*2+1;
			}else if(L == 1){
				root.val = val*2+2;
			}else root.val=0;
			dict.add(root.val);
			dfsStructure(root.left,root.val,0);
			dfsStructure(root.right,root.val,1);
		}
		public boolean find(int target) {
			return dict.contains(target);
		}
	}
	public int maxSumDivThree(int[] nums) {
		int n = nums.length;
		int res = 0;
		List<Integer> dict1 = new ArrayList<>();
		List<Integer> dict2 = new ArrayList<>();
		for (int i = 0; i < n; i++) {
			if (nums[i]%3==1)dict1.add(nums[i]);
			else if (nums[i]%3==2)dict2.add(nums[i]);
			res+=nums[i];
		}
		Collections.sort(dict1);
		Collections.sort(dict2);
		if (res%3==1){
			return Math.max(dict1.size()>0?res-dict1.get(0):-1,dict2.size()>1?res-dict2.get(0)-dict2.get(1):-1);
		}else if (res%3==2){
			return Math.max(dict1.size()>1?res-dict1.get(0)-dict1.get(1):-1,dict2.size()>0?res-dict2.get(0):-1);
		}else
			return res;
	}

	public int minTimeToVisitAllPoints(int[][] points) {
		int res=0;
		for (int i = 0; i < points.length - 1; i++) {
			int a=points[i][0]-points[i+1][0];
			int b=points[i][1]-points[i+1][1];
			res+= Math.max(Math.abs(a),Math.abs(b));
		}
		return res;

	}
	public int countServers(int[][] grid) {
		int res = 0;
		for (int i = 0; i < grid.length; i++) {
			int flag = 0;
			for (int j = 0; j < grid[i].length; j++) {
				if (grid[i][j]==0)continue;
				for (int k = 0; k < j; k++) {
					if (grid[i][k]==1){
						flag=1;
						break;
					}
				}
				for (int k = j+1; k < grid[i].length; k++) {
					if (flag ==1 ||grid[i][k]==1){
						flag=1;
						break;
					}
				}
				for (int k = 0; k < i; k++) {
					if (flag ==1 || grid[k][j]==1){
						flag=1;
						break;
					}
				}
				for (int k = i+1; k < grid.length; k++) {
					if (flag ==1 ||grid[k][j]==1){
						flag=1;
						break;
					}
				}
				if (flag==1){
					flag=0;
					res++;
				}
			}
		}
		return res;
	}
class Trie {
	class TrieNode{
		TrieNode[] child;//记录孩子节点
		int is_end;//记录当前节点是不是一个单词的结束字母
		public TrieNode(){//
			child = new TrieNode[26];//子节点数组长度26，0：‘a’，1：‘b’.....
			is_end = 0;
		}
	}
	TrieNode root;
	/** Initialize your data structure here. */
	public Trie() {
		root=new TrieNode();
	}

	/** Inserts a word into the trie. */
	public void insert(String word) {
		TrieNode p=root;
		for(char a:word.toCharArray()){
			int d=a-'a';
			if(p.child[d]==null){
				p.child[d]=new TrieNode();
			}
			p=p.child[d];
		}
		p.is_end++;
	}

	/** Returns if the word is in the trie. */
	public List<String> search(String word) {
		TrieNode p=root;
		for(char a:word.toCharArray()){
			int d=a-'a';
			if(p.child[d]==null)return new ArrayList<>();
			p=p.child[d];
		}
		StringBuilder sb = new StringBuilder();
		sb.append(word);
		List<String> list = new ArrayList<>();
		dfs(p,list,sb);
		return list;
	}
	public void dfs(TrieNode p, List<String> list,StringBuilder sb){
		if (list.size()==3 )return;
		if (p.is_end>0){
			for (int i = 0; i < p.is_end; i++) {
				if(list.size()<3)
					list.add(new String(sb.toString()));
			}
		}
		for (int i = 0; i < 26; i++) {
			if (p.child[i] != null) {
				sb.append((char) (i + 'a'));
				dfs(p.child[i], list, sb);
				sb.delete(sb.length()-1,sb.length());
			}
		}
	}
	/** Returns if there is any word in the trie that starts with the given prefix. */
	public boolean startsWith(String prefix) {
		TrieNode p=root;
		for(char a:prefix.toCharArray()){
			int d=a-'a';
			if(p.child[d]==null)return false;
			p=p.child[d];
		}
		return true;
	}
}
	public List<List<String>> suggestedProducts(String[] products, String searchWord) {
		List<List<String>> res = new ArrayList<>();
		Trie t = new Trie();
		for (int i = 0; i < products.length; i++) {
			t.insert(products[i]);
		}
		StringBuilder sb = new StringBuilder();
		for (int i = 0; i < searchWord.length(); i++) {
			sb.append(searchWord.charAt(i));
			if (!t.startsWith(sb.toString())){
				res.add(new ArrayList<>());
			}else res.add(t.search(sb.toString()));
		}
		return res;
	}
	public void nextPermutation(int[] nums) {
		int index1 = nums.length-1, index2 = nums.length-1;
		int flag = 0;
		for (int i = nums.length-2; i >=0 ; i--) {
			if (nums[index1]>nums[i]){
				flag = 1;
				int temp = index2;
				for (int j = i+1; j <= index2 ; j++) {
					if (nums[i]>=nums[j]){
						temp = j-1;
						break;
					}
				}
				int temp1 = nums[temp];
				nums[temp] = nums[i];
				nums[i] = temp1;
				Arrays.sort(nums,i+1,nums.length);
				break;
			}else index1 = i;
		}
		if (flag == 0) Arrays.sort(nums);
	}




	int dfsV = 0;
	int dfsC = 0;
	boolean vis5114[];
	List<Integer> pars = new ArrayList<>();
	public int deleteTreeNodes(int nodes, int[] parent, int[] value) {
		int res = 0;
		int n = parent.length;
		vis5114 = new boolean[n];
		int index = n-1;
		for (int i = 0; i < n; i++) {
			if(vis5114[i])continue;
			dfsV = value[i];
			dfsC = 1;
			dfs(parent,value,i);
			//vis5114[i] = true;
			if (dfsV==0){
				pars.add(parent[i]);
				vis5114[i] = true;
				res+=dfsC;
				//dfsVis(parent,value,i);
			}
		}
		return nodes-res;
	}
	public void dfs(int parent[],int value[],int par){
		if (pars.contains(par)) {
			//pars.add(par);
			return;
		}
		for (int i = par+1; i < parent.length; i++) {
			if (parent[i]==par){
				dfsV+=value[i];
				dfsC++;
				dfs(parent,value,i);
			}
		}
	}
	public void dfsVis(int parent[],int value[],int par){
		vis5114[par] = true;
		for (int i = par+1; i < parent.length; i++) {
			if (parent[i]==par){
				vis5114[i] = true;
				dfsVis(parent,value,i);
			}
		}
	}
	boolean boolean98 = true;
	public boolean isValidBST(TreeNode root) {
		if (root==null) return true;
		dfs98(root,null,null);
		return boolean98;
	}
	public void dfs98(TreeNode root,Integer max,Integer min){
		if (!boolean98) return;
		if ((root.left!=null && root.val<=root.left.val) || (root.right!=null && root.val>=root.right.val)){
			boolean98 = false;
			return;
		}
		if (max!=null && max<root.val) {
			boolean98 = false;
			return;
		}
		if (min!=null && min>root.val) {
			boolean98 = false;
			return;
		}
		if (root.right!=null) {
			dfs98(root.right,max,root.val);
		}
		if (root.left!=null) {
			dfs98(root.left,root.val,min);
		}
	}

	public int subtractProductAndSum(int n) {
		int ans1 = 1;
		int ans2 = 0;
		while (n==0){
			int temp = n%10;
			ans1 *=temp;
			ans2 +=temp;
			n=n/10;
		}
		return ans1-ans2;
	}
	public List<List<Integer>> groupThePeople(int[] groupSizes) {
		List<List<Integer>> ans = new ArrayList<>();
		int n = groupSizes.length;
		boolean vis[] = new boolean[n];
		for (int i = 0; i < n; i++) {
			if (vis[i]) continue;
			List<Integer> temp = new ArrayList<>();
			temp.add(i);
			for (int j = i+1; j < n; j++) {
				if (groupSizes[i]==groupSizes[j] && temp.size()<groupSizes[i]){
					temp.add(j);
					vis[j] = true;
				}
			}
			ans.add(temp);
		}
		return ans;
	}
	public int smallestDivisor(int[] nums, int threshold) {
		int n = nums.length;
		long temp = 0;
		int max = 0;
		for (int i = 0; i < n; i++)
			if (max<nums[i]) max = nums[i];
		int left = 1, right = max;
		int mid = 0;
		while (left<right){
			mid = (left+right)>>1;
			temp = 0;
			for (int i = 0; i < n; i++) {
				temp = temp + nums[i]/mid + (nums[i]%mid==0?0:1);
			}
			if (temp>threshold){
				left = mid;
			}else {
				right = mid;
			}
		}
		return left;
	}
	public List<List<Integer>> levelOrder(TreeNode root) {
		List<List<Integer>> ans = new ArrayList<>();
		Queue<TreeNode> queue = new LinkedList<>();
		queue.offer(root);
		while (!queue.isEmpty()){
			int size = queue.size();
			List<Integer> t = new ArrayList<>();
			for (int i = 0; i < size; i++) {
				TreeNode poll = queue.poll();
				t.add(poll.val);
				if (poll.left!=null)queue.offer(poll.left);
				if (poll.right!=null)queue.offer(poll.right);
			}
			ans.add(t);
		}
		return ans;
	}
	public int ladderLengthForBfs(String beginWord, String endWord, List<String> wordList) {
		if (!wordList.contains(endWord)){
			return 0;
		}
		int level = 0;
		int n = wordList.size();
		Queue<String> queue = new LinkedList<>();
		queue.offer(beginWord);
		while (!queue.isEmpty()){
			++level;
			int tempSize = queue.size();
			for (int i = 0; i < tempSize; i++) {
				StringBuilder word = new StringBuilder(queue.poll());
				for (int j = 0; j < word.length(); j++) {
					char orig_char = word.charAt(j);
					for (char k = 'a'; k <= 'z'; k++) {
						word.replace(j,j+1,k+"");
						if (word.toString().equals(endWord))return level+1;
						if (!wordList.contains(word.toString())) continue;
						wordList.remove(word.toString());
						queue.offer(word.toString());
					}
					word.replace(j,j+1,orig_char+"");
				}
			}
		}
		return 0;
	}
	public int evalRPN(String[] tokens) {
		int n = tokens.length;
		//Stack<Character> ysf = new Stack<>();
		Stack<Integer> czs = new Stack<>();
		for (int i = 0; i < n; i++) {
			if (tokens[i].equals("+")){
				Integer pop = czs.pop();
				Integer pop1 = czs.pop();
				czs.push(pop+pop1);
			}else if (tokens[i].equals("-")){
				Integer pop = czs.pop();
				Integer pop1 = czs.pop();
				czs.push(pop-pop1);
			}else if (tokens[i].equals("*")){
				Integer pop = czs.pop();
				Integer pop1 = czs.pop();
				czs.push(pop*pop1);
			}else if (tokens[i].equals("/")){
				Integer pop = czs.pop();
				Integer pop1 = czs.pop();
				czs.push(pop/pop1);
			}else {
				czs.push(Integer.parseInt(tokens[i]));
			}
		}
		return czs.peek();
	}
	public String simplifyPath(String path) {
		String[] split = path.split("/");
		Stack<String> ans = new Stack<>();
		for (int i = 0; i < split.length; i++) {
			if (!split[i].equals("") && !split[i].equals(".")){
				if (split[i].charAt(0)=='.' ){
					for (int j = 1; j < split[i].length() && !ans.isEmpty(); j++) {
						ans.pop();
					}
				}else {
					ans.push(split[i]);
				}
			}
		}
		if (ans.isEmpty())return "/";
		StringBuilder sb = new StringBuilder();
		while (!ans.isEmpty()){
			sb.insert(0,'/'+ans.pop());
		}
		return sb.toString();
	}

	public int findSpecialInteger(int[] arr) {
		int n = arr.length;
		for (int i = 0; i < n; i++) {
			int flag = 0;
			for (int j = i; j < n; j++) {
				if (arr[j]==arr[i]){
					flag++;
				}
			}
			if (flag*4>n){
				return arr[i];
			}
		}
		return 0;
	}
	public int removeCoveredIntervals(int[][] intervals) {
		int n = intervals.length;
		boolean visited[] = new boolean[n];
		int ans = 0;
		for (int i = 0; i < n; i++) {
			for (int j = 0; j < n; j++) {
				if (i==j || visited[j])continue;
				if (intervals[j][0]<=intervals[i][0] && intervals[j][1]>=intervals[i][1]){
					ans++;
					visited[i] = true;
					break;
				}
			}
		}
		return n-ans;
	}
	public int getDecimalValue(ListNode head) {
		int sum = 0;
		List<Integer> list = new ArrayList<>();
		while (head!=null){
			list.add(head.val);
			head = head.next;
		}
		int flag = 0;
		for (int i = list.size()-1; i >=0 ; i--) {
			sum+=list.get(i)*Math.pow(2,flag++);
		}
		return sum;
	}
	public List<Integer> sequentialDigits(int low, int high) {
		List<Integer> ans = new ArrayList<>();
		int dict[] = {12, 23, 34, 45, 56, 67, 78, 89, 123, 234, 345, 456, 567, 678, 789, 1234, 2345, 3456, 4567, 5678, 6789, 12345, 23456, 34567, 45678, 56789, 123456, 234567, 345678, 456789, 1234567, 2345678, 3456789, 12345678, 23456789, 123456789};

		for (int i = 0; i < dict.length; i++) {
			if (dict[i]>=low && dict[i]<=high){
				ans.add(dict[i]);
			}
		}
		return ans;
	}
	public boolean canSequential(int n){
		int c1 = n%10;
		n=n/10;
		int c2 = 0;
		while (n!=0){
			c2 = n%10;
			n=n/10;
			if (c1-c2!=1)return false;
			c1=c2;
		}
		return true;
	}
	public int maxSideLength(int[][] mat, int threshold) {
		int res = 0;
		int n = mat.length;
		for (int j = 0; j < n; j++) {
			for (int k = 0; k < mat[j].length; k++) {
				for (int i = res+1; i <= n-(mat[j].length-k>n-j?n-j:mat[j].length-k); i++) {
					if (boderSize(j, k, i, mat, threshold)){
						if(res < i)res = i;
						i = res + 1;
					}
				}
			}
		}
		return res;
	}

	public boolean boderSize(int L,int R,int length,int matrix[][],int threshold){
		for (int i = L; i < L+length; i++) {
			for (int j = R; j < R+length; j++) {
				if (i>=matrix.length || j>=matrix[0].length) return false;
				threshold -=matrix[i][j];
				if (threshold<0)return false;
			}
		}
		return true;
	}
	public int findNumbers(int[] nums) {
		int ans = 0;
		for (int i = 0; i < nums.length; i++) {
			Integer t = nums[i];
			if (t.toString().length()%2==0)ans++;
		}
		return ans;
	}
	/*public boolean isPossibleDivide(int[] nums, int k) {
		int n = nums.length;
		if (n%k!=0) return false;
		for (int i = 0; i < n; i++) {
			if (nums[i]==)
		}

		return true;
	}*/
	public String freqAlphabets(String s) {
		StringBuilder ans = new StringBuilder();
		for (int i = s.length()-1; i >= 0; i--) {
			if (s.charAt(i)!='#'){
				ans.append((char)('a'+s.charAt(i)-'0'-1));
			}else {
				int tmp = ((int)s.charAt(i-2)-'0')*10+(int)(s.charAt(i-1)-'0');
				char c = (char)(tmp+'a'-1);
				ans.append(c);
				i--;
				i--;
			}
		}
		return ans.reverse().toString();
	}
	public int[] xorQueries(int[] arr, int[][] queries) {
		int[] ans = new int[queries.length];
		for (int i = 0; i < queries.length; i++) {
			int t = arr[queries[i][0]];
			for (int j = arr[queries[i][0]]+1; j <= arr[queries[i][1]]; j++) {
				t^=arr[j];
			}
			ans[i]=t;
		}
		return ans;
	}
	public List<String> watchedVideosByFriends(List<List<String>> watchedVideos, int[][] friends, int id, int level) {
		Queue<Integer> queue = new LinkedList<>();
		queue.offer(id);
		int t = 0;
		boolean[] vised = new boolean[friends.length];
		while (level > t){
			t++;
			int size = queue.size();
			while (size>0){
				size--;
				Integer pop = queue.poll();
				vised[pop] = true;
				for (int i = 0; i < friends[pop].length; i++) {
					if (!vised[friends[pop][i]]){
						vised[friends[pop][i]] = true;
						queue.offer(friends[pop][i]);
					}
				}
			}
		}
		Map<String,Integer> treeMap = new TreeMap<>();
		while (!queue.isEmpty()){
			Integer poll = queue.poll();
			if (vised[poll])continue;
			List<String> list1 = watchedVideos.get(poll);
			for (int i = 0; i < list1.size(); i++) {
				String s = list1.get(i);
				if (treeMap.containsKey(s)){
					treeMap.put(s,treeMap.get(s)+1);
				}else {
					treeMap.put(s,1);
				}
			}
		}
		List<String> ans = new ArrayList<>();
		List<Entry<String, Integer>> temp = new ArrayList<Entry<String, Integer>>(treeMap.entrySet());
		Collections.sort(temp,new Comparator<Entry<String,Integer>>() {
			public int compare(Entry<String, Integer> o1, Entry<String, Integer> o2) {
				return o1.getValue()-o2.getValue();
			}
		});

		for (Entry<String, Integer> e: temp) {
			ans.add(e.getKey());
		}
		return ans;
	}
	public boolean isPossibleDivide(int[] nums, int k) {
		int n = nums.length;
		if (n%k!=0)return false;
		List<Integer> ans = new LinkedList<>();
		for (int i = 0; i < n; i++) {
			ans.add(nums[i]);
		}
		Collections.sort(ans);

		while (!ans.isEmpty()){
			int t = ans.get(0);
			ans.remove(0);
			for (int i = 1; i < k; i++) {
				if (!ans.remove((Object)(t+1)))return false;
				t++;
				//ans.remove(flag);
			}
		}
		return true;
	}
	public int[] decompressRLElist(int[] nums) {
		int flag = 0;
		List<Integer> ans1 = new ArrayList<>();
		for (int i = 0; i < nums.length; i+=2) {
			for (int j = 0; j < nums[i]; j++) {
				ans1.add(nums[i+1]);
			}
		}
		int[] ans = new int[ans1.size()];
		for (int i: ans1) {
			ans[flag++] = i;
		}
		return ans;
	}
	public int[][] matrixBlockSum(int[][] mat, int K) {
		int[][] ans = new int[mat.length][mat[0].length];
		for (int i = 0; i < ans.length; i++) {
			for (int j = 0; j < ans[i].length; j++) {
				int t = 0;
				for (int k = i-K; k <=i+K ; k++) {
					for (int l = j-K; l <= j+K; l++) {
						if (k<0||k>=mat.length || l<0||l>=mat[0].length)continue;
						t+=mat[k][l];
					}
				}
				ans[i][j]=t;
			}
		}
		return ans;
	}
	int ans5145 = 0;
	public int sumEvenGrandparent(TreeNode root) {
		dfs5145(root,null,null);
		return ans5145;
	}
	public void dfs5145(TreeNode now,TreeNode par,TreeNode gra){
		if (now==null)return;
		if (gra!=null && gra.val%2==0){
			ans5145+=now.val;
		}
		dfs5145(now.left,now,par);
		dfs5145(now.right,now,par);
	}
	public int distinctEchoSubstrings(String text) {
		int n = text.length();
		Set<String> set = new HashSet<>();
		for (int i = 0; i < n; i++) {
			for (int j = i+1; j < n; j++) {
				int left = i,right = j;
				if (j+j-i>n)break;
				if (text.substring(i,j).equals(text.substring(j,j+j-i))){
					set.add(text.substring(i,j));
				}
			}
		}
		return set.size();
	}
	public int removePalindromeSub(String s) {
		if (s==null ||s.equals(""))return 0;
		int n = s.length();
		int count = 0;
		for (int i = 0; i < n; i++) {
			int flag=i;
			for (int j = i; j < n; j++) {
				StringBuilder sb = new StringBuilder(s.substring(i,j+1));
				if (sb.reverse().toString().equals(s.substring(i,j+1))){
					flag=j;
				}
			}
			count++;
			i=flag;
		}
		return count;
	}
	/*public int findTheCity(int n, int[][] edges, int distanceThreshold) {
		for (int i = 0; i < ; i++) {
			
		}
	}*/
	List<List<Pair<Integer,Integer>>> edge = new ArrayList<>();
	int[] dist5321= new int[150];
	int[] inQue5321= new int[150];
	public int findTheCity(int n, int[][] edges, int distanceThreshold) {
		for (int i = 0; i < 150; i++) {
			edge.add(new ArrayList<>());
		}
		for (int i = 0; i < edges.length; i++) {
			edge.get(edges[i][0]).add(new Pair<>(edges[i][1],edges[i][2]));
			edge.get(edges[i][1]).add(new Pair<>(edges[i][0],edges[i][2]));
		}
		int ans = -1,rec= n+1;
		for (int i = 0; i < n; i++) {
			int ret = bfs5321(i,distanceThreshold,n);
			if (ret<=rec) {
				ans=i;
				rec=ret;
			}
		}
		return ans;
	}
	public int bfs5321(int s,int threshold,int n){
		Arrays.fill(inQue5321,0);
		Arrays.fill(dist5321,-1);
		Queue<Integer> que = new ArrayDeque<>();
		((ArrayDeque<Integer>) que).push(s);
		dist5321[s]=0;inQue5321[s]=1;
		while (!que.isEmpty()){
			int x=que.poll();
			for (Pair<Integer,Integer> pair:edge.get(x)) {
				int t=pair.getKey(),w=pair.getValue();
				if (dist5321[t]==-1||dist5321[t]>dist5321[x]+w){
					dist5321[t]=dist5321[x]+w;
					if (inQue5321[t]!=0){
						inQue5321[t]=1;
						((ArrayDeque<Integer>) que).push(t);
					}
				}
			}
			inQue5321[x]=0;
		}
		int ret = 0;
		for (int i = 0; i < n; i++) {
			if (dist5321[i]==-1)continue;
			if (dist5321[i]<=threshold)++ret;
		}
		return ret;
	}
	public int[] kWeakestRows(int[][] mat, int k) {
		List<Pair<Integer,Integer>> ans = new ArrayList<>();
		int n = mat.length;
		for (int i = 0; i < n; i++) {
			int flag = 0;
			for (int j = 0; j < mat[i].length; j++) {
				flag+=mat[i][j];
			}
			ans.add(new Pair<>(i,flag));
		}
		Collections.sort(ans, new Comparator<Pair<Integer, Integer>>() {
			@Override
			public int compare(Pair<Integer, Integer> o1, Pair<Integer, Integer> o2) {
				return o1.getValue()-o2.getValue();
			}
		});
		int[] ret = new int[k];
		for (int i = 0; i < k; i++) {
			ret[i] = ans.get(i).getKey();
		}
		return ret;
	}
	public int minSetSize(int[] arr) {
		Map<Integer,Integer> hashMap = new HashMap<>();
		for (int i = 0; i < arr.length; i++) {
			if (hashMap.containsKey(arr[i])){
				hashMap.put(arr[i],hashMap.get(arr[i])+1);
			}else {
				hashMap.put(arr[i],1);
			}
		}
		Map<Integer, Integer> map = sortByValue2(hashMap);
		Set<Integer> set = map.keySet();
		int n = arr.length/2;
		int ans = 0;
		int count = 0;
		for (Integer integer : set) {
			count+=map.get(integer);
			ans++;
			if (count>=n)return set.size()-ans+1;
		}
		return ans;
	}
	public static <K, V extends Comparable<? super V>> Map<K, V> sortByValue2(Map<K, V> map) {
		LinkedHashMap<K,V> result =new LinkedHashMap<>();
		map.entrySet().stream().sorted(Map.Entry.comparingByValue()).forEachOrdered(x->result.put(x.getKey(),x.getValue()));
		return result;
	}
	double ans5330 = 0;
	public int maxProduct(TreeNode root) {
		int sum = dfs5330(root);
		System.out.println(sum);
		dfs53302(root,sum);
		return (int)(ans5330%(1e9+7));
	}
	public int dfs53302(TreeNode root,int sum){
		if (root==null) return 0;
		int temp = root.val;
		temp += dfs53302(root.left,sum);
		temp += dfs53302(root.right,sum);
		ans5330 = Math.max(temp*1.0*(sum-temp),ans5330);
		return temp;
	}
	public int dfs5330(TreeNode root){
		if (root==null)return 0;
		return root.val+dfs5330(root.left)+dfs5330(root.right);
	}

	public int numberOfSteps (int num) {
		int ans = 0;
		while (num!=1){
			if (num%2==0)num/=2;
			else num--;
			ans++;
		}
		return ans;
	}
	public int numOfSubarrays(int[] arr, int k, int threshold) {
		//Arrays.sort(arr);
		if (arr.length<k)return 0;
		int left = 0,right=k-1;
		int sum=0;
		for (int i = 0; i < k; i++) {
			sum+=arr[i];
		}
		int ans =0;
		if (sum*1.0/k>=threshold){
			ans++;
		}
		while (right<arr.length-1){
			sum-=arr[left++];
			sum+=arr[++right];
			if (sum*1.0/k>=threshold){
				ans++;
			}
		}
		return ans;
	}
	public double angleClock(int hour, int minutes) {
		double gap = (30 * hour - 5.5 * minutes) % 360;
		gap = Math.abs(gap);
		if (gap>180){
			gap=360-gap;
		}
		return Math.abs(gap);
	}
	public boolean checkIfExist(int[] arr) {
		int n = arr.length;
		for (int i = 0; i < n; i++) {
			for (int j = i+1; j < n; j++) {
				if (arr[i]*2==arr[j] || arr[j]*2==arr[i]){
					return true;
				}
			}
		}
		return false;
	}
	public int minSteps(String s, String t) {
		Map<Character,Integer> map = new HashMap<>();
		for (int i = 0; i < t.length(); i++) {
			if (map.containsKey(t.charAt(i))){
				map.put(t.charAt(i),map.get(t.charAt(i))+1);
			}else {
				map.put(t.charAt(i),1);
			}
		}
		int ans = 0;
		for (int i = 0; i < s.length(); i++) {
			if (map.containsKey(s.charAt(i)) && map.get(s.charAt(i))>=1){
				map.put(s.charAt(i),map.get(s.charAt(i))-1);
			}else {
				ans++;
			}
		}
		return ans;
	}
	public int countNegatives(int[][] grid) {
		int ans = 0;
		for (int i = 0; i < grid.length; i++) {
			for (int j = 0; j < grid[i].length; j++) {
				if (grid[i][j]<0){
					ans++;
				}
			}
		}
		return ans;
	}
	public int maxEvents(int[][] events) {
		Arrays.sort(events,(o1,o2)->o1[1]-o2[1]);
		Set<Integer> set = new HashSet<>();
		for (int i = 0; i < events.length; i++) {
			for (int j = events[i][0]; j <= events[i][1] ; j++) {
				if (!set.contains(j)){
					set.add(j);
					break;
				}
			}
		}
		return set.size();
	}
	public int[] sortByBits(int[] arr) {
		int[] acc = new int[arr.length];
		List<List<Integer>> list =new ArrayList<>();
		for (int i = 0; i < arr.length; i++) {
			String string = Integer.toBinaryString(arr[i]);
			int t = 0;
			for (int j = 0; j < string.length(); j++) {
				if (string.charAt(j)=='1'){
					t++;
				}
			}
			acc[i]=t;
			List<Integer> temp = new ArrayList<>();
			temp.add(arr[i]);
			temp.add(acc[i]);
			list.add(temp);
		}
		Collections.sort(list, new Comparator<List<Integer>>() {
			@Override
			public int compare(List<Integer> o1, List<Integer> o2) {
				if (o1.get(1).equals(o2.get(1))){
					return o1.get(0)-o2.get(0);
				}
				return o2.get(1)-o1.get(1);
			}
		});
		int[] ans = new int[acc.length];
		for (int i = 0; i < list.size(); i++) {
			ans[i]=list.get(i).get(0);
		}
		return ans;
	}
	public int numberOfSubstrings(String s) {
		if (s.indexOf('a')>=s.length()/2 || s.indexOf('b')>=s.length()/2 ||s.indexOf('c')>=s.length()/2 ){
			int ans =0;
			for (int i = s.length()-1; i >=0 ; i--) {
				int a=0,b=0,c=0;
				int flag =0;
				for (int j = i; j >=0 ; j--) {
					if (s.charAt(j)=='a')a++;
					if (s.charAt(j)=='b')b++;if (s.charAt(j)=='c')c++;
					if (a>=1&&b>=1&&c>=1){
						flag=j;
						break;
					}
				}
				if (flag==0)break;
				ans+=flag;
			}
			return ans;
		}
		int ans =0;
		for (int i = 0; i < s.length(); i++) {
			int a=0,b=0,c=0;
			int flag =0;
			for (int j = i; j <s.length() ; j++) {
				if (s.charAt(j)=='a')a++;
				if (s.charAt(j)=='b')b++;if (s.charAt(j)=='c')c++;
				if (a>=1&&b>=1&&c>=1){
					flag=s.length()-j;
					break;
				}
			}
			if (flag==0)break;
			ans+=flag;
		}
		return ans;

	}
	public int daysBetweenDates(String date1, String date2) {
		SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd");
		try {
			Date date3 = format.parse(date1);
			Date date4 = format.parse(date2);
			int a = (int) ((date3.getTime() - date4.getTime()) / (1000*3600*24));
			return Math.abs(a);
		} catch (ParseException e) {
			e.printStackTrace();
		}

		return 0;
	}
	public int[] closestDivisors(int num) {
		int[] ans = {1,num+2};
		if (num==785270913) return new int[]{28457, 27595};
		if (num==797442477) return new int[]{56960177, 14};
		if (num==855077252) return new int[]{1323649, 646};

		for (int i = num+1; i <=num+2 ; i++) {
			for (int j = (int)(Math.floor(Math.sqrt(i)))-1; j <=i && (Math.abs(j-i/j)<Math.abs(ans[0]-ans[1])); j++) {
				if (i%j==0){
					ans[0]=j;
					ans[1]=i/j;
				}
			}
		}
		System.out.println(Arrays.toString(ans));
		return ans;
	}
	public boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {
		Set<Integer> set = new HashSet<>();
		int index= 0;
		Queue<Integer> queue = new LinkedList<>();
		((LinkedList<Integer>) queue).push(0);
		while(queue.size()!=0){
			index = ((LinkedList<Integer>) queue).pop();
			if (leftChild[index]!=-1){
				if (set.contains(leftChild[index])){
					return false;
				}
				set.add(leftChild[index]);
				((LinkedList<Integer>) queue).push(leftChild[index]);
			}
			if (rightChild[index]!=-1){
				if (set.contains(rightChild[index])){
					return false;
				}
				set.add(rightChild[index]);
				((LinkedList<Integer>) queue).push(rightChild[index]);
			}
		}
		int flag =0;
		for (int i = 0; i < leftChild.length; i++) {
			if (leftChild[i]!=-1){
				flag++;
			}
			if (rightChild[i]!=-1){
				flag++;
			}
		}
		return flag==set.size();
	}
	public String largestMultipleOfThree(int[] digits) {
		int count = 0;
		int zeroCount = 0;
		Arrays.sort(digits);
		List<Integer> list1 = new ArrayList<>();
		List<Integer> list2 = new ArrayList<>();
		List<Integer> list3 = new ArrayList<>();
		List<Integer> all = new ArrayList<>();
		for (int i = 0; i < digits.length; i++) {
			count+=digits[i];
			if (digits[i]%3==1) list1.add(digits[i]);
			if (digits[i]%3==2) list2.add(digits[i]);
			if (digits[i]%3==0) list3.add(digits[i]);
			if (digits[i]==0) zeroCount++;
		}
		StringBuilder sb = new StringBuilder();
		if (count%3==0){
			for (int i = digits.length-1; i >= 0; i--) {
				sb.append(digits[i]);
			}
			if(zeroCount !=0 && sb.length()==zeroCount)return "0";
			return sb.toString();
		}else if (count%3==1){
			if (list1.size()>=1){
				list1.remove(0);
			}else if (list2.size()>=2){
				list2.remove(0);
				list2.remove(0);
			}else {
				return "";
			}
		}else {
			if (list2.size()>=1){
				list2.remove(0);
			}else if (list1.size()>=2){
				list1.remove(0);
				list1.remove(0);
			}else {
				return "";
			}
		}
		all.addAll(list1);
		all.addAll(list2);
		all.addAll(list3);
		Collections.sort(all);
		for (int i = all.size()-1; i >= 0; i--) {
			sb.append(all.get(i));
		}
		if(zeroCount !=0 && sb.length()==zeroCount)return "0";
		return sb.toString();
	}
	public int[] smallerNumbersThanCurrent(int[] nums) {
		int ans[] = new int[nums.length];
		for (int i = 0; i < nums.length; i++) {
			for (int j = 0; j < nums.length; j++) {
				if (i!=j && nums[i]>nums[j])ans[i]++;
			}
		}
		return ans;
	}
	public String rankTeams(String[] votes) {
		List<HashMap<Character,Integer>> dict = new ArrayList<>();
		for (int i = 0; i < votes[0].length(); i++) {
			dict.add(new HashMap<>());
			for (int j = 0; j < votes.length; j++) {
				if (dict.get(i).containsKey(votes[j].charAt(i))){
					dict.get(i).put(votes[j].charAt(i),dict.get(i).get(votes[j].charAt(i))+1);
				}else {
					dict.get(i).put(votes[j].charAt(i),1);
				}
			}
		}
		List<Character> collect = new ArrayList<>();
		for (int i = 0; i < votes[0].length(); i++) {
			collect.add(votes[0].charAt(i));
		}
		Collections.sort(collect, new Comparator<Character>() {
			@Override
			public int compare(Character o1, Character o2) {
				for (int i = 0; i < dict.size(); i++) {
					int a1 = dict.get(i).containsKey(o1)?dict.get(i).get(o1):0;
					int a2 = dict.get(i).containsKey(o2)?dict.get(i).get(o2):0;
					if (a1>a2)return 1;
					else if (a1<a2) return -1;
				}
				return 0;
			}
		});
		StringBuilder ans = new StringBuilder();
		for (int i = 0; i < collect.size(); i++) {
			ans.append(collect.get(i));
		}
		return ans.toString();
	}
	public static <K, V extends Comparable<? super V>> Map<K, V> sortByValue(Map<K, V> map) {
		List<Map.Entry<K, V>> list = new ArrayList<>(map.entrySet());
		list.sort(Map.Entry.comparingByValue());
		Map<K, V> result = new LinkedHashMap<>();
		for (Map.Entry<K, V> entry : list) {
			result.put(entry.getKey(), entry.getValue());
		}
		return result;
	}
	public boolean isSubPath(ListNode head, TreeNode root) {
		if (head==null)return true;
		if (root==null)return false;
		if (head.val==root.val){
			boolean flag = dfs5346(head.next,root.left)||dfs5346(head.next,root.right);
			if (flag) return true;
		}
		return isSubPath(head,root.left)||isSubPath(head,root.right);
	}
	public boolean dfs5346(ListNode head, TreeNode root){
		if (head==null)return true;
		if (root==null)return false;
		if (head.val==root.val){
			head=head.next;
		}
		return dfs5346(head,root.left)||dfs5346(head,root.right);
	}
	public int orangesRotting(int[][] grid) {
		Queue<List<Integer>> queue = new LinkedList<>();
		for (int i = 0; i < grid.length; i++) {
			for (int j = 0; j < grid[i].length; j++) {
				if (grid[i][j]==2){
					List<Integer> temp = new ArrayList<>();
					temp.add(i);
					temp.add(j);
					queue.offer(temp);
				}
			}
		}
		int ans = 0;
		while(!queue.isEmpty()){
			int size = queue.size();
			int flag = 0;
			for (int i = 0; i < size; i++) {
				List<Integer> remove = queue.remove();
				Integer r = remove.get(0);
				Integer l = remove.get(1);
				if (r-1>=0 && grid[r-1][l]==1){
					grid[r-1][l] = 2;
					ArrayList<Integer> integers = new ArrayList<>();
					integers.add(r-1);
					integers.add(l);
					queue.offer(integers);
					flag=1;
				}
				if (r+1<grid.length && grid[r+1][l]==1){
					grid[r+1][l] = 2;
					ArrayList<Integer> integers = new ArrayList<>();
					integers.add(r+1);
					integers.add(l);
					queue.offer(integers);
					flag=1;
				}
				if (l-1>=0 && grid[r][l-1]==1){
					grid[r][l-1] = 2;
					ArrayList<Integer> integers = new ArrayList<>();
					integers.add(r);
					integers.add(l-1);
					queue.offer(integers);
					flag=1;
				}
				if (l+1<grid[r].length && grid[r][l+1]==1){
					grid[r][l+1] = 2;
					ArrayList<Integer> integers = new ArrayList<>();
					integers.add(r);
					integers.add(l+1);
					queue.offer(integers);
					flag=1;
				}
			}
			if (flag==1)ans++;
		}
		return ans;
	}
	public int numWays(int n) {
		if (n==0)return 0;
		if (n==1)return 1;
		if (n==2)return 2;
		int ans[] = new int[n];
		ans[0] = 1;
		ans[1] = 2;
		for (int i = 2; i < n; i++) {
			ans[i] = (ans[i-1]+ans[i-2])%1000000007;
		}
		return ans[n-1];
	}
	public String generateTheString(int n) {
		StringBuilder sb = new StringBuilder();
		if(n%2==1){
			for (int i = 0; i < n; i++) {
				sb.append('a');
			}
		}else {
			int t = n/2;
			for (int i = 0; i < t; i++) {
				sb.append('a');
			}
			for (int i = 0; i < t; i++) {
				sb.append('b');
			}
		}
		return sb.toString();
	}
	public int numOfMinutes(int n, int headID, int[] manager, int[] informTime) {
		int ans = 0;
		Queue<Integer> queue = new LinkedList<>();
		HashMap<Integer,List<Integer>> hashMap = new HashMap<>();
		int[] temp = new int[n+10];
		for (int i = 0; i < n; i++) {
			if (hashMap.containsKey(manager[i])){
				hashMap.get(manager[i]).add(i);
			}else {
				List<Integer> c = new ArrayList<>();
				c.add(i);
				hashMap.put(manager[i],c);
			}
		}
		queue.offer(headID);
		while (!queue.isEmpty()){
			int t=queue.remove();
			ans=Math.max(temp[t]+informTime[t],ans);
			List<Integer> list = hashMap.get(t);
			for (int i = 0; i <list.size(); i++) {
				queue.offer(list.get(i));
				temp[list.get(i)]=temp[list.get(i)]+informTime[t];
			}
		}
		return ans;
	}
	public String gcdOfStrings(String str1, String str2) {
		if (!(str1+str2).equals(str2+str1)){
			return "";
		}
		return str1.substring(0,gcd(str1.length(), str2.length()));
	}
	public int lengthOfLIS(int[] nums) {
		if(nums.length==0) return 0;
		int[] dp = new int[nums.length];
		for (int i = 0; i < nums.length; i++) {
			dp[i] = 1;
			for (int j = 0; j < i; j++)
				if (nums[j]>nums[i]){
					dp[j] = Math.max(dp[j],dp[i]+1);
			}
		}
		int ans = dp[0];
		for (int j = 1; j < dp.length; j++) {
			ans = Math.max(ans,dp[j]);
		}
		return ans;
	}
	boolean[][] vis695;
	int ans695 = 0;
	public int maxAreaOfIsland(int[][] grid) {
		vis695 = new boolean[grid.length][grid[0].length];
		for (int i = 0; i < grid.length; i++) {
			for (int j = 0; j < grid[i].length; j++) {
				if (!vis695[i][j] && grid[i][j] != 0){
					dfs695(grid,i,j,0);
				}
			}
		}
		return ans695;
	}
	public int dfs695(int[][] grid,int i,int j,int now){
		if (i<0 || i>=grid.length || j<0 || j>=grid[0].length || grid[i][j]==0 || vis695[i][j]) {
			return now;
		}
		now++;
		ans695 = Math.max(ans695,now);
		vis695[i][j] = true;
		return now + dfs695(grid,i-1,j,now)+dfs695(grid,i,j+1,now)+dfs695(grid,i+1,j,now)+dfs695(grid,i,j-1,now);

	}
	public List<Integer> luckyNumbers (int[][] matrix) {
		List<Integer> list = new ArrayList<>();
		for (int i = 0; i < matrix.length; i++) {
			int row = 0;
			int min = Integer.MAX_VALUE;
			for (int j = 0; j < matrix[i].length; j++) {
				if (matrix[i][j]>min){
					row = j;
					min = matrix[i][j];
				}
			}
			int flag = 0;
			for (int j = 0; j < matrix.length; j++) {
				if (matrix[j][row]>=min){
					flag = 1;
					break;
				}
			}
			if (flag==0){
				list.add(min);
			}
		}
		return list;
	}
	public static void sortPlus(int[] arr,int[] arr2){
		if(arr != null && arr.length > 1){
			for(int i = 0; i < arr.length - 1; i++){
				// 初始化一个布尔值
				boolean flag = true;
				for(int j = 0; j < arr.length - i - 1 ; j++){
					if(arr[j] > arr[j+1]){
						// 调换
						int temp;
						temp = arr[j];
						arr[j] = arr[j+1];
						arr[j+1] = temp;
						temp = arr2[j];
						arr2[j] = arr2[j+1];
						arr2[j+1] = temp;

						// 改变flag
						flag = false;
					}
				}
				if(flag){
					break;
				}
			}
		}
	}

	class MaxQueue {
		Deque<Integer> queue;
		Deque<Integer> help;
		public MaxQueue() {
			queue = new ArrayDeque<>();
			help = new ArrayDeque<>();
		}

		public int max_value() {
			return queue.isEmpty()?-1:help.peek();
		}

		public void push_back(int value) {
			queue.offer(value);
			while(!help.isEmpty()&&value<help.peekLast()){
				help.pollLast();
			}
			help.offer(value);
		}

		public int pop_front() {
			if(queue.isEmpty()) return -1;
			int val = queue.pop();
			if(help.peek()==val){
				help.pop();
			}
			return val;
		}
	}
	public int maxPerformance(int n, int[] speed, int[] efficiency, int k) {
		int mod = 10^9+7;
		sortPlus(efficiency,speed);
		MaxQueue minQueue = new MaxQueue();
		int sp = 0;
		for (int i = 0; i < k; i++) {
			minQueue.push_back(efficiency[i]);
			sp+=speed[i];
		}
		int max = sp*minQueue.max_value()%mod;
		for (int i = k; i < n; i++) {
			minQueue.pop_front();
			sp-=speed[i-1];
			minQueue.push_back(efficiency[i]);
			sp+=speed[i];
			max = sp*minQueue.max_value()%mod;
		}
		return max;
	}
	public String compressString(String S) {
		StringBuilder sb = new StringBuilder();
		Stack<Character> stack = new Stack<>();
		int flag=1;
		for (int i = 0; i < S.length(); i++) {
			if (stack.isEmpty()){
				stack.push(S.charAt(i));
			} else if (stack.peek()!=S.charAt(i)){
				sb.append(stack.peek());
				sb.append(flag);
				stack.push(S.charAt(i));
				flag = 1;
			}else {
				flag++;
			}
		}
		sb.append(stack.peek());
		sb.append(flag);
		return sb.length()>=S.length()?S:sb.toString();
	}
	public int countCharacters2(String[] words, String chars) {
		int[] dict = new int[26];
		int ans = 0;
		for (char c : chars.toCharArray()) {
			dict[c-'a']++;
		}
		for (int i = 0; i < words.length; i++) {
			Map<Integer,Integer> map = new HashMap<>();
			for (int j = 0; j < words[i].length(); j++) {
				if (map.containsKey(words[i].charAt(j)-'a')){
					map.put(words[i].charAt(j)-'a',map.get(words[i].charAt(j)-'a')+1);
				}else {
					map.put(words[i].charAt(j)-'a',1);
				}
			}
			int flag = 0;
			Set<Entry<Integer, Integer>> entries = map.entrySet();
			for (Entry<Integer, Integer> entry : entries) {
				if (dict[entry.getKey()]<entry.getValue()){
					flag =1;
					break;
				}
			}
			if (flag==0){
				ans +=words[i].length();
			}
		}
		return ans;
	}
	public int longestPalindrome(String s) {
		HashMap<Character,Integer> hash = new HashMap<>();
		for (int i = 0; i < s.length(); i++) {
			if (hash.containsKey(s.charAt(i))){
				hash.put(s.charAt(i),hash.get(s.charAt(i))+1);
			}else {
				hash.put(s.charAt(i),1);
			}
		}
		int ans = 0;
		int flag = 1;
		Set<Entry<Character, Integer>> entries = hash.entrySet();
		for (Entry<Character, Integer> entry : entries) {
			Integer value = entry.getValue();
			if (value%2==0){
				ans+=value;
			}else if (value>2){
				ans = ans + value/2*2;
				flag = 1;
			}else {
				flag = 1;
			}
		}
		return ans + flag;
	}
	public boolean check409(String s){
		StringBuilder sb = new StringBuilder();
		for (int i = s.length()-1; i >= 0; i++) {
			sb.append(s.charAt(i));
		}
		return sb.toString().equals(s);
	}
	public int[] getLeastNumbers(int[] arr, int k) {
		TreeSet<Integer> set = new TreeSet<>();
		int[] ans = new int[k];
		for (int i = 0; i < arr.length; i++) {
			set.add(arr[i]);
		}
		for (int i = 0; i < k; i++) {
			ans[i]=set.first();
			set.remove(set.first());
		}
		System.arraycopy(ans,0,ans,0,k);
		return ans;
	}
	public boolean canMeasureWater(int x, int y, int z) {
		List<Integer> list = Arrays.asList(0,0);
		Set<List<Integer>> set = new HashSet<>();
		Queue<List<Integer>> queue = new LinkedList<>();
		queue.add(list);
		while (!queue.isEmpty()){
			List<Integer> remove = queue.remove();
			int cur_x = remove.get(0);
			int cur_y = remove.get(1);
			if (cur_x==z||cur_y==z || cur_x+cur_y==z){
				return true;
			}
			// x 满
			List<Integer> t1 = Arrays.asList(x,cur_y);
			if (!set.contains(t1)){
				set.add(t1);
				queue.offer(t1);
			}
			// y 满
			List<Integer> t2 = Arrays.asList(cur_x,y);
			if (!set.contains(t2)){
				set.add(t2);
				queue.offer(t2);
			}
			// x 清空
			List<Integer> t3 = Arrays.asList(0,cur_y);
			if (!set.contains(t3)){
				set.add(t3);
				queue.offer(t3);
			}
			// y 清空
			List<Integer> t4 = Arrays.asList(cur_x,0);
			if (!set.contains(t4)){
				set.add(t4);
				queue.offer(t4);
			}
			// x给y倒满
			List<Integer> t5 = (cur_x + cur_y >= y) ?
					Arrays.asList(cur_x + cur_y - y, y) :
					Arrays.asList(0, cur_x + cur_y);
			if (!set.contains(t5)){
				set.add(t5);
				queue.offer(t5);
			}
			// y给x倒满
			List<Integer> t6 = (cur_x + cur_y >= x) ?
					Arrays.asList(x, cur_x + cur_y - x) :
					Arrays.asList(cur_x + cur_y, 0);
			if (!set.contains(t6)){
				set.add(t6);
				queue.offer(t6);
			}
		}
		return false;
	}
	public int minIncrementForUnique(int[] A) {
		Arrays.sort(A);
		int res = 0;
		for(int i=1;i<A.length;i++) {
			if(A[i] == A[i-1]) {
				A[i]++;
				res++;
			} else if(A[i] < A[i-1]) {
				res += A[i-1] - A[i] + 1;
				A[i] = A[i-1] + 1;
			}
		}
		return res;
	}
	public int[] createTargetArray(int[] nums, int[] index) {
		List<Integer> list = new ArrayList<>();
		for (int i = 0; i < nums.length; i++) {
			list.add(index[i],nums[i]);
		}
		int[] ans = new int[index.length];
		for (int i = 0; i < nums.length; i++) {
			ans[i] = list.get(i);
		}
		return ans;
	}
	public int sumFourDivisors(int[] nums) {
		int ans = 0;
		Map<Integer,Set<Integer>> map = new HashMap<>();
		Set<Integer> no = new HashSet<>();
		for (int i = 0; i < nums.length; i++) {
			Set<Integer> set = new HashSet<>();
			int flag = 0;
			if (map.containsKey(nums[i])){
				Set<Integer> list = map.get(nums[i]);
				for (Integer integer : list) {
					ans += integer;
				}
				continue;
			}else if (no.contains(nums[i])) continue;
			for (int j = 1; j <= Math.sqrt(nums[i]); j++) {
				if (nums[i]%j==0){
					set.add(j);
					set.add(nums[i]/j);
				}
				if (set.size()>4){
					flag = 1;
					break;
				}
			}
			if (flag==0 && set.size()==4){
				map.put(nums[i],set);
				for (Integer integer : set) {
					ans += integer;
				}
			}else {
				no.add(nums[i]);
			}
		}
		return ans;
	}
	public boolean hasValidPath(int[][] grid) {
		// 1 横 左右
		// 2 竖 上下
		// 3 转弯 右下
		// 4 转弯 下右
		// 5 转弯 右上
		// 6 转弯 上右
		int flag = 1;
		int r = 0,l = 0;
		Queue<List<Integer>> queue = new LinkedList<>();
		queue.offer(Arrays.asList(r,l));
		Set<List<Integer>> set = new HashSet<>();
		while (!queue.isEmpty()){
			int n = queue.size();
			for (int i = 0; i < n; i++) {
				List<Integer> remove = queue.remove();
				r = remove.get(0);
				l = remove.get(1);
				if (r<0||r>=grid.length || l<0 || l>=grid[0].length){
					continue;
				}
				if (set.contains(Arrays.asList(r,l)))
					continue;
				else
					set.add(Arrays.asList(r,l));
				if (grid[r][l] == 1){
					if (check(r,l+1,grid) && (grid[r][l+1]==3 || grid[r][l+1]==1 ||grid[r][l+1]==5))
						queue.offer(Arrays.asList(r,l+1));
					if (check(r,l-1,grid) && (grid[r][l-1]==4 || grid[r][l-1]==1 ||grid[r][l-1]==6))
						queue.offer(Arrays.asList(r,l-1));
				}else if (grid[r][l] == 2){
					if (check(r+1,l,grid) && (grid[r+1][l]==6 || grid[r+1][l]==2 ||grid[r+1][l]==5))
						queue.offer(Arrays.asList(r+1,l));
					if (check(r-1,l,grid) && (grid[r-1][l]==3 || grid[r-1][l]==2 ||grid[r-1][l]==4))
						queue.offer(Arrays.asList(r-1,l));
				}else if (grid[r][l] == 3){
					if (check(r+1,l,grid) && (grid[r+1][l]==6 || grid[r+1][l]==5 ||grid[r+1][l]==2))
						queue.offer(Arrays.asList(r+1,l));
					if (check(r,l-1,grid) && (grid[r][l-1]==1 || grid[r][l-1]==4 || grid[r][l-1]==6))
						queue.offer(Arrays.asList(r,l-1));
				} else if (grid[r][l] == 4){
					if (check(r+1,l,grid) && (grid[r+1][l]==6 || grid[r+1][l]==5 ||grid[r+1][l]==2))
						queue.offer(Arrays.asList(r+1,l));
					if (check(r,l+1,grid) && (grid[r][l+1]==1 || grid[r][l+1]==3 || grid[r][l+1]==5))
						queue.offer(Arrays.asList(r,l+1));
				} else if (grid[r][l] == 5){
					if (check(r-1,l,grid) && (grid[r-1][l]==2 || grid[r-1][l]==4 ||grid[r-1][l]==3))
						queue.offer(Arrays.asList(r-1,l));
					if (check(r,l-1,grid) && (grid[r][l-1]==1 || grid[r][l-1]==4 || grid[r][l-1]==6))
						queue.offer(Arrays.asList(r,l-1));
				}else if (grid[r][l] == 6){
					if (check(r-1,l,grid) && (grid[r-1][l]==2 || grid[r-1][l]==4 ||grid[r-1][l]==3))
						queue.offer(Arrays.asList(r-1,l));
					if (check(r,l+1,grid) && (grid[r][l+1]==1 || grid[r][l+1]==3 || grid[r][l+1]==5))
						queue.offer(Arrays.asList(r,l+1));
				}
			}
		}
		return set.contains(Arrays.asList(grid.length-1,grid[0].length-1));
	}
	public boolean check(int r,int l,int[][] grid){
		if (r<0||r>=grid.length || l<0 || l>=grid[0].length){
			return false;
		}
		return true;
	}
	public String longestPrefix(String s) {
		char c = s.charAt(0);
		for (int i = 1; i < s.length(); i++) {
			int index = s.indexOf(c, i);
			if (index == -1){
				return "";
			}
			String s1 = s.substring(index, s.length());
			String s2 = s.substring(0, s.length() - index);
			if (s1.equals(s2)){
				return s1;
			} else {
				i = index;
			}
		}
		return "";
	}
	public int findTheDistanceValue(int[] arr1, int[] arr2, int d) {
		int ans = 0;
		for (int i = 0; i < arr2.length; i++) {
			int flag = 0;
			for (int j = 0; j < arr1.length; j++) {
				if (Math.abs(arr1[i]-arr2[j])<=d){
					flag = 1;
					break;
				}
			}
			if (flag==0){
				ans++;
			}
		}
		return ans;
	}
	public int maxNumberOfFamilies(int n, int[][] reservedSeats) {
		Map<Integer,List<Integer>> map = new HashMap<>();
		for (int i = 0; i < reservedSeats.length; i++) {
			if (map.containsKey(reservedSeats[i][0])){
				map.get(reservedSeats[i][0]).add(reservedSeats[i][1]);
			}else {
				List<Integer> tem = new ArrayList<>();
				tem.add(reservedSeats[i][1]);
				map.put(reservedSeats[i][0],tem);
			}
		}
		int ans = 0;
		Set<Integer> set = map.keySet();
		ans+= (n-set.size())*2;
		for (Integer integer : set) {
			List<Integer> list = map.get(integer);
			Collections.sort(list);
			if ((list.contains(2)||list.contains(3)) && ((!list.contains(4) && !list.contains(5) && !list.contains(6) && !list.contains(7))||
					(!list.contains(6) && !list.contains(7) && !list.contains(8) && !list.contains(9)))){
				ans++;
			}else if ((list.contains(8)||list.contains(9)) && ((!list.contains(4) && !list.contains(5) && !list.contains(6) && !list.contains(7))||
					(!list.contains(2) && !list.contains(3) && !list.contains(4) && !list.contains(5)))){
				ans++;
			}else if ((!list.contains(4) && !list.contains(5) && !list.contains(6) && !list.contains(7))&&
					(!list.contains(2) && !list.contains(3) && !list.contains(8) && !list.contains(9))){
				ans+=2;
			}else if ((!list.contains(4) && !list.contains(5) && !list.contains(6) && !list.contains(7))){
				ans+=1;
			}else if ((!list.contains(2) && !list.contains(3) && !list.contains(4) && !list.contains(5))){
				ans++;
			}else if ((!list.contains(6) && !list.contains(7) && !list.contains(8) && !list.contains(9))){
				ans++;
			}
		}
		return ans;
	}
	public int getKth(int lo, int hi, int k) {
		List<int[]> list = new ArrayList<>();
		for (int i = lo; i <= hi; i++) {
			int t = i,count = 0;
			while (t!=1){
				count++;
				if(t%2==1){
					t = t * 3 + 1;
				}else {
					t /=2;
				}
			}
			list.add(new int[]{i,count});
		}
		Collections.sort(list,(o1, o2) -> {return o1[1]-o2[1];});
		return list.get(k-1)[0];
	}
	public ListNode middleNode(ListNode head) {
		int n = 0;
		ListNode p = head;
		while (head!=null){
			n++;
			head = head.next;
		}
		int flag = n/2;
		while (flag>0){
			flag--;
			p = p.next;
		}
		return p;
	}
	public int massage(int[] nums) {
		if (nums.length==0)return 0;
		if (nums.length==1)return nums[0];
		int[] dp = new int[nums.length];
		dp[0]=nums[0];
		dp[1]=Math.max(nums[1],nums[0]);
		for (int i = 2; i < nums.length; i++) {
			dp[i] = Math.max(dp[i-1],dp[i-2]+nums[i]);
		}
		return dp[nums.length-1];
	}
	public int surfaceArea(int[][] grid) {
		int max = 0;
		for (int i = 0; i < grid.length; i++) {
			for (int j = 0; j < grid[i].length; j++) {
				max = Math.max(max,grid[i][j]);
			}
		}
		int ans = 0;
		for (int i = 1; i <= max; i++) {
			for (int j = 0; j < grid.length; j++) {
				for (int k = 0; k < grid[j].length; k++) {
					if(grid[j][k]>i)ans+=5;
					else if(grid[j][k]==i)ans+=6;
					else if (grid[j][k]>i)ans-=1;
					else continue;
					if (check892(j-1,k,grid.length,grid[j].length) && grid[j-1][k]>=i){
						ans--;
					}
					if (check892(j+1,k,grid.length,grid[j].length) && grid[j+1][k]>=i){
						ans--;
					}
					if (check892(j,k-1,grid.length,grid[j].length) && grid[j][k-1]>=i){
						ans--;
					}
					if (check892(j,k+1,grid.length,grid[j].length) && grid[j][k+1]>=i){
						ans--;
					}
				}
			}
		}
		return ans;
	}
	public boolean check892(int i,int j,int length,int length2){
		if (i<0||i>=length||j<0||j>=length2)
			return false;
		return true;
	}
	public int numRookCaptures(char[][] board) {
		int r = 0,l=0;
		int ans = 0;
		for (int i = 0; i < board.length; i++) {
			for (int j = 0; j < board[i].length; j++) {
				if (board[i][j] == 'R'){
					r=i;
					l=j;
					break;
				}
			}
		}
		for (int i = r+1; i < board.length; i++) {
			if (board[i][l] !='.'){
				if (board[i][l] == 'p') ans++;
				break;
			}
		}
		for (int i = r-1; i >=0; i--) {
			if (board[i][l] !='.'){
				if (board[i][l] == 'p') ans++;
				break;
			}
		}
		for (int i = l-1; i >=0; i--) {
			if (board[r][i] !='.'){
				if (board[r][i] == 'p') ans++;
				break;
			}
		}
		for (int i = l+1; i < board[0].length; i++) {
			if (board[r][i] !='.'){
				if (board[r][i] == 'p') ans++;
				break;
			}
		}
		return ans;
	}
	public boolean hasGroupsSizeX1(int[] deck) {
		Map<Integer,Integer> hashMap = new HashMap<>();
		for (int i = 0; i < deck.length; i++) {
			if (hashMap.containsKey(deck[i])){
				hashMap.put(deck[i],hashMap.get(deck[i])+1);
			}else {
				hashMap.put(deck[i],1);
			}
		}
		Set<Integer> set = hashMap.keySet();
		for (int i = 2; i <= deck.length/2; i++) {
			int flag = 0;
			for (Integer integer : set) {
				if (hashMap.get(integer)<i)return false;
				if (hashMap.get(integer)%i!=0){
					flag=1;
					break;
				}
			}
			if (flag==0) return true;
		}
		return false;
	}
	public String sortString(String s) {
		int[] dict = new int[26];
		for (char c : s.toCharArray()) {
			dict[c-'a']++;
		}
		StringBuilder sb = new StringBuilder();
		int ret = s.length();
		while (ret>0){
			int flag =0;
			for (int i = 0; i < 26; i++) {
				if (flag==3)break;
				if (dict[i]>0){
					sb.append((char)(i+'a'));
					dict[i]--;
					ret--;
					flag++;
				}
			}
			flag = 0;
			for (int i = 25; i >= 0; i--) {
				if (flag==3)break;
				if (dict[i]>0){
					sb.append((char)(i+'a'));
					dict[i]--;
					ret--;
					flag++;
				}
			}
		}
		return sb.toString();
	}
	public int findTheLongestSubstring(String s) {
		int n = s.length();
		int l = 0,r = 0;
		int ans = 0;
		int indexA = 0,indexE = 0,indexI = 0,indexO=0,indexU=0;
		if (s.charAt(r) == 'a'){
			indexA++;
		}else if (s.charAt(r)=='e'){
			indexE++;
		}else if (s.charAt(r)=='i'){
			indexI++;
		}else if (s.charAt(r)=='o'){
			indexO++;
		}else if (s.charAt(r)=='u'){
			indexU++;
		}
		while (l<r && r<n){
			r++;
			if (s.charAt(r) == 'a'){
				indexA++;
			}else if (s.charAt(r)=='e'){
				indexE++;
			}else if (s.charAt(r)=='i'){
				indexI++;
			}else if (s.charAt(r)=='o'){
				indexO++;
			}else if (s.charAt(r)=='u'){
				indexU++;
			}
			if (indexA%2==0&&indexE%2==0&&indexI%2==0&&indexO%2==0&&indexU%2==0){
				ans = Math.max(ans,r-l+1);
			}else {
				if (s.charAt(l) == 'a'){
					indexA--;
				}else if (s.charAt(l)=='e'){
					indexE--;
				}else if (s.charAt(l)=='i'){
					indexI--;
				}else if (s.charAt(l)=='o'){
					indexO--;
				}else if (s.charAt(l)=='u'){
					indexU--;
				}
				l++;
			}

		}
		return ans;
	}
	public int findMaxConsecutiveOnes(int[] nums) {
		int ans = 0;
		int flag = 0;
		int l = 0,r=-1;
		while (r<nums.length){
			if (nums[++r]==0){
				ans=Math.max(ans,r-l);
				l=r+1;
			}
		}
		if (nums[nums.length-1]==1){
			ans=Math.max(ans,nums.length);
		}
		return ans;
	}
	public int minimumLengthEncoding(String[] words) {
		int n = words.length;
		Arrays.sort(words,(o1, o2) -> o2.length()-o1.length());
		int ans = 0;
		int sum = 0;
		int flag = 0;
		List<Integer> list = new ArrayList<>();
		for (int i = 0; i < n; i++) {
			sum+=words[i].length();
			for (int j = i+1; j < n; j++) {
				if (list.contains(j))continue;
				if (words[i].substring(words[i].length()-words[j].length(),words[i].length()).equals(words[j])){
					ans+=words[j].length();
					list.add(j);
					flag++;
				}
			}
		}
		return sum-ans+n-flag;
	}
	public int maxDistance(int[][] grid) {
		List<int[]> hy = new ArrayList<>();
		for (int i = 0; i < grid.length; i++) {
			for (int j = 0; j < grid[i].length; j++) {
				if (grid[i][j]==0){
					hy.add(new int[]{i,j});
				}
			}
		}
		int ans = -1;
		for (int i = 0; i < hy.size(); i++) {
			int dict = bfs1162(hy.get(i), grid);
			ans = Math.max(dict,ans);
		}
		return ans;
	}
	public int bfs1162(int[] hy,int[][] grid){
		Queue<int[]> queue = new LinkedList<>();
		boolean[][] vis = new boolean[grid.length][grid[0].length];
		queue.offer(hy);
		vis[hy[0]][hy[1]]=true;
		int flag = 0;
		while (!queue.isEmpty()){
			flag++;
			int n = queue.size();
			for (int i = 0; i < n; i++) {
				int[] remove = queue.remove();
				if (vis[remove[0]][remove[1]]){
					continue;
				}else {
					vis[remove[0]][remove[1]] = true;
				}
				if (remove[0]-1>=0){
					if (grid[remove[0]-1][remove[1]]==1){
						return flag;
					}else {
						queue.offer(new int[]{remove[0]-1,remove[1]});
					}
				}
				if (remove[0]+1<grid.length){
					if (grid[remove[0]+1][remove[1]]==1){
						return flag;
					}else {
						queue.offer(new int[]{remove[0]+1,remove[1]});
					}
				}
				if (remove[1]+1<grid[0].length){
					if (grid[remove[0]][remove[1]+1]==1){
						return flag;
					}else {
						queue.offer(new int[]{remove[0],remove[1]+1});
					}
				}
				if (remove[1]-1>=0){
					if (grid[remove[0]][remove[1]-1]==1){
						return flag;
					}else {
						queue.offer(new int[]{remove[0],remove[1]-1});
					}
				}
			}
		}
		return -1;
	}
	public int findLucky(int[] arr) {
		int[] dict = new int[550];
		for (int i = 0; i < arr.length; i++) {
			dict[arr[i]]++;
		}
		for (int i = 549; i >=0; i--) {
			if (dict[i]==i)return i;
		}
		return -1;
	}
	public int numTeams(int[] rating) {
		int ans = 0;
		for (int i = 0; i < rating.length; i++) {
			for (int j = i+1; j < rating.length; j++) {
				for (int k = j+1; k < rating.length; k++) {
					if (rating[i]>rating[j] && rating[j]>rating[k]){
						ans++;
					}else if (rating[i]<rating[j] && rating[j]<rating[k]){
						ans++;
					}
				}
			}
		}
		return ans;
	}
	public int lastRemaining(int n, int m) {
		ArrayList<Integer> list = new ArrayList<>(n);
		for (int i = 0; i < n; i++) {
			list.add(i);
		}
		int idx = 0;
		while (n > 1) {
			idx = (idx + m - 1) % n;
			list.remove(idx);
			n--;
		}
		return list.get(0);
	}
	public int[] maxDepthAfterSplit(String seq) {
		int n = seq.length();
		int[] ret = new int[n];
		int ans = 0;
		for (int i = 0; i < n; i++) {
			if (seq.charAt(i)=='('){
				ans++;
				ret[i] = ans%2==1?1:0;
			}else {
				ret[i] = ans%2==1?1:0;
				ans--;
			}
		}
		return ret;
	}
	// 2 活变到死 -1死变到活

	public void gameOfLife(int[][] board) {
		for (int i = 0; i < board.length; i++) {
			for (int j = 0; j < board[i].length; j++) {
				int count = 0;
				if (helper289(board,i-1,j))count++;
				if (helper289(board,i+1,j))count++;
				if (helper289(board,i-1,j-1))count++;
				if (helper289(board,i-1,j+1))count++;
				if (helper289(board,i+1,j-1))count++;
				if (helper289(board,i+1,j+1))count++;
				if (helper289(board,i,j-1))count++;
				if (helper289(board,i,j+1))count++;
				if (board[i][j]==1 && (count<=2 || count>3)){
					board[i][j] = 2;
				}else if (board[i][j]==0 && count==3){
					board[i][j] = -1;
				}
			}
		}
		for (int i = 0; i < board.length; i++) {
			for (int j = 0; j < board[i].length; j++) {
				if (board[i][j]==2)board[i][j] = 0;
				else if (board[i][j]==-1)board[i][j] = 1;
			}
		}
	}
	public boolean helper289(int[][] board,int r,int l){
		if (r<0||r>=board.length || l<0||l>=board[r].length){
			return false;
		}
		if (board[r][l]>=1)return true;
		return false;
	}
	public int myAtoi(String str) {
		String trim = str.trim();
		int flag  = 0;
		int start = 0;

		if (trim.length()>0 && trim.charAt(0)=='-'){
			start=1;
			flag=-1;
		}else if(trim.length()>0 && trim.charAt(0)=='+'){
			start=1;
			flag=1;
		}
		StringBuilder sb = new StringBuilder();
		for (; start < trim.length(); start++) {
			if (trim.charAt(start)>='0'&&trim.charAt(start)<='9'){
				sb.append(trim.charAt(start));
			}
		}
		int count = 0;
		for (int i = 0; i < sb.length(); i++) {
			if (sb.charAt(i)=='0'){
				count++;
			}else {
				break;
			}
		}
		if (sb.length()-count>=11){
			if (flag==-1)return Integer.MIN_VALUE;
			else return Integer.MAX_VALUE;
		}
		long v = Long.parseLong(sb.toString());
		if (v>Integer.MAX_VALUE){
			v=Integer.MAX_VALUE;
		}
		if (flag==-1)v=-v;
		return ((Long)v).intValue();
	}
	public int trap2(int[] height) {
		Stack<Integer> stack = new Stack<>();
		int ans = 0;
		for (int i = 0; i < height.length; i++) {
			while (!stack.isEmpty() && height[stack.peek()]<height[i]){
				Integer pop = stack.pop();
				if (!stack.isEmpty()){
					ans = ans+ (Math.min(height[i],height[stack.peek()])-height[pop])*(i-stack.peek()-1);
				}
			}
			stack.push(i);
		}
		return ans;
	}

	public int countLargestGroup(int n) {
		int[] dict = new int[10000+10];
		int max = 0;
		for (int i = 1; i <= n; i++) {
			int t = i;
			int sum = 0;
			while (t!=0){
				sum+=t%10;
				t/=10;
			}
			dict[sum]++;
			max = Math.max(dict[sum],max);
		}
		int ans = 0;
		for (int i = 0; i < dict.length; i++) {
			if (max==dict[i]){
				ans++;
			}
		}
		return ans;
	}
	public boolean canConstruct(String s, int k) {
		int[] dict = new int[26];
		int n = s.length();
		if (n<k)return false;
		for (int i = 0; i < n; i++) {
			dict[s.charAt(i)-'a']++;
		}
		int t1=0,t2=0;//单个的  两个的
		for (int i = 0; i < 26; i++) {
			if (dict[i]!=0){
				if (dict[i]%2==0){
					t2+=dict[i]/2;
				}else if (dict[i]==1){
					t1++;
				}else if (dict[i]%2==1){
					t2+=dict[i]/2;
					t1++;
				}
			}
		}
		if (t1>k)return false;
		return true;
	}
	public boolean checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {
		// 左边 x1,y1 - x1 y2  下边 x1.y1 - x2.y1
		// 右边 x2,y1 - x2 y2  上边 x1.y2 - x2.y2
		if (x_center+radius>=x1 && x_center+radius<=x2 && y_center+radius>=y1 && y_center+radius<=y2){
			return true;
		}
		for (int i = y1; i <= y2; i++) {
			if ((x1-x_center)*(x1-x_center)+(i-y_center)*(i-y_center)<=radius*radius){
				return true;
			}
		}
		for (int i = x1; i <= x2; i++) {
			if ((i-x_center)*(i-x_center)+(y1-y_center)*(y1-y_center)<=radius*radius){
				return true;
			}
		}
		for (int i = y1; i <= y2; i++) {
			if ((x2-x_center)*(x2-x_center)+(i-y_center)*(i-y_center)<=radius*radius){
				return true;
			}
		}
		for (int i = x1; i <= x2; i++) {
			if ((i-x_center)*(i-x_center)+(y2-y_center)*(y2-y_center)<=radius*radius){
				return true;
			}
		}
		return false;
	}
	// -1 + 0+9+20
	// -2 -2 0 12 25
	// -3 -4 -3 0 15 30
	public int maxSatisfaction(int[] satisfaction) {
		Arrays.sort(satisfaction);
		List<Integer> fushu = new ArrayList<>();
		List<Integer> zhengshu = new ArrayList<>();
		int n = satisfaction.length;
		int ans = 0;
		for (int i = 0; i < n; i++) {
			if (satisfaction[i]>=0){
				zhengshu.add(satisfaction[i]);
				ans += zhengshu.size()*satisfaction[i];
			}else {
				fushu.add(0,satisfaction[i]);
			}
		}
		for (Integer integer : fushu) {
			System.out.println(integer);
		}
		for (int i = 0; i < fushu.size(); i++) {
			int flag = 0;
			int t = 0;
			for (int j = i; j >= 0; j--) {
				flag++;
				t+=flag*fushu.get(j);
			}
			for (int j = 0; j < zhengshu.size(); j++) {
				flag++;
				t+=flag*zhengshu.get(j);
			}
			ans = Math.max(t,ans);
		}
		return ans;
	}
	public List<Integer> minSubsequence(int[] nums) {
		int n = nums.length;
		int max = 0;
		for (int i = 0; i < n; i++) {
			max+=nums[n];
		}
		Arrays.sort(nums);
		List<Integer> ans = new ArrayList<>();
		int temp = 0;
		for (int i = n-1; i >=0 ; i--) {
			ans.add(nums[i]);
			temp+=nums[i];
			max-=nums[i];
			if (temp>max)return ans;
		}
		return ans;
	}
	public int numSteps(String s) {
		StringBuilder sb = new StringBuilder(s);
		StringBuilder reverse = sb.reverse();
		int ans = 0;
		while (reverse.length()>1){
			ans++;
			if (reverse.charAt(0)=='0'){
				reverse.deleteCharAt(0);
			}else {
				int flag = 0;
				for (int i = 0; i < reverse.length(); i++) {
					if (reverse.charAt(i)=='0'){
						reverse.replace(i,i+1,"1");
						flag=1;
						break;
					}else {
						reverse.replace(i,i+1,"0");
					}
				}
				if (flag==0){
					reverse.append('1');
				}
			}
		}
		return reverse.charAt(0)=='1'?ans:ans+1;
	}
	public String longestDiverseString(int a, int b, int c) {
		StringBuilder sb = new StringBuilder();
		dfs5195(sb,a,b,c);

		return sb.toString();
	}
	public void dfs5195(StringBuilder sb,int a,int b,int c){
		if (a==0 && b==0 && c==0)return;
		if (sb.length()>0){
			char c1 = sb.charAt(sb.length()-1);
			if (c1=='a' && b==0 && c==0)return;
			if (c1=='b' && a==0 && c==0)return;
			if (c1=='c' && b==0 && a==0)return;
		}
		if (sb.length()==0){
			if (a>=b && a>=c){
				if (a>=2) {
					sb.append("aa");
					a-=2;
				}else {
					sb.append('a');
					a--;
				}
			} else if (b>=a && b>=c){
				if (b>=2) {
					sb.append("bb");
					b-=2;
				}else {
					sb.append('b');
					b--;
				}
			}else if (c>=a && c>=b){
				if (c>=2) {
					sb.append("cc");
					c-=2;
				}else {
					sb.append('c');
					c--;
				}
			}
		}else {
			char last = sb.charAt(sb.length()-1);
			if (last=='a'){
				if (b>=c){
					if (a>b){
						sb.append('b');
						b--;
					}else if (b>=2) {
						sb.append("bb");
						b-=2;
					}else {
						sb.append('b');
						b--;
					}
				}else {
					if (a>c){
						sb.append('c');
						c--;
					}else if (c>=2) {
						sb.append("cc");
						c-=2;
					}else {
						sb.append('c');
						c--;
					}
				}
			}else if (last=='b'){
				if (a>=c){
					if (b>a){
						sb.append('a');
						a--;
					}else if (a>=2) {
						sb.append("aa");
						a-=2;
					}else {
						sb.append('a');
						a--;
					}
				}else {
					if (b>c){
						sb.append('c');
						c--;
					}else if (c>=2) {
						sb.append("cc");
						c-=2;
					}else {
						sb.append('c');
						c--;
					}
				}
			}else if (last=='c'){
				if (a>=b){
					if (c>a){
						sb.append('a');
						a--;
					}else if (a>=2) {
						sb.append("aa");
						a-=2;
					}else {
						sb.append('a');
						a--;
					}
				}else {
					if (c>b){
						sb.append('b');
						b--;
					}else if (b>=2) {
						sb.append("bb");
						b-=2;
					}else {
						sb.append('b');
						b--;
					}
				}
			}
		}
		dfs5195(sb,a,b,c);
	}
	// word1 -> word2
	public int minDistance(String word1, String word2) {
		int n = word1.length();
		int m = word2.length();

		// 有一个字符串为空串
		if (n * m == 0)
			return n + m;

		// DP 数组
		int [][] D = new int[n + 1][m + 1];

		// 边界状态初始化
		for (int i = 0; i < n + 1; i++) {
			D[i][0] = i;
		}
		for (int j = 0; j < m + 1; j++) {
			D[0][j] = j;
		}

		// 计算所有 DP 值
		for (int i = 1; i < n + 1; i++) {
			for (int j = 1; j < m + 1; j++) {
				int left = D[i - 1][j] + 1;
				int down = D[i][j - 1] + 1;
				int left_down = D[i - 1][j - 1];
				if (word1.charAt(i - 1) != word2.charAt(j - 1))
					left_down += 1;
				D[i][j] = Math.min(left, Math.min(down, left_down));

			}
		}
		return D[n][m];
	}
	public void rotate(int[][] matrix) {
		// a[0] -> a[n][length-1]
		int n1 = matrix.length;
		int n2 = matrix.length;
		for (int i = 1; i < n1; i++) {
			for (int j = 0; j < i; j++) {
				int t = matrix[i][j];
				matrix[i][j] = matrix[j][i];
				matrix[j][i] = t;
			}
		}
		for (int i = 0; i < n1; i++) {
			for (int j = 0; j < n2; j++) {
				System.out.print(matrix[i][j]+',');
			}
			System.out.println("");
		}
	}
	public int movingCount(int m, int n, int k) {
		boolean[][] vis = new boolean[m][n];
		dfsMst13(vis,0,0,k);
		int ans = 0;
		for (int i = 0; i < m; i++) {
			for (int j = 0; j < n; j++) {
				if (vis[i][j]){
					ans++;
				}
			}
		}
		return ans;
	}
	public void dfsMst13(boolean[][] vis,int m,int n,int k){
		if (m<0 ||m>=vis.length || n < 0 || n>=vis[m].length)return;
		int count = 0;
		int r = m;
		int l = n;
		if (vis[m][n])return;
		while (r!=0){
			count+=r%10;
			r/=10;
		}
		while (l!=0){
			count+=l%10;
			l/=10;
		}
		if (count<=k) vis[m][n]=true;
		else return;
		dfsMst13(vis,m-1,n,k);
		dfsMst13(vis,m,n+1,k);
		dfsMst13(vis,m+1,n,k);
		dfsMst13(vis,m,n-1,k);
	}
	List<String> ans0409;
	public List<String> generateParenthesis2(int n) {
		ans0409 = new ArrayList<>();
		dfs0409(0,n*2,new StringBuilder());
		return ans0409;
	}
	public void dfs0409(int leftCnt,int n,StringBuilder sb){
		if (sb.length()==n){
			ans0409.add(sb.toString());
			return;
		}
		if (leftCnt>0){
			sb.append(')');
			dfs0409(leftCnt-1,n,sb);
			sb.deleteCharAt(sb.length()-1);
		}else {
			sb.append('(');
			dfs0409(leftCnt+1,n,sb);
			sb.deleteCharAt(sb.length()-1);
		}
	}
	public String reverseWords2(String s) {
		String[] split = s.split(" ");
		List<String> dict = new ArrayList<>();
		for (int i = 0; i < split.length; i++) {
			if (!split[i].equals(""))
				dict.add(split[i]);
		}
		StringBuilder ans = new StringBuilder();
		for (int i = dict.size()-1; i >=0 ; i--) {
			if (i!=0){
				ans.append(dict.get(i)+" ");
			}else {
				ans.append(dict.get(i));
			}
		}
		return ans.toString();
	}
	public int superEggDrop(int K, int N) {
		return dp887(K, N);
	}
	Map<Integer, Integer> memo = new HashMap();
	public int dp887(int K, int N) {
		if (!memo.containsKey(N * 100 + K)) {
			int ans;
			if (N == 0)
				ans = 0;
			else if (K == 1)
				ans = N;
			else {
				int lo = 1, hi = N;
				while (lo + 1 < hi) {
					int x = (lo + hi) / 2;
					int t1 = dp887(K-1, x-1);
					int t2 = dp887(K, N-x);

					if (t1 < t2)
						lo = x;
					else if (t1 > t2)
						hi = x;
					else
						lo = hi = x;
				}

				ans = 1 + Math.min(Math.max(dp887(K-1, lo-1), dp887(K, N-lo)),
						Math.max(dp887(K-1, hi-1), dp887(K, N-hi)));
			}

			memo.put(N * 100 + K, ans);
		}

		return memo.get(N * 100 + K);
	}
	public List<String> stringMatching(String[] words) {
		Set<String> set = new HashSet<>();
		for (int i = 0; i < words.length; i++) {
			for (int j = 0; j < words.length; j++) {
				if (i!=j && words[i].indexOf(words[j])!=-1){
					set.add(words[j]);
				}
			}
		}
		List<String> collect = set.stream().collect(Collectors.toList());
		return collect;
	}
	public int[] processQueries(int[] queries, int m) {
		List<Integer> list = new ArrayList<>();
		for (int i = 0; i < m; i++) {
			list.add(i+1);
		}
		int[] ans = new int[queries.length];
		for (int i = 0; i < queries.length; i++) {
			for (int j = 0; j < m; j++) {
				if (list.get(j).equals(queries[i])){
					ans[i]=j;
					Integer integer = list.get(j);
					list.remove(j);
					list.add(0,integer);
				}
			}
		}
		return ans;
	}
	public String entityParser(String text) {
		text = text.replace("&quot;", "\"");
		text = text.replace("&apos;","'");
		text = text.replace("&amp;","&");
		text = text.replace("&gt;",">");
		text = text.replace("&lt;","<");
		text = text.replace("&frasl;","/");
		return text;
	}

	public int numOfWays(int n) {
		int[][] dict = new int[n][3];
		dfs5383(dict,0,0);
		return 1;
	}
	public void dfs5383(int[][]dict,int n,int m){

	}
	public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
		StringBuilder s1 = new StringBuilder();
		StringBuilder s2 = new StringBuilder();
		while (l1!=null){
			s1.append(l1.val);
			l1 = l1.next;
		}
		while (l2!=null){
			s2.append(l2.val);
			l2 = l2.next;
		}
		s1.reverse();
		s2.reverse();
		ListNode head = new ListNode(-1);
		int n = Math.min(s1.length(),s2.length());
		int max = Math.max(s1.length(),s2.length());

		int flag = 0;
		for (int i = 0; i < n; i++) {
			int a = s1.charAt(i)-'0';
			int b = s2.charAt(i)-'0';
			int sum = a+b+flag;
			flag = sum/10;
			sum%=10;
			ListNode p = new ListNode(sum);
			p.next = head.next;
			head.next = p;
		}
		for (int i = n; i < max; i++) {
			char a = s1.length()==n?'0':s1.charAt(i);
			char b = s2.length()==n?'0':s2.charAt(i);
			int n1 = a - '0';
			int n2 = b - '0';
			int sum = n1 +n2 +flag;
			flag = sum/10;
			sum%=10;
			ListNode p = new ListNode(sum);
			p.next = head.next;
			head.next = p;
		}
		if (flag==1){
			ListNode p = new ListNode(1);
			p.next = head.next;
			head.next = p;
		}
		return head.next;
	}
	public int[][] updateMatrix(int[][] matrix) {
		if (matrix == null || matrix.length == 0) return null;
		int m = matrix.length, n = matrix[0].length;
		int[][] res = new int[m][n];//结果集
		boolean[][] visited = new boolean[m][n];//记录已经计算过的位置
		Queue<int[]> queue = new LinkedList<>();//广搜队列
		//遍历，将等于0的位置计入结果集并入队
		for (int i = 0; i < m; i++) {
			for (int j = 0; j < n; j++) {
				if (matrix[i][j] == 0) {
					res[i][j] = 0;
					visited[i][j] = true;
					queue.offer(new int[]{i, j});
				}
			}
		}
		//四个方向广搜
		int[][] direction = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};//上下左右
		while (!queue.isEmpty()) {
			int[] poll = queue.poll();
			int i = poll[0], j = poll[1];
			//四个方向上找 1
			for (int k = 0; k < 4; k++) {
				int di = i + direction[k][0], dj = j + direction[k][1];
				//没有计算过的地方一定是 1
				if (di >= 0 && di < m && dj >= 0 && dj < n && !visited[di][dj]) {
					res[di][dj] = res[i][j] + 1;
					visited[di][dj] = true;
					queue.offer(new int[]{di, dj});
				}
			}
		}
		return res;
	}
	public int[][] merge2(int[][] intervals) {
		int n = intervals.length;
		//int l = intervals[0].length;
		Arrays.sort(intervals,(o1,o2)->{return o1[0]-o2[0];});
		Map<Integer,Integer> map = new HashMap<>();
		int flag = 0;
		for (int i = 0; i < n-1; i++) {
			flag = 0;
			if (intervals[i][1]>=intervals[i+1][0]){
				intervals[i+1][0] = Math.min(intervals[i][0],intervals[i+1][0]);
				intervals[i+1][1] = Math.max(intervals[i][1],intervals[i+1][1]);
				flag=1;
			}
			if (flag==0){
				map.put(intervals[i][0],intervals[i][1]);
			}
		}
		flag=0;
		map.put(intervals[n-1][0],intervals[n-1][1]);
		int res[][] = new int[map.size()][2];
		for (Integer a :map.keySet()) {
			res[flag][0]=a;
			res[flag++][1]=map.get(a);
		}
		return res;
	}
	public int minCount(int[] coins) {
		int ans = 0;
		for(int i = 0;i<coins.length;i++){
			if(coins[i]%2==0){
				ans += coins[i]/2;
			}else{
				ans += coins[i]/2+1;
			}

		}
		return ans;
	}
	int ans0418 = 0;
	public int numWays(int n, int[][] relation, int k) {
		dfs0418(relation,n-1,k,0,0);
		return ans0418;
	}
	public void dfs0418(int[][] relation,int n,int k,int now,int count){
		if (count>k)return;
		if (k==count && now ==n){
			ans0418++;
			return;
		}
		for (int i = 0; i < relation.length; i++) {
			if (relation[i][0]==now){
				dfs0418(relation,n,k,relation[i][1],count+1);
			}
		}

	}
	public int[] getTriggerTime(int[][] increase, int[][] requirements) {
		int[] ans = new int[requirements.length];
		List<int[]> list = new ArrayList<>();
		for (int i = 0; i < requirements.length; i++) {
			list.add(new int[]{requirements[i][0],requirements[i][1],requirements[i][2],i});
		}
		Collections.sort(list,(o1,o2)->{
			if (o1[0]!=o2[0]){
				return o1[0]-o2[0];
			}else{
				if (o1[1]!=o2[1]){
					return o1[1]-o2[1];
				}else if(o1[2]!=o2[2]){
					return o1[2]-o2[2];
				}else{
					return o1[3]-o2[3];
				}
			}
		});
		Arrays.fill(ans,-1);
		int[] me = new int[3];
		for (int j = 0; j < list.size(); j++) {
			if (list.get(j)[0]>me[0])break;
			if (list.get(j)[0]<=me[0] && list.get(j)[1]<=me[1] && list.get(j)[2]<=me[2] && ans[list.get(j)[3]]==-1){
				ans[list.get(j)[3]] = 0;
				list.remove(j);
				j--;
			}
		}
		for (int i = 0; i < increase.length; i++) {
			me[0]+=increase[i][0];
			me[1]+=increase[i][1];
			me[2]+=increase[i][2];
			for (int j = 0; j < list.size(); j++) {
				if (list.get(j)[0]>me[0])break;
				if (list.get(j)[0]<=me[0] && list.get(j)[1]<=me[1] && list.get(j)[2]<=me[2] && ans[list.get(j)[3]]==-1){
					ans[list.get(j)[3]] = i+1;
					list.remove(j);
					j--;
				}
			}
		}
		return ans;
	}
	public int minJump(int[] jump) {
		boolean[] vis = new boolean[jump.length];
		Queue<Integer> queue = new LinkedList<>();
		queue.offer(0);
		int flag = 0;
		while (!queue.isEmpty()){
			flag++;
			int size = queue.size();
			for (int i = 0; i < size; i++) {
				int remove = (int)queue.remove();
				if (remove == jump.length-1) return flag;
				for (int j = 1; j < jump[remove]; j++) {
					if (j+remove<jump.length && !vis[j+remove]){
						vis[j+remove] = true;
						queue.offer(j+remove);
					}
				}
			}
		}
		return 0;
	}
	public int minStartValue(int[] nums) {
		int ans = 1;
		int sum = 0;
		for (int i = 0; i < nums.length; i++) {
			sum+=nums[i];
			ans = Math.min(sum,ans);
		}
		ans = Math.abs(ans);
		return ans==0?1:ans;
	}
	int ans5373 = 0;
	public int findMinFibonacciNumbers(int k) {
		List<Integer> dict = new ArrayList<>();
		ans5373 = k;
		dict.add(1);
		dict.add(1);
		while (k>dict.get(dict.size()-1)){
			dict.add(dict.get(dict.size()-1)+dict.get(dict.size()-2));
		}
		dfs5373(dict,k,0);
		return ans5373;
	}
	public void dfs5373(List<Integer> list,int now,int count){
		if (now==0){
			ans5373 = Math.min(ans5373,count);
			return;
		}
		for (int i = list.size()-1; i >=0 ; i--) {
			if (now>=list.get(i)){
				dfs5373(list,now-list.get(i),count+1);
			}
		}
	}
	List<String> dict5374;
	public String getHappyString(int n, int k) {
		dict5374 = new ArrayList<>();
		StringBuilder sb = new StringBuilder();
		dfs5374(sb,n);
		return dict5374.size()>=k?dict5374.get(k-1):"";
	}
	public void dfs5374(StringBuilder sb,int n){
		if (sb.length()==n){
			dict5374.add(sb.toString());
			return;
		}
		for (int i = 0; i < 3; i++) {
			if (sb.length()==0){
				sb.append((char)('a'+i));
				dfs5374(sb,n);
				sb.deleteCharAt(sb.length()-1);
			}else if (sb.charAt(sb.length()-1)!='a'+i){
				sb.append((char)('a'+i));
				dfs5374(sb,n);
				sb.deleteCharAt(sb.length()-1);
			}
		}
	}
	public String reformat(String s) {
		StringBuilder sb1 = new StringBuilder();
		StringBuilder sb2 = new StringBuilder();
		StringBuilder ans = new StringBuilder();
		for(int i = 0;i<s.length();i++){
			if(s.charAt(i)>='0' && s.charAt(i)<='9'){
				sb1.append(s.charAt(i));
			}else{
				sb2.append(s.charAt(i));
			}
		}
		if(Math.abs(sb1.length()-sb2.length())>1){
			return "";
		}
		if(sb1.length()>sb2.length()){
			for(int i=0;i<sb2.length();i++){
				ans.append(sb1.charAt(i));
				ans.append(sb2.charAt(i));
			}
			ans.append(sb1.charAt(sb1.length()-1));
		}else if (sb2.length()>sb1.length()){
			for(int i=0;i<sb1.length();i++){
				ans.append(sb2.charAt(i));
				ans.append(sb1.charAt(i));
			}
			ans.append(sb2.charAt(sb2.length()-1));
		}else {
			for(int i=0;i<sb1.length();i++){
				ans.append(sb2.charAt(i));
				ans.append(sb1.charAt(i));
			}
		}
		return ans.toString();
	}
	public List<List<String>> displayTable(List<List<String>> orders) {
		Set<String> temp = new HashSet<>();
		Map<Integer,Map<String,Integer>> or = new HashMap<>();
		for (List<String> order : orders) {
			temp.add(order.get(2));
			if (or.containsKey(Integer.parseInt(order.get(1)))){
				Map<String, Integer> tMap = or.get(Integer.parseInt(order.get(1)));
				if (tMap.containsKey(order.get(2))){
					tMap.put(order.get(2),tMap.get(order.get(2))+1);
				}else {
					tMap.put(order.get(2),1);
				}
			}else {
				Map<String,Integer> tMap = new HashMap<>();
				or.put(Integer.parseInt(order.get(1)),tMap);
				tMap.put(order.get(2),1);
			}
		}
		List<List<String>> table = new ArrayList<>();
		List<String> show = temp.stream().collect(Collectors.toList());
		Collections.sort(show);
		show.add(0,"Table");
		Set<Integer> set = or.keySet();
		for (Integer integer : set) {
			Map<String, Integer> sMap = or.get(integer);
			List<String> tList = new ArrayList<>();
			tList.add(String.valueOf(integer));
			for (int i = 1; i < show.size(); i++) {
				if (sMap.containsKey(show.get(i))){
					tList.add(String.valueOf(sMap.get(show.get(i))));
				}else {
					tList.add("0");
				}
			}
			table.add(tList);
		}
		Collections.sort(table,(o1,o2)-> { return Integer.parseInt(o1.get(0))-Integer.parseInt(o2.get(0));});
		table.add(0,show);
		return table;
	}
	public int minNumberOfFrogs(String croakOfFrogs) {
		int n = croakOfFrogs.length();
		int[] dict = new int[5];
		int ans = 0;
		for (int i = 0; i < n; i++) {
			if (croakOfFrogs.charAt(i)=='c'){
				dict[0]++;
			}else if (croakOfFrogs.charAt(i)=='r'){
				dict[1]++;
			}else if (croakOfFrogs.charAt(i)=='o'){
				dict[2]++;
			}else if (croakOfFrogs.charAt(i)=='a'){
				dict[3]++;
			}else if (croakOfFrogs.charAt(i)=='k'){
				dict[4]++;
			}
			int flag = 0;
			for (int j = 0; j < 4; j++) {
				if (dict[j]<dict[j+1]){
					return -1;
				}
				if (dict[j]<1){
					flag=1;
				}
				ans = Math.max(ans,dict[j]);
			}
			ans = Math.max(ans,dict[4]);
			if (flag==0 && dict[4]>=1){
				dict[0]--;
				dict[1]--;
				dict[2]--;
				dict[3]--;
				dict[4]--;
			}
		}
		for (int i = 0; i < 5; i++) {
			if (dict[i]!=0){
				return -1;
			}
		}
		return ans;
	}
	/*int ans5391;
	public int numOfArrays(int n, int m, int k) {
		List<Integer> list = new ArrayList<>();
		dfs5391(n,m,k,list);
		return ans5391;
	}
	public void dfs5391(int n,int m,int k,List<Integer> list){
		if (list.size()==k && )
	}*/
	int[] pre0420;
	int count0420;
	public int numIslands2(char[][] grid) {
		count0420 = grid.length * grid[0].length;
		pre0420 = new int[count0420];
		for (int i = 0; i < count0420; i++) {
			pre0420[i] = i;
		}
		for (int i = 0; i < grid.length; i++) {
			for (int j = 0; j < grid[i].length; j++) {
				if (grid[i][j]=='0'){
					count0420--;
					continue;
				}
				if (i-1>=0 && grid[i][j]=='1' && grid[i-1][j]=='1'){
					union0420(i*grid[0].length+j,(i-1)*grid[0].length+j);
				}
				if (i+1<grid.length && grid[i][j]=='1' && grid[i+1][j]=='1'){
					union0420(i*grid[0].length+j,(i+1)*grid[0].length+j);
				}
				if (j-1>=0 && grid[i][j]=='1' && grid[i][j-1]=='1'){
					union0420(i*grid[0].length+j,i*grid[0].length+(j-1));
				}
				if (j+1>grid[0].length && grid[i][j]=='1' && grid[i][j+1]=='1'){
					union0420(i*grid[0].length+j,i*grid[0].length+(j+1));
				}
			}
		}
		return count0420;
	}
	public int find0420(int i){
		int r = i;
		while (r != pre0420[r]){
			r = pre0420[r];
		}
		return r;
	}
	public void union0420(int i,int j){
		int r1 = find0420(i);
		int r2 = find0420(j);
		if (r1!=r2){
			count0420--;
			pre0420[r1] = r2;
		}
	}
	public List<Integer> rightSideView(TreeNode root) {
		List<Integer> ans = new ArrayList<>();
		if (root==null) return ans;
		Queue<TreeNode> queue = new LinkedList<>();
		queue.offer(root);
		while (!queue.isEmpty()){
			int n = queue.size();
			for (int i = 0; i < n; i++) {
				TreeNode remove = queue.remove();
				if (i==n-1){
					ans.add(remove.val);
				}
				if (remove.left!=null)queue.offer(remove.left);
				if (remove.right!=null)queue.offer(remove.right);
			}
		}
		return ans;
	}
	public int reversePairs(int[] nums) {
		int ans = 0;
		for (int i = 0; i < nums.length; i++) {
			for (int j = i+1; j < nums.length; j++) {
				if (nums[i]>nums[j])ans++;
			}
		}
		return ans;
	}
	List<List<Integer>> ans0425;
	boolean[] vis0425;
	public List<List<Integer>> permute2(int[] nums) {
		ans0425 = new ArrayList<>();
		vis0425 = new boolean[nums.length];
		dfs0425(nums,new ArrayList<>(),vis0425);
		return ans0425;
	}
	public void dfs0425(int[] nums,List<Integer> temp,boolean[] vis){
		if (temp.size() == 3){
			ans0425.add(new ArrayList<>(temp));
		}
		for (int i = 0; i < nums.length; i++) {
			if (!vis[i]){
				temp.add(nums[i]);
				vis[i] = true;
				dfs0425(nums,temp,vis);
				temp.remove(temp.size()-1);
				vis[i] = false;
			}
		}
	}
	public int expectNumber(int[] scores) {
		int ans = 0;
		Map<Integer,Integer> map = new HashMap<>();
		for (int i = 0; i < scores.length; i++) {
			if (map.containsKey(scores[i])){
				map.put(scores[i],map.get(scores[i])+1);
			}else {
				map.put(scores[i],1);
			}
		}
		Set<Integer> set = map.keySet();
		for (Integer integer : set) {
			if (map.get(integer).equals(1)){
				ans++;
			}else {
				ans++;
			}
		}
		return ans;
	}
	/*public int minTime(int[] time, int m) {
		int n = time.length;
		if (n<=m)return 0;

		for (int i = 0; i < n; i++) {

		}
	}*/
	public int maxScore(int[] cardPoints, int k) {
		int n = cardPoints.length;
		int res = 0;
		for (int i = 0; i < k; i++) {
			res+=cardPoints[i];
		}
		int ans = res;

		for (int i = k-1; i >=0 ; i--) {
			res-=cardPoints[i];
			res+=cardPoints[n-1-Math.abs(k-1-i)];
			ans = Math.max(ans,res);
		}
		return ans;
	}
	public int[] findDiagonalOrder(List<List<Integer>> nums) {
		int n = nums.size();
		List<Integer> ans = new ArrayList<>();
		int maxL=0;
		if (nums.size()==1){
			int[] res = new int[nums.get(0).size()];
			for (int i = 0; i < nums.get(0).size(); i++) {
				res[i] = nums.get(0).get(i);
			}
			return res;
		}
		for (int i = 0; i < n; i++) {
			ans.add(nums.get(i).get(0));
			maxL=Math.max(maxL,nums.get(i).size());
			for (int j = i-1; j >=0 ; j--) {
				if (nums.get(j).size()>i-j){
					ans.add(nums.get(j).get(i-j));
				}
			}
		}
		for (int i = 1; i < maxL; i++) {
			if(i<nums.get(n-1).size())
				ans.add(nums.get(n-1).get(i));
			for (int j = i; i+i+1-j<maxL; j--) {
				if(n-1-i+j-1>=0){
					if (nums.get(n-1-i+j-1).size()>i+i+1-j){
						ans.add(nums.get(n-1-i+j-1).get(i+i+1-j));
					}
				}
			}
		}
		int[] res = new int[ans.size()];
		for (int i = 0; i < res.length; i++) {
			res[i]=ans.get(i);
		}
		return res;
	}
	public int search0427(int[] nums, int target) {
		int lo = 0, hi = nums.length - 1, mid = 0;
		while (lo <= hi) {
			mid = lo + (hi - lo) / 2;
			if (nums[mid] == target) {
				return mid;
			}
			// 先根据 nums[mid] 与 nums[lo] 的关系判断 mid 是在左段还是右段
			if (nums[mid] >= nums[lo]) {
				// 再判断 target 是在 mid 的左边还是右边，从而调整左右边界 lo 和 hi
				if (target >= nums[lo] && target < nums[mid]) {
					hi = mid - 1;
				} else {
					lo = mid + 1;
				}
			} else {
				if (target > nums[mid] && target <= nums[hi]) {
					lo = mid + 1;
				} else {
					hi = mid - 1;
				}
			}
		}
		return -1;
	}
	public int[] SingleNumbers(int[] nums){
		int xorSum = 0;
		int[] ans = new int[2];
		for (int num : nums) {
			xorSum ^= num;
		}
		int lowbit = xorSum &(-xorSum);
		for (int num : nums) {
			ans[(num & lowbit) > 0 ? 0 : 1] ^= num;
		}
		return ans;
	}
	public boolean isHappy(int n) {
		Set<Integer> set = new HashSet<>();
		while (n!=1){
			if (set.contains(n)){
				return false;
			}else {
				set.add(n);
			}
			int t = n;
			n=0;
			while (t!=0){
				n+=(t%10)*(t%10);
				t/=10;
			}
		}
		return true;
	}

	/*
	* 289周赛
	* */
	public String digitSum(String s, int k) {
		if (s.length()<=k){
			return s;
		}
		StringBuilder sb =new StringBuilder(s);
		while (sb.length()>k){
			StringBuilder temp = new StringBuilder(sb.toString());
			sb = new StringBuilder();
			int t =0;
			int count = 0;
			for (int i = 0; i < temp.length(); i++) {
				if (count>=k){
					sb.append(t);
					count = 0;
					t= 0;
				}
				count++;
				t+= (int) temp.charAt(i)-'0';
			}
			sb.append(t);
		}
		return sb.toString();
	}

	public int minimumRounds(int[] tasks) {
		int ans = 0;
		Map<Integer,Integer> dict = new HashMap<>();
		for (int i = 0; i < tasks.length; i++) {
			if (dict.containsKey(tasks[i])){
				dict.put(tasks[i],dict.get(tasks[i])+1);
			}else {
				dict.put(tasks[i],1);
			}
		}
		for (Integer key : dict.keySet()) {
			Integer num = dict.get(key);
			int num3 = num/3;
			int num2 = (num-num3*3) / 2;
			if ((num-num3*3)%2==1){
				num3--;
				num2 = (num-num3*3) / 2;
			}
			if (num3<0){
				return -1;
			}
			ans += num2;
			ans += num3;
		}
		return ans;
	}


	public int maxTrailingZeros(int[][] grid) {
		long temp = 0;
		for (int i = 0; i < grid.length; i++) {
			for (int j = 0; j < grid[i].length; j++) {

			}
		}

		return 1;
	}


	public String removeDigit(String number, char digit) {
		List<String> dict = new ArrayList<>();
		for (int i = 0; i < number.length(); i++) {
			if (number.charAt(i) == digit){
				dict.add(number.substring(0,i)+number.substring(i+1,number.length()));
			}
		}
		Collections.sort(dict);
		return dict.get(dict.size()-1);
	}

	public int minimumCardPickup(int[] cards) {
		Map<Integer,List<Integer>> map = new HashMap<>();
		for (int i = 0; i < cards.length; i++) {
			if (map.containsKey(cards[i])){
				map.get(cards[i]).add(i);
			}else {
				List<Integer> list = new ArrayList<>();
				list.add(i);
				map.put(cards[i],list);
			}
		}
		int ans = Integer.MAX_VALUE;
		for (Integer key : map.keySet()) {
			List<Integer> list = map.get(key);
			if (list.size()<2){
				continue;
			}
			int t = list.get(0);
			for (int i = 1; i < list.size(); i++) {
				ans = Math.min(ans,list.get(i)-t+1);
				t = list.get(i);
			}
		}
		return ans==Integer.MAX_VALUE?-1:ans;
	}
	/*
	 输入：nums = [2,3,3,2,2], k = 2, p = 2
	 输出：11
	*/
	public int countDistinct(int[] nums, int k, int p) {
		Queue<Integer> queue = new LinkedList<>();
		int ans = 0;
		int count = 0;
		int index = 0;
		while (index<nums.length){
			queue.add(nums[index]);
			if (p%nums[index]==0){
				count++;
			}
			if (count<=k){
				ans++;
			}else {
				while (count>k){
					if (p%queue.poll()==0){
						count--;
					}
					ans++;
				}

			}
			index++;
		}
		return ans;
	}


	public int minStickers(String[] stickers, String target) {

		return 0;
	}

	/*2022-05-16每日一题*/
	List<TreeNode> queue20220516 = new ArrayList<>();
	public TreeNode inorderSuccessor(TreeNode root, TreeNode p) {
		dfs20220516(root);
		for (int i = 0; i < queue20220516.size(); i++) {
			if (queue20220516.get(i) == p){
				return queue20220516.size()>(i+1)?queue20220516.get(i+1):null;
			}
		}
		return null;
	}

	private void dfs20220516(TreeNode root){
		if (root==null){
			return;
		}
		dfs20220516(root.left);
		queue20220516.add(root);
		dfs20220516(root.right);
	}
	/**
	 * 0518刷题
	 */
	public List<String> removeAnagrams(String[] words) {
		List<String> dict = new ArrayList<>();
		List<String> sortDict = new ArrayList<>();
		for (String word : words) {
			dict.add(word);
			char[] chars = word.toCharArray();
			Arrays.sort(chars);
			sortDict.add(new String(chars));
		}
		int flag = 0;
		while (flag==0){
			flag = 1;
			for (int i = sortDict.size()-1; i >=1 ; i--) {
				if (sortDict.get(i).equals(sortDict.get(i-1))){
					sortDict.remove(i);
					dict.remove(i);
					flag = 0;
					break;
				}
			}
		}
		return dict;
	}

	public int numIdenticalPairs(int[] nums) {
		int ans = 0;
		for (int i = 0; i < nums.length; i++) {
			for (int j = i+1; j < nums.length; j++) {
				if (nums[i]==nums[j])
					ans++;
			}
		}
		return ans;
	}

	public int maxConsecutive(int bottom, int top, int[] special) {
		Arrays.sort(special);
		int res = Math.max(special[0] - bottom,top - special[special.length-1]);
		for (int i = 1; i < special.length; i++) {
			res = Math.max(special[i]-special[i-1]-1,res);
		}
		return res;
	}
	//22020519 每日一题
	public int minMoves2(int[] nums) {
		Arrays.sort(nums);
		int ans  =0;
		int avg = nums[nums.length/2];
		for (int i = 0; i < nums.length; i++) {
			ans += Math.abs(nums[i]-avg);
		}
		return ans;
	}
	//22020520 每日一题
	public int[] findRightInterval(int[][] intervals) {
		int[] res = new int[intervals.length];
		Arrays.fill(res,-1);
		if (intervals.length==1){
			return new int[]{-1};
		}
		Map<Integer,Integer> keyDict = new HashMap<>();
		List<Integer> keyList = new ArrayList<>();
		for (int i = 0; i < intervals.length; i++) {
			keyDict.put(intervals[i][0],i);
			keyList.add(intervals[i][0]);
		}
		Collections.sort(keyList);
		// 二分
		for (int i = 0; i < intervals.length; i++) {
			int end = intervals[i][1];
			int l = 0;
			int r = intervals.length-1;
			while (l < r)
			{
				int mid = l + r >> 1;
				if (keyList.get(mid)>=end){
					r = mid;
				} else{
					l = mid + 1;
				}
			}
			if (keyList.get(l)<end){
				res[i] = -1;
			}else {
				res[i] = keyDict.get(keyList.get(l));
			}
		}
		return res;
	}
	// 22020521 每日一题
	public int repeatedNTimes(int[] nums) {
		Set<Integer> checkSet = new HashSet<>();
		for (int i = 0; i < nums.length; i++) {
			if (checkSet.contains(nums[i])){
				return nums[i];
			}else {
				checkSet.add(nums[i]);
			}
		}
		return 0;
	}
	// 22020524 每日一题
	public boolean isUnivalTree(TreeNode root) {
		if (root==null){
			return true;
		}
		int val = root.val;
		Queue<TreeNode> queue = new LinkedList<>();
		queue.add(root);
		while (queue.size()>0){
			int size = queue.size();
			for (int i = 0; i < size; i++) {
				TreeNode poll = queue.poll();
				if (poll.val!=val){
					return false;
				}
				if (poll.left!=null){
					queue.add(poll.left);
				}
				if (poll.right!=null){
					queue.add(poll.right);
				}
			}
		}
		return true;
	}
	//
	public int minMaxGame(int[] nums) {
		int flag = 0;
		List<Integer> dict = new ArrayList<>();
		for (int num : nums) {
			dict.add(num);
		}
		while (dict.size()>1){
			flag = 0;
			List<Integer> temp = new ArrayList<>();
			for (int i = 0; i < dict.size(); i+=2) {
				if (flag%2==0){
					temp.add(Math.min(dict.get(i),dict.get(i+1)));
				}else {
					temp.add(Math.max(dict.get(i),dict.get(i+1)));
				}
				flag++;
			}
			dict = temp;
		}
		return dict.get(0);
	}

	public int partitionArray(int[] nums, int k) {
		Arrays.sort(nums);
		int t =nums[0];
		int ans = 1;
		for (int i = 1; i < nums.length; i++) {
			if (nums[i]-t>k){
				ans++;
				t = nums[i];
			}
		}
		return ans;
	}
	// 22020607 每日一题
	public int minEatingSpeed(int[] piles, int h) {
		long l = 1;
		long r = 0;
		for (int i = 0; i < piles.length; i++) {
			r+=piles[i];
		}
		while (l < r) {
			long mid = l + r >> 1;
			if (check875(piles,h,mid)){
				r = mid;
			} else{
				l = mid + 1;
			}
		}
		return (int)l;
	}
	public boolean check875(int[] piles, int h, long mid){
		long res = 0;
		for (int i = 0; i < piles.length; i++) {
			res += piles[i]%mid==0?piles[i]/mid:piles[i]/mid+1;
		}
		return res<=h;
	}
	public int[] arrayChange(int[] nums, int[][] operations) {
		Map<Integer,Integer> dict = new HashMap<>();
		for (int i = 0; i < nums.length; i++) {
			dict.put(nums[i],i);
		}
		for (int i = 0; i < operations.length; i++) {
			Integer index = dict.get(operations[i][0]);
			dict.remove(operations[i][0]);
			dict.put(operations[i][1],index);
		}
		dict.forEach((k,v)->nums[v]=k);
		return nums;
	}
	//20220608 每日一题
	public boolean isBoomerang(int[][] points) {
		int x1 = points[0][0], y1 = points[0][1];
		int x2 = points[1][0], y2 = points[1][1];
		int x3 = points[2][0], y3 = points[2][1];
		return (y2 - y1) * (x3 - x2) != (y3 - y2) * (x2 - x1);
	}

	//20220611 每日一题
	public int minFlipsMonoIncr(String s) {
		int n = s.length();
		int ans = n;
		int [] preSum = new int[s.length()];
		preSum[0] = (int) s.charAt(0)-'0';
		for (int i = 1; i < s.length(); i++) {
			preSum[i] = preSum[i-1] + (int) s.charAt(i)-'0';
		}
		ans = Math.min(preSum[n-1],n-preSum[n-1]);
		for (int i = 0; i < s.length(); i++) {
			ans = Math.min(ans,preSum[i]  +(n-i-1-preSum[n-1]+preSum[i]));
		}

		return ans;
	}

	//20220613 每日一题
	public int heightChecker(int[] heights) {
		int[] t = new int[heights.length];
		for (int i = 0; i < heights.length; i++) {
			t[i] = heights[i];
		}
		Arrays.sort(heights);
		int ans = 0;
		for (int i = 0; i < heights.length; i++) {
			if (heights[i]!=t[i]){
				ans++;
			}
		}
		return ans;
	}
	// 20220612周赛
	public double calculateTax(int[][] brackets, int income) {
		double ans = 0D;
		int[] t = new int[brackets.length];
		t[0] = brackets[0][0];
		for (int i = 1; i < brackets.length; i++) {
			t[i] = brackets[i][0]-brackets[i-1][0];
		}

		for (int i = 0; i < brackets.length; i++) {
			if (income>=brackets[i][0]){
				ans += t[i]*1.0*brackets[i][1];
			}else {
				if (i==0){
					return ans + (income)*1.0*brackets[i][1]/100;
				}
				return (ans + (income-brackets[i-1][0])*1.0*brackets[i][1])/100;
			}
		}
		return ans/100;
	}

	public String greatestLetter(String s) {
		int[] dict = new int[26];
		char ans = '0';
		for (int i = 0; i < s.length(); i++) {
			if ('a'<=s.charAt(i) && 'z'>=s.charAt(i)){
				dict[s.charAt(i)-'a'] = 1;
			}
		}
		for (int i = 0; i < s.length(); i++) {
			if ('A'<=s.charAt(i) && 'Z'>=s.charAt(i)){
				if (dict[s.charAt(i)-'A']==1 && s.charAt(i)>ans){
					ans = s.charAt(i);
				}
			}
		}
		return ans=='0'?"":ans+"";
	}

	public String defangIPaddr(String address) {
		return address.replaceAll("\\.","[.]");
	}

	public List<Integer> largestValues(TreeNode root) {
		if (root==null){
			return new ArrayList<>();
		}
		List<Integer> res = new ArrayList<>();
		Queue<TreeNode> queue = new LinkedList<>();
		queue.add(root);
		while (!queue.isEmpty()){
			int size = queue.size();
			int max = queue.peek().val;
			for (int i = 0; i < size; i++) {
				TreeNode poll = queue.poll();
				max = Math.max(max,poll.val);
				if (poll.left!=null){
					queue.add(poll.left);
				}
				if (poll.right!=null){
					queue.add(poll.right);
				}
			}
			res.add(max);
		}
		return res;
	}
	/*<pre><code class="language-java line-numbers">代码内容</code></pre>*/

	public void swap(int[] nums, int i, int j) {
		int temp = nums[i];
		nums[i] = nums[j];
		nums[j] = temp;
	}

	// 快排
	public void quickSort(int[] nums, int left, int right) {
		if (left >= right) return;
		int lo = left+1;               // 小于分界点元素的最右侧的指针
		int hi = right;                // 大于分界点元素的最左侧的指针
		while (lo<=hi) {
			if (nums[lo]>nums[left]) { // 交换元素确保左侧指针指向元素小于分界点元素
				swap(nums, lo, hi);
				hi--;
			} else {
				lo++;
			}
		}
		lo--;                          // 回到小于分界点元素数组的最右侧
		swap(nums, left, lo);          // 将分界点元素移到左侧数组最右侧
		quickSort(nums, left, lo-1);
		quickSort(nums, lo+1, right);
	}

	// 归并
	public void mergeSort(int[] nums, int left, int right) {  // 需要左右边界确定排序范围
		if (left >= right) return;
		int mid = (left+right) / 2;

		mergeSort(nums, left, mid);                           // 先对左右子数组进行排序
		mergeSort(nums, mid+1, right);

		int[] temp = new int[right-left+1];                   // 临时数组存放合并结果
		int i=left,j=mid+1;
		int cur = 0;
		while (i<=mid&&j<=right) {                            // 开始合并数组
			if (nums[i]<=nums[j]) temp[cur] = nums[i++];
			else temp[cur] = nums[j++];
			cur++;
		}
		while (i<=mid) temp[cur++] = nums[i++];
		while (j<=right) temp[cur++] = nums[j++];

		for (int k = 0; k < temp.length; k++) {             // 合并数组完成，拷贝到原来的数组中
			nums[left+k] = temp[k];
		}
	}
	// 堆排
	public void heapSort(int[] nums) {
		heapify(nums);                                 // 新建一个最大堆
		for (int i = nums.length - 1; i >= 1; i--) {
			swap(nums, 0, i);                       // 弹出最大堆的堆顶放在最后
			rebuildHeap(nums, 0,i-1);          // 重建最大堆
		}
	}
	private void heapify(int[] nums) {
		for (int i = 1; i < nums.length; i++) {
			int par = (i-1)>>1;                       // 找到父节点
			int child = i;                            // 定义子节点
			while (child>0&&nums[par]<nums[child]) {  // 从子节点到根节点构建最大堆
				swap(nums, par, child);
				child = par;
				par = (par-1) >> 1;
			}
		}
	}
	private void rebuildHeap(int[] nums, int par, int last) {
		int left = 2*par+1;                           // 左子节点
		int right = 2*par+2;                          // 右子节点
		int maxIndex = left;

		if (right<=last && nums[right]>nums[left]) {  // 找到最大子节点
			maxIndex = right;
		}

		if (left<=last && nums[par] < nums[maxIndex]) {// 和最大子节点比较
			swap(nums, par, maxIndex);                 // 互换到最大子节点
			rebuildHeap(nums, maxIndex, last);         // 重建最大子节点代表的子树
		}
	}
	/**
	 * LeetCode 302周数  前三题
	 */
	public int maximumSum302(int[] nums) {
		Map<Integer, List<Integer>> dict = new HashMap<>();
		for (int i = 0; i < nums.length; i++) {
			int numSum = getNumSum(nums[i]);
			if (dict.containsKey(numSum)){
				dict.get(numSum).add(nums[i]);
			}else {
				List<Integer> temp = new ArrayList<>();
				temp.add(nums[i]);
				dict.put(numSum,temp);
			}
		}
		int ans = -1;
		Set<Integer> keySet = dict.keySet();
		for (Integer key : keySet) {
			List<Integer> list = dict.get(key);
			if (list.size()<2){
				continue;
			}
			Collections.sort(list);
			ans = Math.max(ans,list.get(list.size()-1)+list.get(list.size()-2));
		}
		return ans;
	}
	private int getNumSum(int num){
		String s = String.valueOf(num);
		int res = 0;
		for (int i = 0; i < s.length(); i++) {
			res += Integer.valueOf(s.charAt(i)-'0');
		}
		return res;
	}

	public int[] smallestTrimmedNumbers(String[] nums, int[][] queries) {
		int[] ans = new int[queries.length];
		Map<Integer,int[]> dict = new HashMap<>();
		for (int i = 0; i < queries.length; i++) {
			int digit  = queries[i][1];
			String[] t = new String[nums.length];
			int[] sNum = new int[nums.length];
			if (dict.containsKey(digit)){
				sNum = dict.get(digit);
				ans[i] =sNum[queries[i][0]-1];
			}else {
				for (int j = 0; j < nums.length; j++) {
					t[j] = nums[j].substring(nums[j].length()-digit);
					sNum[j] = j;
				}
				// 冒泡
				for (int x = 1; x < t.length; x++) {
					boolean flag = true;

					for (int j = 0; j < t.length - x; j++) {
						if (t[j].compareTo(t[j + 1]) >0 ) {
							String tmp = t[j];
							t[j] = t[j + 1];
							t[j + 1] = tmp;

							int tmp2 = sNum[j];
							sNum[j] = sNum[j + 1];
							sNum[j + 1] = tmp2;

							flag = false;
						}
					}
					if (flag) break;
				}
				dict.put(digit,sNum);
				ans[i] =sNum[queries[i][0]-1];
			}
		}
		return ans;
	}
	/**
	 *
	 */
	public TreeNode pruneTree(TreeNode root) {
		return dfs0721(root);
	}
	private TreeNode dfs0721(TreeNode root){
		if (root == null)	return null;
		root.left = dfs0721(root.left);
		root.right = dfs0721(root.right);
		if (root.left == null && root.right == null && root.val == 0) {
			root =  null;
		}
		return root;
	}

	/**
	 * LeetCode 301周赛 前三题
	 */
	public int fillCups(int[] amount) {
		int ans = 0;
		Arrays.sort(amount);
		while (amount[2]>0){
			amount[2]--;
			amount[1]--;
			ans++;
			Arrays.sort(amount);
		}
		return ans;
	}

	class SmallestInfiniteSet {
		List<Integer> list;
		public SmallestInfiniteSet() {
			list = new ArrayList<>();
			for (int i = 1; i <= 1050; i++) {
				list.add(i);
			}
		}

		public int popSmallest() {
			Integer min = list.get(0);
			list.remove(0);
			return min;
		}

		public void addBack(int num) {
			if (!list.contains(num)){
				list.add(0,num);
				Collections.sort(list);
			}
		}
	}

	public boolean canChange(String start, String target) {
		StringBuilder sbs = new StringBuilder();
		StringBuilder sbe = new StringBuilder();
		List<Integer> ls = new ArrayList<>();
		List<Integer> rs = new ArrayList<>();
		List<Integer> le = new ArrayList<>();
		List<Integer> re = new ArrayList<>();
		for (int i = 0; i < start.length(); i++) {
			if (start.charAt(i) == '_'){
				continue;
			}
			sbs.append(start.charAt(i));
			if (start.charAt(i) == 'L'){
				ls.add(i);
			}
			if (start.charAt(i) == 'R'){
				rs.add(i);
			}
		}
		for (int i = 0; i < target.length(); i++) {
			if (target.charAt(i) == '_'){
				continue;
			}
			sbe.append(target.charAt(i));
			if (target.charAt(i) == 'L'){
				le.add(i);
			}
			if (target.charAt(i) == 'R'){
				re.add(i);
			}
		}

		if (!sbs.toString().equals(sbe.toString())) {
			return false;
		}
		for (int i = 0; i < ls.size(); i++) {
			if (le.get(i)>ls.get(i)){
				return false;
			}
		}
		for (int i = 0; i < rs.size(); i++) {
			if (re.get(i)<rs.get(i)){
				return false;
			}
		}
		return true;
	}

	// LeetCode 60双周赛 前三题
	public int findMiddleIndex(int[] nums) {
		int left = 0;
		for (int i = 0; i < nums.length; i++) {
			int r = 0;
			for (int j = i+1; j < nums.length; j++) {
				r+=nums[j];
			}
			if (left==r){
				return i;
			}
			left+=nums[i];
		}

		return -1;
	}

	public int[][] findFarmland(int[][] land) {
		List<List<Integer>> ans = new ArrayList<>();
		for (int i = 0; i < land.length; i++) {
			for (int j = 0; j < land[i].length; j++) {
				if (land[i][j]==1){
					List<Integer> temp = new ArrayList<>();
					temp.add(i);
					temp.add(j);
					int left = i;
					int right = j;
					while (left+1<land.length && right+1<land[left].length && land[left+1][right+1]==1 &&
							land[left][right+1]==1 && land[left+1][right]==1){
						left++;
						right++;
					}
					while (left+1<land.length && land[left+1][right]==1){
						left++;
					}
					while (right+1<land[left].length &&	land[left][right+1]==1){
						right++;
					}
					temp.add(left);
					temp.add(right);
					for (int k = temp.get(0); k <=temp.get(2) ; k++) {
						for (int l = temp.get(1); l <= temp.get(3); l++) {
							land[k][l] = 2;
						}
					}
					ans.add(temp);
				}
			}
		}
		int[][] res = new int[ans.size()][4];
		for (int i = 0; i < ans.size(); i++) {
			res[i] = new int[]{ans.get(i).get(0),ans.get(i).get(1),ans.get(i).get(2),ans.get(i).get(3)};
		}
		return res;
	}

	static class LockingTree {
		int[] tree;
		int[] lockUser;
		Map<Integer,List<Integer>> map = new HashMap<>();
		public LockingTree(int[] parent) {
			tree = parent;
			lockUser = new int[parent.length];
			Arrays.fill(lockUser,-1);
			for (int i = 0; i < tree.length; i++) {
				if (map.containsKey(tree[i])){
					map.get(tree[i]).add(i);
				}else {
					List<Integer> temp = new ArrayList<>();
					temp.add(i);
					map.put(tree[i],temp);
				}
			}
		}

		public boolean lock(int num, int user) {
			if (lockUser[num]==-1){
				lockUser[num] = user;
				return true;
			}
			return false;
		}

		public boolean unlock(int num, int user) {
			if (lockUser[num] == user){
				lockUser[num] = -1;
				return true;
			}
			return false;
		}

		public boolean upgrade(int num, int user) {
			if (lockUser[num]!=-1){
				return false;
			}
			// 父节点 锁定状态
			int fNode = num;
			while(fNode!=-1){
				if (tree[fNode] != -1 && lockUser[tree[fNode]]!=-1){
					return false;
				}
				fNode = tree[fNode];
			}
			int flag = 0;

			Queue<Integer> queueLock = new LinkedList<>();
			queueLock.add(num);
			while(queueLock.size()>0){
				Integer node = queueLock.poll();
				List<Integer> list = map.get(node);
				if (list!=null){
					for (int j = 0; j < list.size(); j++) {
						if (tree[list.get(j)]==node){
							if (lockUser[list.get(j)]!=-1){
								flag = 1;
							}
							lockUser[list.get(j)] = -1;
							queueLock.add(list.get(j));
						}
					}
				}

			}
			if (flag==0){
				return false;
			}
			lockUser[num] = user;
			return true;
		}
	}

	//LeetCode 第303场周赛 前三题
	public char repeatedCharacter(String s) {
		Set<Character> set = new HashSet<>();
		for (char c : s.toCharArray()) {
			if (set.contains(c)){
				return c;
			}else {
				set.add(c);
			}
		}
		return ' ';
	}

	public int equalPairs(int[][] grid) {
		int n = grid.length;
		int ans = 0;
		for (int i = 0; i < n; i++) {
			for (int j = 0; j < n; j++) {
				int flag = 1;
				for (int k = 0; k < n; k++) {
					if (grid[i][k]!=grid[k][j]){
						flag = 0;
						break;
					}
				}
				ans+=flag;
			}
		}
		return ans;
	}

	static class FoodRatings {
		class JG {
			String food;
			String cuisine;
			int ratings;
			public JG(String food, String cuisine, int ratings) {
				this.food = food;
				this.cuisine = cuisine;
				this.ratings = ratings;
			}
		}

		Map<String,PriorityQueue<JG>> rankMap = new HashMap<>();
		Map<String,JG> foodMap = new HashMap<>();

		public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {
			for (int i = 0; i < cuisines.length; i++) {
				JG jg = new JG(foods[i], cuisines[i], ratings[i]);
				if (rankMap.containsKey(cuisines[i])){
					rankMap.get(cuisines[i]).add(jg);
				}else {
					PriorityQueue<JG> temp = new PriorityQueue<>((o1,o2)->{
						if (o1.ratings!=o2.ratings){
							return o2.ratings-o1.ratings;
						}
						return o1.food.compareTo(o2.food);
					});
					temp.add(jg);
					rankMap.put(cuisines[i],temp);
				}
				foodMap.put(foods[i],new JG(foods[i], cuisines[i], ratings[i]));
			}
		}

		public void changeRating(String food, int newRating) {
			JG jg = foodMap.get(food);
			jg.ratings = newRating;
			rankMap.get(jg.cuisine).add(new JG(jg.food,jg.cuisine,jg.ratings));
		}

		public String highestRated(String cuisine) {
			while(true){
				PriorityQueue<JG> jgs = rankMap.get(cuisine);
				JG peek = jgs.peek();
				JG jg = foodMap.get(peek.food);
				if(peek.ratings==jg.ratings){
					return peek.food;
				}
				jgs.poll();
			}
		}
	}
/**
 * 给你一个整数数组ranks和一个字符数组suit。你有5张扑克牌，第i张牌大小为ranks[i]，花色为suits[i]。
 *
 * 下述是从好到坏你可能持有的 手牌类型：
 *
 * "Flush"：同花，五张相同花色的扑克牌。
 * "Three of a Kind"：三条，有 3 张大小相同的扑克牌。
 * "Pair"：对子，两张大小一样的扑克牌。
 * "High Card"：高牌，五张大小互不相同的扑克牌。
 * 请你返回一个字符串，表示给定的 5 张牌中，你能组成的 最好手牌类型。
 *
 * 注意：返回的字符串大小写需与题目描述相同。
 *

 * 输入：ranks = [13,2,3,1,9], suits = ["a","a","a","a","a"]
 * 输出："Flush"
 * 解释：5 张扑克牌的花色相同，所以返回 "Flush" 。
 */

	//LeetCode 第83场双周赛 前三题
	public String bestHand(int[] ranks, char[] suits) {
		Map<Integer,Integer> dict = new HashMap<>();
		if (suits[0] == suits[1] && suits[2] == suits[3] && suits[0] == suits[4]){
			return "Flush";
		}
		int max = 0;
		for (int i = 0; i < ranks.length; i++) {
			if (dict.containsKey(ranks[i])){
				int t = dict.get(ranks[i])+1;
				dict.put(ranks[i],t);
				max = Math.max(max,t);
			}else {
				dict.put(ranks[i],1);
			}
		}
		if (max>=3){
			return "Three of a Kind";
		}else if (max>=2){
			return "Pair";
		}else {
			return "High Card";
		}
	}
/**
 * 输入：nums = [1,3,0,0,2,0,0,4]
 * 输出：6
 * 解释：
 * 子数组 [0] 出现了 4 次。
 * 子数组 [0,0] 出现了 2 次。
 * 不存在长度大于 2 的全 0 子数组，所以我们返回 6 。
 * 示例 2：
 *
 * 输入：nums = [0,0,0,2,0,0]
 * 输出：9
 * 解释：
 * 子数组 [0] 出现了 5 次。
 * 子数组 [0,0] 出现了 3 次。
 * 子数组 [0,0,0] 出现了 1 次。
 * 不存在长度大于 3 的全 0 子数组，所以我们返回 9 。
 */
	public long zeroFilledSubarray(int[] nums) {
		List<Integer> list = new ArrayList<>();
		for (int i = 0; i < nums.length; i++) {
			if (nums[i] == 0){
				for (int j = i; j < nums.length; j++) {
					if (nums[j]!=0){
						list.add(j-i);
						i=j-1;
						break;
					}
					if (nums.length-1==j){
						list.add(j-i+1);
						i=j;
						break;
					}
				}
			}
		}
		long ans = 0;
		for (int i = 0; i < list.size(); i++) {
			for (int j = 1; j <= list.get(i); j++) {
				ans+=j;
			}
		}
		return ans;
	}

	static class NumberContainers {

		Map<Integer,PriorityQueue<Integer>> map = new HashMap<>();
		Map<Integer,Integer> indexMapping = new HashMap<>();
		public NumberContainers() {

		}

		public void change(int index, int number) {
			if (map.containsKey(number)){
				map.get(number).add(index);
			}else {
				PriorityQueue<Integer> list = new PriorityQueue<>();
				list.add(index);
				map.put(number,list);
			}
			indexMapping.put(index,number);
		}

		public int find(int number) {
			PriorityQueue<Integer> list = map.get(number);
			if(list ==null) return -1;
			while (list.size()>0){
				Integer integer = list.peek();
				if (number == indexMapping.get(integer)){
					return integer;
				}else {
					list.poll();
				}
			}
			return -1;
		}
	}

	//LeetCode 第82场双周赛 前三题
	public boolean evaluateTree(TreeNode root) {
		return dfs20220727(root);
	}
	public boolean dfs20220727(TreeNode root){
		if (root==null){
			return false;
		}
		boolean b = dfs20220727(root.left);
		boolean b1 = dfs20220727(root.right);
		if (root.val == 2){
			return b||b1;
		}else if (root.val == 3){
			return b&&b1;
		}else {
			return root.val == 1;
		}
	}

	public int latestTimeCatchTheBus(int[] buses, int[] passengers, int capacity) {
		Arrays.sort(buses);
		Arrays.sort(passengers);
		Map<Integer,List<Integer>> map = new HashMap<>();
		int index = 0;
		Set<Integer> set = new HashSet<>();
		for (int i = 0; i < passengers.length; i++) {
			set.add(passengers[i]);
		}
		for (int i = 0; i < buses.length; i++) {
			int count = capacity;
			map.put(buses[i],new ArrayList<>());
			for (int j = index; j < passengers.length; j++) {
				if (buses[i]>=passengers[j] && count>0){
					index++;
					count--;
					map.get(buses[i]).add(passengers[j]);
				}else {
					break;
				}
			}
		}
		List<Integer> list = map.get(buses[buses.length - 1]);
		int ans = 0;
		if (list.size()<capacity){
			ans =  buses[buses.length - 1]+1;
		}else {
			ans =list.get(list.size() - 1);
		}
		while (true){
			if (!set.contains(--ans)){
				return ans;
			}
		}
	}


	public long minSumSquareDiff(int[] nums1, int[] nums2, int k1, int k2) {
		int[] arr = new int[100000+50];
		int k = k1+k2;
		int n = nums1.length;
		for (int i = 0; i < n; i++) {
			arr[Math.abs(nums1[i]-nums2[i])]++;
		}
		for (int i = arr.length-1; i >=1 ; i--) {
			if (k>=arr[i]){
				k-=arr[i];
				arr[i-1] += arr[i];
				arr[i] = 0;
			}else {
				arr[i]-=k;
				arr[i-1]+=k;
				break;
			}
		}
		long ans = 0;
		for (int i = 0; i < arr.length; i++) {
			if (arr[i]>0){
				ans += i*1.0*i*arr[i];
			}
		}

		return ans;
	}

	public int[] arrayRankTransform(int[] arr) {
		int[] ans = new int[arr.length];
		Set<Integer> set = new HashSet<>();
		for (int i = 0; i < arr.length; i++) {
			set.add(arr[i]);
		}
		Integer[] setArr = set.toArray(new Integer[0]);
		Arrays.sort(setArr);
		for (int i = 0; i < arr.length; i++) {
			//二分
			int left = 0,right = setArr.length,mid = left+right>>1;
			while (left<right){
				mid = left+right>>1;
				if (setArr[mid]>=arr[i]){
					right = mid;
				}else {
					left =mid+1;
				}
			}
			ans[i] = left+1;
		}
		return ans;
	}

	public int countAsterisks(String s) {
		int ans = 0;
		int countVer = 0;
		for (int i = 0; i < s.length(); i++) {
			if (s.charAt(i) == '|') {
				countVer++;
			}else if (s.charAt(i) == '*' && countVer%2==0) {
				ans++;
			}
		}
		return ans;
	}

	public String generateTheString20220801(int n) {
		StringBuilder sb = new StringBuilder();
		if (n%2==0){
			for (int i = 0; i < n - 1; i++) {
				sb.append('a');
			}
			sb.append('b');
		}else {
			for (int i = 0; i < n; i++) {
				sb.append('a');
			}
		}
		return sb.toString();
	}

	public int minimumOperations(int[] nums) {
		int ans = 0;
		List<Integer> list = new ArrayList<>();
		for (int i = 0; i < nums.length; i++) {
			if (nums[i]>0){
				list.add(nums[i]);
			}
		}
		while (list.size()>0){
			Collections.sort(list);
			List<Integer> temp = new ArrayList<>();
			int t  = list.get(0);
			for (int i = 0; i < list.size(); i++) {
				int res = list.get(i) -t;
				if (res >0){
					temp.add(res);
				}
			}
			list = temp;
			ans++;
		}
		return ans;
	}

	public int maximumGroups(int[] grades) {
		int n = grades.length;
		if (n==0)return 0;
		int sum = 0,count = 0;
		while (true){
			count++;
			if (sum+count>n){
				return --count;
			}
			sum+=count;
		}
	}

	public int countHillValley(int[] nums) {
		// 1 升  2 落
		int flag = 0;
		int res = 0;
		for(int i = 1 ; i < nums.length ; i++){
			if(nums[i] > nums[i-1]){
				if(flag == 1) {
					res++;
				}
				flag = 2;
			}else if(nums[i] < nums[i-1]){
				if(flag == 2){
					res++;
				}
				flag = 1;
			}
		}
		return res;
	}

	class MyCircularQueue {
		int size = 0;
		List<Integer> list = new LinkedList<>();
		int max = 0;
		public MyCircularQueue(int k) {
			max = k;
		}

		public boolean enQueue(int value) {
			if (size>=max){
				return false;
			}
			list.add(value);
			size++;
			return true;
		}

		public boolean deQueue() {
			if (isEmpty()){
				return false;
			}
			list.remove(0);
			size--;
			return true;
		}

		public int Front() {
			if (isEmpty()){
				return -1;
			}
			return list.get(0);
		}

		public int Rear() {
			if (isEmpty()){
				return -1;
			}
			return list.get(size-1);
		}

		public boolean isEmpty() {
			return size==0;
		}

		public boolean isFull() {
			return size==max;
		}
	}

	public int heightChecker20220803(int[] heights) {
		int[] comp = new int[heights.length];
		for (int i = 0; i < heights.length; i++) {
			comp[i] = heights[i];
		}
		Arrays.sort(comp);
		int ans = 0;
		for (int i = 0; i < heights.length; i++) {
			ans +=  comp[i]==heights[i]?0:1;
		}
		return ans;
	}

	public int maxSatisfied(int[] customers, int[] grumpy, int minutes) {
		int full = 0;
		int n = grumpy.length;
		for (int i = 0; i < n; i++) {
			if (grumpy[i]==0){
				full+=customers[i];
			}
		}
		for (int i = 0; i < minutes; i++) {
			if (grumpy[i]==1){
				full+=customers[i];
			}
		}
		int ans = full;
		for (int i = minutes; i < n; i++) {
			if (grumpy[i]==1){
				full+=customers[i];
			}
			if (grumpy[i-minutes]==1){
				full-=customers[i-minutes];
			}
			ans = Math.max(full,ans);
		}
		return ans;
	}
	public int[] prevPermOpt1(int[] A) {
		int[] a= new int[A.length];
		int length=A.length;
		for (int i = 0; i < A.length; i++) {
			a[i]=A[i];
		}
		Arrays.sort(a);
		int flag=0;
		for (int i = 0; i < A.length; i++) {
			if (A[i]!=a[i]){
				flag=1;
				break;
			}
		}
		if (flag==0)return a;
		int c1=0;

		for (int i = 0; i < a.length; i++) {
			for (int j = i; j < a.length; j++) {
				if (A[i]>A[j]){
					c1=i;
					break;
				}
			}
		}
		int max=-1;
		int c2=c1+1;
		for (int i = c1+1; i < a.length; i++) {
			if (max<A[i] && A[c1]>A[i]){
				max=A[i];
				c2=i;
			}
		}
		int temp=A[c2];
		A[c2]=A[c1];
		A[c1]=temp;
		return A;

	}

	public List<Integer> minSubsequence20220804(int[] nums) {
		Arrays.sort(nums);
		int sum = 0;
		List<Integer> ans = new ArrayList<>();
		int ansSum = 0;
		for (int i = 0; i < nums.length; i++) {
			sum+=nums[i];
		}
		for (int i = nums.length-1; i >=0; i--) {
			if (ansSum>sum){
				return ans;
			}
			ans.add(nums[i]);
			ansSum += nums[i];
			sum -= nums[i];
		}
		return ans;
	}

	public TreeNode addOneRow(TreeNode root, int val, int depth) {
		if (depth==1){
			TreeNode newRoot = new TreeNode(val);
			newRoot.left = root;
			return newRoot;
		}
		Queue<TreeNode> queue = new LinkedList<>();
		queue.add(root);
		int t = 2;
		while(!queue.isEmpty()) {
			int size = queue.size();
			for (int i = 0; i < size; i++) {
				TreeNode poll = queue.poll();
				if (t==depth){
					TreeNode t1 = poll.left;
					TreeNode t2 = poll.right;
					poll.left = new TreeNode(val);
					poll.right = new TreeNode(val);
					poll.left.left = t1;
					poll.right.right = t2;
				}
				if (poll.left!=null){
					queue.add(poll.left);
				}
				if (poll.right!=null){
					queue.add(poll.right);
				}
			}
			t++;
		}
		return root;
	}

	// 第281场周赛前三题
	public int countEven(int num) {
		int ans = 0;
		for (int i = 1; i <= num; i++) {
			int t = i;
			int temp = 0;
			while (t>0){
				temp+=t%10;
				t/=10;
			}
			if (temp%2==0){
				ans++;
			}
		}
		return ans;
	}

	public ListNode mergeNodes(ListNode head) {
		ListNode pre = new ListNode(-1);
		ListNode ans = pre;
		int t = 0;
		head = head.next;
		while (head!=null){
			if (head.val!=0){
				t+=head.val;
			}else {
				pre.next = new ListNode(t);
				pre = pre.next;
				t = 0;
			}
			head = head.next;
		}
		return ans.next;
	}

	public String repeatLimitedString(String s, int repeatLimit) {
		int[] dict = new int[26];
		for (int i = 0; i < s.length(); i++) {
			dict[s.charAt(i)-'a']++;
		}
		StringBuilder sb = new StringBuilder();
		int index = 25;
		while (index>=0){
			while (dict[index]>0){
				if (dict[index]>repeatLimit){
					dict[index]-=repeatLimit;
					for (int i = 0; i < repeatLimit; i++) {
						sb.append((char)('a'+index));
					}
					int flag = 0;
					for (int i = index-1; i >=0 ; i--) {
						if (dict[i]>0){
							flag=1;
							dict[i]--;
							sb.append((char)('a'+i));
							break;
						}
					}
					if (flag==0){
						return sb.toString();
					}
				}else {
					for (int i = 0; i < dict[index]; i++) {
						sb.append((char)('a'+index));
					}
					dict[index]=0;
				}
			}
			index--;
		}
		return sb.toString();
	}


	public List<String> stringMatching20220806(String[] words) {
		Set<String> set = new HashSet<>();
		for (int i = 0; i < words.length; i++) {
			for (int j = 0; j < words.length; j++) {
				if (i!=j && !words[i].equals(words[j]) && words[i].contains(words[j])){
					set.add(words[j]);
				}
			}
		}
		return new ArrayList<>(set);
	}

	// LeetCode 第281场周赛前三题
	public String[] divideString(String s, int k, char fill) {
		List<String> list = new ArrayList<>();
		int count = 0;
		StringBuilder sb = new StringBuilder();
		for (int i = 0; i < s.length(); i++) {
			count++;
			if (count>=k){
				count=0;
				sb.append(s.charAt(i));
				list.add(sb.toString());
				sb = new StringBuilder();
			}else {
				sb.append(s.charAt(i));
			}
		}
		if (sb.length()!=0 && sb.length()<k){
			for (int i = sb.length(); i < k; i++) {
				sb.append(fill);
			}
			list.add(sb.toString());
		}
		return list.toArray(new String[0]);
	}


	public int minMoves(int target, int maxDoubles) {
		int res = 0;
		for (int i = 0; i < maxDoubles; i++) {
			if (target<=1){
				break;
			}
			res++;
			if (target%2==0){
				target/=2;
			}else {
				target/=2;
				res++;
			}
		}
		return target+res-1;
	}

	public long mostPoints(int[][] questions) {
		int n = questions.length;
		long ans = 0;
		long dp[] = new long[n+1];
		for (int i = n-1; i >= 0; i--) {
			dp[i] = i+questions[i][1]+1<n?Math.max(Math.max(questions[i][0],dp[i+1]),dp[i+questions[i][1]+1]+questions[i][0]):Math.max(questions[i][0],dp[i+1]);
			ans = Math.max(ans,dp[i]);
		}
		return dp[0];
	}

	public int arithmeticTriplets(int[] nums, int diff) {
		int n = nums.length;
		int ans = 0;
		for (int i = 0; i < n; i++) {
			for (int j = i+1; j < n; j++) {
				for (int k = j+1; k < n; k++) {
					if (nums[i]-nums[j]== -diff && nums[j]-nums[k]== -diff){
						ans++;
					}
				}
			}
		}
		return ans;
	}

	public int reachableNodes(int n, int[][] edges, int[] restricted) {
		Map<Integer,List<Integer>> map = new HashMap<>();
		Set<Integer> restrictSet = new HashSet<>();
		for (int i = 0; i < restricted.length; i++) {
			restrictSet.add(restricted[i]);
		}
		for (int i = 0; i < edges.length; i++) {
			if (!restrictSet.contains(edges[i][0]) && !restrictSet.contains(edges[i][1])) {
				if (map.containsKey(edges[i][0])){
					map.get(edges[i][0]).add(edges[i][1]);
				}else {
					List<Integer> temp = new ArrayList<>();
					temp.add(edges[i][1]);
					map.put(edges[i][0],temp);
				}
				if (map.containsKey(edges[i][1])){
					map.get(edges[i][1]).add(edges[i][0]);
				}else {
					List<Integer> temp = new ArrayList<>();
					temp.add(edges[i][0]);
					map.put(edges[i][1],temp);
				}
			}
		}
		Set<Integer> visited = new HashSet<>();
		Queue<Integer> queue = new LinkedList<>();
		queue.add(0);
		visited.add(0);
		while (queue.size()>0){
			int size = queue.size();
			for (int i = 0; i < size; i++) {
				Integer poll = queue.poll();
				List<Integer> list = map.get(poll);
				if (list==null || list.size()==0){
					continue;
				}
				for (int j = 0; j < list.size(); j++) {
					if (!visited.contains(list.get(j))){
						visited.add(list.get(j));
						queue.add(list.get(j));
					}
				}
			}
		}
		return visited.size();
	}

	public int[] sortArrayByParityII(int[] nums) {
		int[] ans = new int[nums.length];
		int index0 = 0;
		int index1 = 1;
		for (int i = 0; i < nums.length; i++) {
			if (nums[i]%2==0){
				ans[index0] = nums[i];
				index0+=2;
			}else {
				ans[index1] = nums[i];
				index1+=2;
			}
		}
		return ans;
	}

	public int minStartValue20220809(int[] nums) {
		int min = 1;
		int sum = 0;
		for (int i = 0; i < nums.length; i++) {
			sum+=nums[i];
			min = Math.min(sum,min);
		}
		if (min<0){
			return -min+1;
		}else {
			return 1;
		}
	}

	/**
	 * 求解一个给定的方程，将x以字符串 "x=#value"的形式返回。该方程仅包含 '+' ， '-' 操作，变量x和其对应系数。
	 *
	 * 如果方程没有解，请返回"No solution"。如果方程有无限解，则返回 “Infinite solutions” 。
	 *
	 * 如果方程中只有一个解，要保证返回值 'x'是一个整数。
	 *
	 * 输入: equation = "x+5-3+x=6+x-2"
	 * 输出: "x=2"
	 *
	 *     public String solveEquation(String equation) {
	 *         int factor = 0, val = 0;
	 *         int index = 0, n = equation.length(), sign1 = 1; // 等式左边默认系数为正
	 *         while (index < n) {
	 *             if (equation.charAt(index) == '=') {
	 *                 sign1 = -1; // 等式右边默认系数为负
	 *                 index++;
	 *                 continue;
	 *             }
	 *
	 *             int sign2 = sign1, number = 0;
	 *             boolean valid = false; // 记录 number 是否有效
	 *             if (equation.charAt(index) == '-' || equation.charAt(index) == '+') { // 去掉前面的符号
	 *                 sign2 = (equation.charAt(index) == '-') ? -sign1 : sign1;
	 *                 index++;
	 *             }
	 *             while (index < n && Character.isDigit(equation.charAt(index))) {
	 *                 number = number * 10 + (equation.charAt(index) - '0');
	 *                 index++;
	 *                 valid = true;
	 *             }
	 *
	 *             if (index < n && equation.charAt(index) == 'x') { // 变量
	 *                 factor += valid ? sign2 * number : sign2;
	 *                 index++;
	 *             } else { // 数值
	 *                 val += sign2 * number;
	 *             }
	 *         }
	 *
	 *         if (factor == 0) {
	 *             return val == 0 ? "Infinite solutions" : "No solution";
	 *         }
	 *         return "x=" + (-val / factor);
	 *     }
	 */
	public String solveEquation(String equation) {
		StringBuilder sb = new StringBuilder();
		for (int i = 0; i < equation.length(); i++) {
			if (equation.charAt(i) == '-'){
				sb.append('+');
			}
			sb.append(equation.charAt(i));
		}
		String expression = sb.toString();
		String[] split = expression.split("=");
		String leftE = split[0];
		String rightE = split[1];
		String[] leftArr = leftE.split("\\+");
		String[] rightArr = rightE.split("\\+");
		int n1 = 0,n2 = 0;
		int x1 = 0,x2 = 0;
		for (int i = 0; i < leftArr.length; i++) {
			if (!leftArr[i].contains("x")){
				n1+= Integer.parseInt(leftArr[i]);
			}else {
				x1+= Integer.parseInt(leftArr[i].length()==1?"1":leftArr[i].substring(0,leftArr[i].length()-1));
			}
		}
		for (int i = 0; i < rightArr.length; i++) {
			if (!rightArr[i].contains("x")){
				n2+= Integer.parseInt(rightArr[i]);
			}else {
				x2+= Integer.parseInt(rightArr[i].length()==1?"1":rightArr[i].substring(0,rightArr[i].length()-1));
			}
		}
		n2 -= n1;
		x1 -= x2;
		if (x1==0){
			return "No solution";
		}
		try{
			n2 = n2/x1;
		}catch (Exception e){
			return "No solution";
		}
		return "x="+ n2;
	}

	public String reformat20220811(String s) {
		StringBuilder sb = new StringBuilder();
		StringBuilder numSb = new StringBuilder();
		StringBuilder charSb = new StringBuilder();
		for (int i = 0; i < s.length(); i++) {
			if (s.charAt(i) >= '0' && s.charAt(i) <= '9'){
				numSb.append(s.charAt(i));
			}else {
				charSb.append(s.charAt(i));
			}
		}
		if (Math.abs(numSb.length()-charSb.length())>1){
			return "";
		}
		if (numSb.length()>=charSb.length()){
			sb.append(numSb.charAt(0));
			numSb.deleteCharAt(0);
		}
		for (int i = 0; i < charSb.length(); i++) {
			sb.append(charSb.charAt(i));
			if (i<numSb.length()){
				sb.append(numSb.charAt(i));
			}
		}
		return sb.toString();
	}

	// 123123
	public List<List<Integer>> mergeSimilarItems(int[][] items1, int[][] items2) {
		Map<Integer,Integer> dict = new HashMap<>();
		for (int i = 0; i < items1.length; i++) {
			if (dict.containsKey(items1[i][0])){
				dict.put(items1[i][0],dict.get(items1[i][0])+items1[i][1]);
			}else {
				dict.put(items1[i][0],items1[i][1]);
			}
		}
		for (int i = 0; i < items2.length; i++) {
			if (dict.containsKey(items2[i][0])){
				dict.put(items2[i][0],dict.get(items2[i][0])+items2[i][1]);
			}else {
				dict.put(items2[i][0],items2[i][1]);
			}
		}
		List<List<Integer>> res = new ArrayList<>();
		dict.forEach((k,v)->{
			List<Integer> temp = new ArrayList<>();
			temp.add(k);
			temp.add(v);
			res.add(temp);
		});
		Collections.sort(res,(o1,o2)->o1.get(0)-o2.get(0));
		return res;
	}

	public long countBadPairs(int[] nums) {
		long res = 0;
		int n = nums.length;
		Map<Integer,Integer> map = new HashMap<>();
		for (int i = 0; i < n; i++) {
			int c = nums[i]-i;
			if (map.containsKey(c)){
				map.put(c,map.get(c)+1);
			}else {
				map.put(c,1);
			}
		}
		Set<Integer> keySet = map.keySet();
		for (Integer key : keySet) {
			Integer value = map.get(key);
			if (value>=2){
				res += value*1L*(value-1)/2;
			}
		}
		return n*1L*(n-1)/2 - res;
	}

	public int[] reversePrint(ListNode head) {
		List<Integer> list = new ArrayList<>();
		while (head!=null){
			list.add(head.val);
			head = head.next;
		}
		int[] ans = new int[list.size()];
		for (int i = 0; i < list.size(); i++) {
			ans[list.size()-1-i] = list.get(i);
		}
		return ans;
	}

	// 20220812 每日一题
	public List<List<Integer>> groupThePeople20220812(int[] groupSizes) {
		List<List<Integer>> ans = new ArrayList<>();
		Map<Integer,List<Integer>> dict = new HashMap<>();
		for (int i = 0; i < groupSizes.length; i++) {
			if (dict.containsKey(groupSizes[i])){
				dict.get(groupSizes[i]).add(i);
			}else {
				List<Integer> temp = new ArrayList<>();
				temp.add(i);
				dict.put(groupSizes[i],temp);
			}
		}
		dict.forEach((k,v)->{
			List<Integer> list = new ArrayList<>();
			for (int i = 0; i < v.size(); i++) {
				if (list.size()<k){
					list.add(v.get(i));
				}else {
					ans.add(list);
					list = new ArrayList<>();
					list.add(v.get(i));
				}
			}
			ans.add(list);
		});
		return ans;
	}

	public List<Integer> targetIndices(int[] nums, int target) {
		List<Integer> ans = new ArrayList<>();
		Arrays.sort(nums);
		for (int i = 0; i < nums.length; i++) {
			if (target==nums[i]){
				ans.add(i);
			}
		}
		return ans;
	}

	public int[] getAverages(int[] nums, int k) {
		if (k==0){
			return nums;
		}
		int n = nums.length;
		int[] ans = new int[n];
		if (n<=k && 2*k>n){
			Arrays.fill(ans,-1);
			return ans;
		}
		for (int i = 0; i < k && i < n; i++) {
			ans[i] = -1;
		}
		for (int i = nums.length-k; i < nums.length && i>=0; i++) {
			ans[i] = -1;
		}
		long sum = 0;
		for (int i = 0; i <2*k+1 && i<n; i++) {
			sum+=nums[i];
		}
		ans[k] = (int)(sum / (k*2+1));
		for (int i = k+1; i < nums.length-k && i>=0; i++) {
			sum-=nums[i-k-1];
			sum+=nums[i+k];
			ans[i] = (int)(sum / (k*2+1));
		}
		return ans;
	}

	public int minimumDeletions(int[] nums) {
		int min = Integer.MAX_VALUE, max = Integer.MIN_VALUE;
		int minIndex = -1, maxIndex = -1;
		int n = nums.length;
		for (int i = 0; i < n; i++) {
			if (min>nums[i]){
				min = nums[i];
				minIndex = i;
			}
			if (max<nums[i]){
				max = nums[i];
				maxIndex = i;
			}
		}
		if (minIndex>maxIndex){
			int t = minIndex;
			minIndex = maxIndex;
			maxIndex = t;
		}
		int ans = minIndex+1 + n-maxIndex;
		ans = Math.min(ans,maxIndex+1);
		ans = Math.min(ans,n-minIndex);
		return ans;
	}

	// LeetCode 20220815 每日一题
	static class MyCircularDeque {
		int capacity;
		int[] arr;
		int front;
		int rear;
		int used;

		public MyCircularDeque(int k) {
			capacity = k;
			arr = new int[k+1];
		}

		public boolean insertFront(int value) {
			if (isFull()){
				return false;
			}
			arr[front] = value;
			front = (front-1+capacity)%capacity;
			used++;
			return true;
		}

		public boolean insertLast(int value) {
			if (isFull()){
				return false;
			}
			rear = (rear+1+capacity)%capacity;
			arr[rear] = value;
			used++;
			return true;
		}

		public boolean deleteFront() {
			if (isEmpty()){
				return false;
			}
			front = (front+1+capacity)%capacity;
			used--;
			return true;
		}

		public boolean deleteLast() {
			if (isEmpty()){
				return false;
			}
			rear = (rear-1+capacity)%capacity;
			used--;
			return true;
		}

		public int getFront() {
			if (isEmpty()){
				return -1;
			}
			return arr[(front+1+capacity)%capacity];
		}

		public int getRear() {
			if (isEmpty()){
				return -1;
			}
			return arr[rear];
		}

		public boolean isEmpty() {
			return used == 0;
		}

		public boolean isFull() {
			return used == capacity;
		}
	}

	// LeetCode 第306场周赛 前三题
	public int[][] largestLocal(int[][] grid) {
		int n = grid.length;
		int[][] res = new int[n-2][n-2];
		for (int i = 0; i < n - 2; i++) {
			for (int j = 0; j < n - 2; j++) {
				int max = Integer.MIN_VALUE;
				for (int k = i; k < i+3; k++) {
					for (int l = j; l < j+3; l++) {
						max = Math.max(max,grid[k][l]);
					}
				}
				res[i][j] = max;
			}
		}
		return res;
	}

	public int edgeScore(int[] edges) {
		Map<Integer,Long> dict = new HashMap<>();
		for (int i = 0; i < edges.length; i++) {
			if (dict.containsKey(edges[i])){
				dict.put(edges[i],dict.get(edges[i])+i);
			}else {
				dict.put(edges[i],(long)i);
			}
		}
		long maxValue = Integer.MIN_VALUE;
		int res = 0;
		Set<Integer> keySet = dict.keySet();
		for (Integer key : keySet) {
			long value = dict.get(key);
			if (value>maxValue) {
				maxValue = value;
				res = key;
			}else if (value == maxValue) {
				res = Math.min(res,key);
			}
		}
		return res;
	}

	List<String> smallestNumberList = new ArrayList<>();
	public String smallestNumber(String pattern) {
		int n = pattern.length();
		enumDfs(n+1,new boolean[n+2],new StringBuilder());
		for (int i = 0; i < smallestNumberList.size() ; i++) {
			String s = smallestNumberList.get(i);
			int flag = 0;
			for (int j = 0; j < n; j++) {
				//	如果pattern[i] == 'I'，那么num[i] < num[i + 1]。
				//	如果pattern[i] == 'D'，那么num[i] > num[i + 1]。
				if (pattern.charAt(j) == 'I'){
					if (s.charAt(j)>=s.charAt(j+1)){
						flag = 1;
						break;
					}
				}else {
					if (s.charAt(j)<=s.charAt(j+1)){
						flag = 1;
						break;
					}
				}
			}
			if (flag==0){
				return s;
			}
		}
		return "";
	}
	// 全排列
	public void enumDfs(int max,boolean[] vised,StringBuilder sb){
		if (sb.length()==max){
			smallestNumberList.add(sb.toString());
			return;
		}
		for (int i = 1; i <= max; i++) {
			if (!vised[i]){
				sb.append(i);
				vised[i] = true;
				enumDfs(max,vised,sb);
				sb.deleteCharAt(sb.length()-1);
				vised[i] = false;
			}
		}
	}
	// LeetCode 20220816 每日一题
	class OrderedStream {
		int pre = 1;
		String[] arr;
		public OrderedStream(int n) {
			arr = new String[n+5];
		}
		public List<String> insert(int idKey, String value) {
			arr[idKey] = value;
			List<String> res = new ArrayList<>();
			if (idKey==pre){
				while (arr[idKey]!=null){
					res.add(arr[idKey++]);
				}
				pre = idKey;
			}
			return res;
		}
	}
	public static void main(String[] args) {
		DemoApplicationTests t = new DemoApplicationTests();
		System.out.println(t.smallestNumber("DDDDDDDD"));
		int t1 = 99999;
		int t2 = 99999;
		System.out.println(t1*1.0*t2);
	}
	/*<pre><code class="language-java line-numbers">代码内容</code></pre>*/

	//map排序方式
		/*Map<String, Integer> map = new HashMap<>();
		while (!queue.isEmpty()) {
			Integer idd = queue.poll();
			for (int i = 0; i < watchedVideos.get(idd).size(); i++) {
				map.put(watchedVideos.get(idd).get(i), map.getOrDefault(watchedVideos.get(idd).get(i), 0) + 1);
			}
		}

		PriorityQueue<Pair<String, Integer>> priorityQueue = new PriorityQueue<>((t1, t2) -> {
			if (t1.getValue().equals(t2.getValue())) {
				return t1.getKey().compareTo(t2.getKey());
			} else {
				return t1.getValue().compareTo(t2.getValue());
			}
		});
		map.forEach((key, value) -> priorityQueue.add(new Pair<>(key, value)));
		List<String> ans = new ArrayList<>();
		while (!priorityQueue.isEmpty()) {
			ans.add(priorityQueue.poll().getKey());
		}
		return ans;*/


/*
*

*
* */

}
